{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"@babel/runtime/regenerator\");\n\nvar _defineProperty = require(\"@babel/runtime/helpers/defineProperty\");\n\nvar _slicedToArray = require(\"@babel/runtime/helpers/slicedToArray\");\n\nvar _classCallCheck = require(\"@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"@babel/runtime/helpers/createClass\");\n\nvar _inherits = require(\"@babel/runtime/helpers/inherits\");\n\nvar _possibleConstructorReturn = require(\"@babel/runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"@babel/runtime/helpers/getPrototypeOf\");\n\nfunction _createForOfIteratorHelperLoose(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (it) return (it = it.call(o)).next.bind(it); if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nvar AbstractConsumer = require(\"./AbstractConsumer\");\n\nvar _require = require(\"./constants\"),\n    EMPTY_POSITION = _require.EMPTY_POSITION,\n    FIRST_COLUMN = _require.FIRST_COLUMN,\n    FIRST_LINE = _require.FIRST_LINE;\n\nvar createConsumer = require(\"./createConsumer\");\n\nvar _require2 = require(\"./positionMath\"),\n    subtractOffsetFromPosition = _require2.subtractOffsetFromPosition;\n\nvar _require3 = require(\"./search\"),\n    greatestLowerBound = _require3.greatestLowerBound;\n\nvar _require4 = require(\"ob1\"),\n    add = _require4.add,\n    add0 = _require4.add0,\n    get0 = _require4.get0,\n    get1 = _require4.get1,\n    sub = _require4.sub,\n    sub1 = _require4.sub1;\n\nvar SectionsConsumer = function (_AbstractConsumer) {\n  _inherits(SectionsConsumer, _AbstractConsumer);\n\n  var _super = _createSuper(SectionsConsumer);\n\n  function SectionsConsumer(sourceMap) {\n    var _this;\n\n    _classCallCheck(this, SectionsConsumer);\n\n    _this = _super.call(this, sourceMap);\n    _this._consumers = sourceMap.sections.map(function (section, index) {\n      var generatedOffset = {\n        lines: add0(section.offset.line),\n        columns: add0(section.offset.column)\n      };\n      var consumer = createConsumer(section.map);\n      return [generatedOffset, consumer];\n    });\n    return _this;\n  }\n\n  _createClass(SectionsConsumer, [{\n    key: \"originalPositionFor\",\n    value: function originalPositionFor(generatedPosition) {\n      var _ref = this._consumerForPosition(generatedPosition) || [],\n          _ref2 = _slicedToArray(_ref, 2),\n          generatedOffset = _ref2[0],\n          consumer = _ref2[1];\n\n      if (!consumer) {\n        return _objectSpread({}, EMPTY_POSITION);\n      }\n\n      return consumer.originalPositionFor(subtractOffsetFromPosition(generatedPosition, generatedOffset));\n    }\n  }, {\n    key: \"generatedMappings\",\n    value: _regeneratorRuntime.mark(function generatedMappings() {\n      var _iterator, _step, _ref3, _ref4, generatedOffset, consumer, first, _iterator2, _step2, mapping;\n\n      return _regeneratorRuntime.wrap(function generatedMappings$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              _iterator = _createForOfIteratorHelperLoose(this._consumers);\n\n            case 1:\n              if ((_step = _iterator()).done) {\n                _context.next = 20;\n                break;\n              }\n\n              _ref3 = _step.value;\n              _ref4 = _slicedToArray(_ref3, 2);\n              generatedOffset = _ref4[0];\n              consumer = _ref4[1];\n              first = true;\n              _iterator2 = _createForOfIteratorHelperLoose(consumer.generatedMappings());\n\n            case 8:\n              if ((_step2 = _iterator2()).done) {\n                _context.next = 18;\n                break;\n              }\n\n              mapping = _step2.value;\n\n              if (!(first && (get1(mapping.generatedLine) > 1 || get0(mapping.generatedColumn) > 0))) {\n                _context.next = 13;\n                break;\n              }\n\n              _context.next = 13;\n              return {\n                generatedLine: FIRST_LINE,\n                generatedColumn: FIRST_COLUMN,\n                source: null,\n                name: null,\n                originalLine: null,\n                originalColumn: null\n              };\n\n            case 13:\n              first = false;\n              _context.next = 16;\n              return _objectSpread(_objectSpread({}, mapping), {}, {\n                generatedLine: add(mapping.generatedLine, generatedOffset.lines),\n                generatedColumn: add(mapping.generatedColumn, generatedOffset.columns)\n              });\n\n            case 16:\n              _context.next = 8;\n              break;\n\n            case 18:\n              _context.next = 1;\n              break;\n\n            case 20:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, generatedMappings, this);\n    })\n  }, {\n    key: \"_consumerForPosition\",\n    value: function _consumerForPosition(generatedPosition) {\n      var line = generatedPosition.line,\n          column = generatedPosition.column;\n\n      if (line == null || column == null) {\n        return null;\n      }\n\n      var index = greatestLowerBound(this._consumers, generatedPosition, function (position, _ref5) {\n        var _ref6 = _slicedToArray(_ref5, 1),\n            offset = _ref6[0];\n\n        var line0 = sub1(line);\n        var column0 = column;\n\n        if (line0 === offset.lines) {\n          return get0(sub(column0, offset.columns));\n        }\n\n        return get0(sub(line0, offset.lines));\n      });\n      return index != null ? this._consumers[index] : null;\n    }\n  }, {\n    key: \"sourceContentFor\",\n    value: function sourceContentFor(source, nullOnMissing) {\n      for (var _iterator3 = _createForOfIteratorHelperLoose(this._consumers), _step3; !(_step3 = _iterator3()).done;) {\n        var _ref7 = _step3.value;\n\n        var _ref8 = _slicedToArray(_ref7, 2);\n\n        var _ = _ref8[0];\n        var consumer = _ref8[1];\n        var content = consumer.sourceContentFor(source, nullOnMissing);\n\n        if (content != null) {\n          return content;\n        }\n      }\n\n      return null;\n    }\n  }]);\n\n  return SectionsConsumer;\n}(AbstractConsumer);\n\nmodule.exports = SectionsConsumer;","map":{"version":3,"names":["AbstractConsumer","require","EMPTY_POSITION","FIRST_COLUMN","FIRST_LINE","createConsumer","subtractOffsetFromPosition","greatestLowerBound","add","add0","get0","get1","sub","sub1","SectionsConsumer","sourceMap","_consumers","sections","map","section","index","generatedOffset","lines","offset","line","columns","column","consumer","generatedPosition","_consumerForPosition","originalPositionFor","first","generatedMappings","mapping","generatedLine","generatedColumn","source","name","originalLine","originalColumn","position","line0","column0","nullOnMissing","_","content","sourceContentFor","module","exports"],"sources":["/Users/hozaifa/Documents/Uni App Github/node_modules/@react-native-community/cli-plugin-metro/node_modules/metro-source-map/src/Consumer/SectionsConsumer.js"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *\n * @format\n */\n\"use strict\";\n\nconst AbstractConsumer = require(\"./AbstractConsumer\");\n\nconst { EMPTY_POSITION, FIRST_COLUMN, FIRST_LINE } = require(\"./constants\");\n\nconst createConsumer = require(\"./createConsumer\");\n\nconst { subtractOffsetFromPosition } = require(\"./positionMath\");\n\nconst { greatestLowerBound } = require(\"./search\");\n\nconst { add, add0, get0, get1, sub, sub1 } = require(\"ob1\");\n/**\n * A source map consumer that supports \"indexed\" source maps (that have a\n * `sections` field and no top-level mappings).\n */\n\nclass SectionsConsumer extends AbstractConsumer {\n  constructor(sourceMap) {\n    super(sourceMap);\n    this._consumers = sourceMap.sections.map((section, index) => {\n      const generatedOffset = {\n        lines: add0(section.offset.line),\n        columns: add0(section.offset.column),\n      };\n      const consumer = createConsumer(section.map);\n      return [generatedOffset, consumer];\n    });\n  }\n\n  originalPositionFor(generatedPosition) {\n    const [generatedOffset, consumer] =\n      this._consumerForPosition(generatedPosition) || [];\n\n    if (!consumer) {\n      return { ...EMPTY_POSITION };\n    }\n\n    return consumer.originalPositionFor(\n      subtractOffsetFromPosition(generatedPosition, generatedOffset)\n    );\n  }\n\n  *generatedMappings() {\n    for (const [generatedOffset, consumer] of this._consumers) {\n      let first = true;\n\n      for (const mapping of consumer.generatedMappings()) {\n        if (\n          first &&\n          (get1(mapping.generatedLine) > 1 || get0(mapping.generatedColumn) > 0)\n        ) {\n          yield {\n            generatedLine: FIRST_LINE,\n            generatedColumn: FIRST_COLUMN,\n            source: null,\n            name: null,\n            originalLine: null,\n            originalColumn: null,\n          };\n        }\n\n        first = false;\n        yield {\n          ...mapping,\n          generatedLine: add(mapping.generatedLine, generatedOffset.lines),\n          generatedColumn: add(\n            mapping.generatedColumn,\n            generatedOffset.columns\n          ),\n        };\n      }\n    }\n  }\n\n  _consumerForPosition(generatedPosition) {\n    const { line, column } = generatedPosition;\n\n    if (line == null || column == null) {\n      return null;\n    }\n\n    const index = greatestLowerBound(\n      this._consumers,\n      generatedPosition,\n      (position, [offset]) => {\n        const line0 = sub1(line);\n        const column0 = column;\n\n        if (line0 === offset.lines) {\n          return get0(sub(column0, offset.columns));\n        }\n\n        return get0(sub(line0, offset.lines));\n      }\n    );\n    return index != null ? this._consumers[index] : null;\n  }\n\n  sourceContentFor(source, nullOnMissing) {\n    for (const [_, consumer] of this._consumers) {\n      const content = consumer.sourceContentFor(source, nullOnMissing);\n\n      if (content != null) {\n        return content;\n      }\n    }\n\n    return null;\n  }\n}\n\nmodule.exports = SectionsConsumer;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}