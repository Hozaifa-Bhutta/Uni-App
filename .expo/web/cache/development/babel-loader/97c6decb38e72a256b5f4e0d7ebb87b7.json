{"ast":null,"code":"\"use strict\";\n\nvar _slicedToArray = require(\"@babel/runtime/helpers/slicedToArray\");\n\nvar _toConsumableArray = require(\"@babel/runtime/helpers/toConsumableArray\");\n\nvar _classCallCheck = require(\"@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"@babel/runtime/helpers/createClass\");\n\nfunction _createForOfIteratorHelperLoose(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (it) return (it = it.call(o)).next.bind(it); if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nvar _require = require(\"metro-source-map\"),\n    normalizeSourcePath = _require.normalizeSourcePath;\n\nvar vlq = require(\"vlq\");\n\nvar METADATA_FIELD_FUNCTIONS = 0;\n\nvar SourceMetadataMapConsumer = function () {\n  function SourceMetadataMapConsumer(map) {\n    var normalizeSourceFn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : normalizeSourcePath;\n\n    _classCallCheck(this, SourceMetadataMapConsumer);\n\n    this._sourceMap = map;\n    this._decodedFunctionMapCache = new Map();\n    this._normalizeSource = normalizeSourceFn;\n  }\n\n  _createClass(SourceMetadataMapConsumer, [{\n    key: \"functionNameFor\",\n    value: function functionNameFor(_ref) {\n      var line = _ref.line,\n          column = _ref.column,\n          source = _ref.source;\n\n      if (source && line != null && column != null) {\n        var mappings = this._getFunctionMappings(source);\n\n        if (mappings) {\n          var mapping = findEnclosingMapping(mappings, {\n            line: line,\n            column: column\n          });\n\n          if (mapping) {\n            return mapping.name;\n          }\n        }\n      }\n\n      return null;\n    }\n  }, {\n    key: \"toArray\",\n    value: function toArray(sources) {\n      var metadataBySource = this._getMetadataBySource();\n\n      var encoded = [];\n\n      for (var _iterator = _createForOfIteratorHelperLoose(sources), _step; !(_step = _iterator()).done;) {\n        var source = _step.value;\n        encoded.push(metadataBySource[source] || null);\n      }\n\n      return encoded;\n    }\n  }, {\n    key: \"_getMetadataBySource\",\n    value: function _getMetadataBySource() {\n      if (!this._metadataBySource) {\n        this._metadataBySource = this._getMetadataObjectsBySourceNames(this._sourceMap);\n      }\n\n      return this._metadataBySource;\n    }\n  }, {\n    key: \"_getFunctionMappings\",\n    value: function _getFunctionMappings(source) {\n      if (this._decodedFunctionMapCache.has(source)) {\n        return this._decodedFunctionMapCache.get(source);\n      }\n\n      var parsedFunctionMap = null;\n\n      var metadataBySource = this._getMetadataBySource();\n\n      if (Object.prototype.hasOwnProperty.call(metadataBySource, source)) {\n        var metadata = metadataBySource[source] || [];\n        parsedFunctionMap = decodeFunctionMap(metadata[METADATA_FIELD_FUNCTIONS]);\n      }\n\n      this._decodedFunctionMapCache.set(source, parsedFunctionMap);\n\n      return parsedFunctionMap;\n    }\n  }, {\n    key: \"_getMetadataObjectsBySourceNames\",\n    value: function _getMetadataObjectsBySourceNames(map) {\n      var _this = this;\n\n      if (map.mappings === undefined) {\n        var indexMap = map;\n        return Object.assign.apply(Object, [{}].concat(_toConsumableArray(indexMap.sections.map(function (section) {\n          return _this._getMetadataObjectsBySourceNames(section.map);\n        }))));\n      }\n\n      if (\"x_facebook_sources\" in map) {\n        var basicMap = map;\n        return (basicMap.x_facebook_sources || []).reduce(function (acc, metadata, index) {\n          var source = basicMap.sources[index];\n\n          if (source != null) {\n            source = _this._normalizeSource(source, basicMap);\n            acc[source] = metadata;\n          }\n\n          return acc;\n        }, {});\n      }\n\n      return {};\n    }\n  }]);\n\n  return SourceMetadataMapConsumer;\n}();\n\nfunction decodeFunctionMap(functionMap) {\n  if (!functionMap) {\n    return [];\n  }\n\n  var parsed = [];\n  var line = 1;\n  var nameIndex = 0;\n\n  for (var _iterator2 = _createForOfIteratorHelperLoose(functionMap.mappings.split(\";\")), _step2; !(_step2 = _iterator2()).done;) {\n    var lineMappings = _step2.value;\n    var column = 0;\n\n    for (var _iterator3 = _createForOfIteratorHelperLoose(lineMappings.split(\",\")), _step3; !(_step3 = _iterator3()).done;) {\n      var mapping = _step3.value;\n\n      var _vlq$decode = vlq.decode(mapping),\n          _vlq$decode2 = _slicedToArray(_vlq$decode, 3),\n          columnDelta = _vlq$decode2[0],\n          nameDelta = _vlq$decode2[1],\n          _vlq$decode2$ = _vlq$decode2[2],\n          lineDelta = _vlq$decode2$ === void 0 ? 0 : _vlq$decode2$;\n\n      line += lineDelta;\n      nameIndex += nameDelta;\n      column += columnDelta;\n      parsed.push({\n        line: line,\n        column: column,\n        name: functionMap.names[nameIndex]\n      });\n    }\n  }\n\n  return parsed;\n}\n\nfunction findEnclosingMapping(mappings, target) {\n  var first = 0;\n  var it = 0;\n  var count = mappings.length;\n  var step;\n\n  while (count > 0) {\n    it = first;\n    step = Math.floor(count / 2);\n    it += step;\n\n    if (comparePositions(target, mappings[it]) >= 0) {\n      first = ++it;\n      count -= step + 1;\n    } else {\n      count = step;\n    }\n  }\n\n  return first ? mappings[first - 1] : null;\n}\n\nfunction comparePositions(a, b) {\n  if (a.line === b.line) {\n    return a.column - b.column;\n  }\n\n  return a.line - b.line;\n}\n\nmodule.exports = SourceMetadataMapConsumer;","map":{"version":3,"names":["require","normalizeSourcePath","vlq","METADATA_FIELD_FUNCTIONS","SourceMetadataMapConsumer","map","normalizeSourceFn","_sourceMap","_decodedFunctionMapCache","Map","_normalizeSource","line","column","source","mappings","_getFunctionMappings","mapping","findEnclosingMapping","name","sources","metadataBySource","_getMetadataBySource","encoded","push","_metadataBySource","_getMetadataObjectsBySourceNames","has","get","parsedFunctionMap","Object","prototype","hasOwnProperty","call","metadata","decodeFunctionMap","set","undefined","indexMap","assign","sections","section","basicMap","x_facebook_sources","reduce","acc","index","functionMap","parsed","nameIndex","split","lineMappings","decode","columnDelta","nameDelta","lineDelta","names","target","first","it","count","length","step","Math","floor","comparePositions","a","b","module","exports"],"sources":["/Users/hozaifa/Documents/Uni App Github/node_modules/@react-native-community/cli-plugin-metro/node_modules/metro-symbolicate/src/SourceMetadataMapConsumer.js"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *\n * @format\n */\n\"use strict\";\n\nconst { normalizeSourcePath } = require(\"metro-source-map\");\n\nconst vlq = require(\"vlq\");\n\nconst METADATA_FIELD_FUNCTIONS = 0;\n\n/**\n * Consumes the `x_facebook_sources` metadata field from a source map and\n * exposes various queries on it.\n *\n * By default, source names are normalized using the same logic that the\n * `source-map@0.5.6` package uses internally. This is crucial for keeping the\n * sources list in sync with a `SourceMapConsumer` instance.\n\n * If you're using this with a different source map reader (e.g. one that\n * doesn't normalize source names at all), you can switch out the normalization\n * function in the constructor, e.g.\n *\n *     new SourceMetadataMapConsumer(map, source => source) // Don't normalize\n */\nclass SourceMetadataMapConsumer {\n  constructor(map, normalizeSourceFn = normalizeSourcePath) {\n    this._sourceMap = map;\n    this._decodedFunctionMapCache = new Map();\n    this._normalizeSource = normalizeSourceFn;\n  }\n\n  /**\n   * Retrieves a human-readable name for the function enclosing a particular\n   * source location.\n   *\n   * When used with the `source-map` package, you'll first use\n   * `SourceMapConsumer#originalPositionFor` to retrieve a source location,\n   * then pass that location to `functionNameFor`.\n   */\n  functionNameFor({ line, column, source }) {\n    if (source && line != null && column != null) {\n      const mappings = this._getFunctionMappings(source);\n\n      if (mappings) {\n        const mapping = findEnclosingMapping(mappings, {\n          line,\n          column,\n        });\n\n        if (mapping) {\n          return mapping.name;\n        }\n      }\n    }\n\n    return null;\n  }\n  /**\n   * Returns this map's source metadata as a new array with the same order as\n   * `sources`.\n   *\n   * This array can be used as the `x_facebook_sources` field of a map whose\n   * `sources` field is the array that was passed into this method.\n   */\n\n  toArray(sources) {\n    const metadataBySource = this._getMetadataBySource();\n\n    const encoded = [];\n\n    for (const source of sources) {\n      encoded.push(metadataBySource[source] || null);\n    }\n\n    return encoded;\n  }\n  /**\n   * Prepares and caches a lookup table of metadata by source name.\n   */\n\n  _getMetadataBySource() {\n    if (!this._metadataBySource) {\n      this._metadataBySource = this._getMetadataObjectsBySourceNames(\n        this._sourceMap\n      );\n    }\n\n    return this._metadataBySource;\n  }\n  /**\n   * Decodes the function name mappings for the given source if needed, and\n   * retrieves a sorted, searchable array of mappings.\n   */\n\n  _getFunctionMappings(source) {\n    if (this._decodedFunctionMapCache.has(source)) {\n      return this._decodedFunctionMapCache.get(source);\n    }\n\n    let parsedFunctionMap = null;\n\n    const metadataBySource = this._getMetadataBySource(); // $FlowFixMe[method-unbinding] added when improving typing for this parameters\n\n    if (Object.prototype.hasOwnProperty.call(metadataBySource, source)) {\n      const metadata = metadataBySource[source] || [];\n      parsedFunctionMap = decodeFunctionMap(metadata[METADATA_FIELD_FUNCTIONS]);\n    }\n\n    this._decodedFunctionMapCache.set(source, parsedFunctionMap);\n\n    return parsedFunctionMap;\n  }\n  /**\n   * Collects source metadata from the given map using the current source name\n   * normalization function. Handles both index maps (with sections) and plain\n   * maps.\n   *\n   * NOTE: If any sources are repeated in the map (which shouldn't happen in\n   * Metro, but is technically possible because of index maps) we only keep the\n   * metadata from the last occurrence of any given source.\n   */\n\n  _getMetadataObjectsBySourceNames(map) {\n    // eslint-disable-next-line lint/strictly-null\n    if (map.mappings === undefined) {\n      const indexMap = map;\n      return Object.assign(\n        {},\n        ...indexMap.sections.map((section) =>\n          this._getMetadataObjectsBySourceNames(section.map)\n        )\n      );\n    }\n\n    if (\"x_facebook_sources\" in map) {\n      const basicMap = map;\n      return (basicMap.x_facebook_sources || []).reduce(\n        (acc, metadata, index) => {\n          let source = basicMap.sources[index];\n\n          if (source != null) {\n            source = this._normalizeSource(source, basicMap);\n            acc[source] = metadata;\n          }\n\n          return acc;\n        },\n        {}\n      );\n    }\n\n    return {};\n  }\n}\n\nfunction decodeFunctionMap(functionMap) {\n  if (!functionMap) {\n    return [];\n  }\n\n  const parsed = [];\n  let line = 1;\n  let nameIndex = 0;\n\n  for (const lineMappings of functionMap.mappings.split(\";\")) {\n    let column = 0;\n\n    for (const mapping of lineMappings.split(\",\")) {\n      const [columnDelta, nameDelta, lineDelta = 0] = vlq.decode(mapping);\n      line += lineDelta;\n      nameIndex += nameDelta;\n      column += columnDelta;\n      parsed.push({\n        line,\n        column,\n        name: functionMap.names[nameIndex],\n      });\n    }\n  }\n\n  return parsed;\n}\n\nfunction findEnclosingMapping(mappings, target) {\n  let first = 0;\n  let it = 0;\n  let count = mappings.length;\n  let step;\n\n  while (count > 0) {\n    it = first;\n    step = Math.floor(count / 2);\n    it += step;\n\n    if (comparePositions(target, mappings[it]) >= 0) {\n      first = ++it;\n      count -= step + 1;\n    } else {\n      count = step;\n    }\n  }\n\n  return first ? mappings[first - 1] : null;\n}\n\nfunction comparePositions(a, b) {\n  if (a.line === b.line) {\n    return a.column - b.column;\n  }\n\n  return a.line - b.line;\n}\n\nmodule.exports = SourceMetadataMapConsumer;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}