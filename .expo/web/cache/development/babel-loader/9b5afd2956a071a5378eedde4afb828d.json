{"ast":null,"code":"\"use strict\";\n\nvar _slicedToArray = require(\"@babel/runtime/helpers/slicedToArray\");\n\nvar _defineProperty = require(\"@babel/runtime/helpers/defineProperty\");\n\nvar _regeneratorRuntime = require(\"@babel/runtime/regenerator\");\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nfunction _createForOfIteratorHelperLoose(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (it) return (it = it.call(o)).next.bind(it); if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nvar nullthrows = require(\"nullthrows\");\n\nfunction getInternalOptions(_ref) {\n  var transform = _ref.transform,\n      resolve = _ref.resolve,\n      onProgress = _ref.onProgress,\n      experimentalImportBundleSupport = _ref.experimentalImportBundleSupport,\n      shallow = _ref.shallow;\n  var numProcessed = 0;\n  var total = 0;\n  return {\n    experimentalImportBundleSupport: experimentalImportBundleSupport,\n    transform: transform,\n    resolve: resolve,\n    onDependencyAdd: function onDependencyAdd() {\n      return onProgress && onProgress(numProcessed, ++total);\n    },\n    onDependencyAdded: function onDependencyAdded() {\n      return onProgress && onProgress(++numProcessed, total);\n    },\n    shallow: shallow\n  };\n}\n\nfunction traverseDependencies(paths, graph, options) {\n  var delta, internalOptions, _iterator, _step, path, added, modified, deleted, _iterator2, _step2, _path, _iterator3, _step3, _path2, _iterator4, _step4, _path3;\n\n  return _regeneratorRuntime.async(function traverseDependencies$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          delta = {\n            added: new Set(),\n            modified: new Set(),\n            deleted: new Set(),\n            inverseDependencies: new Map()\n          };\n          internalOptions = getInternalOptions(options);\n          _iterator = _createForOfIteratorHelperLoose(paths);\n\n        case 3:\n          if ((_step = _iterator()).done) {\n            _context.next = 11;\n            break;\n          }\n\n          path = _step.value;\n\n          if (!graph.dependencies.get(path)) {\n            _context.next = 9;\n            break;\n          }\n\n          delta.modified.add(path);\n          _context.next = 9;\n          return _regeneratorRuntime.awrap(traverseDependenciesForSingleFile(path, graph, delta, internalOptions));\n\n        case 9:\n          _context.next = 3;\n          break;\n\n        case 11:\n          added = new Map();\n          modified = new Map();\n          deleted = new Set();\n\n          for (_iterator2 = _createForOfIteratorHelperLoose(delta.deleted); !(_step2 = _iterator2()).done;) {\n            _path = _step2.value;\n\n            if (!delta.added.has(_path)) {\n              deleted.add(_path);\n            }\n\n            delta.modified.delete(_path);\n            delta.added.delete(_path);\n          }\n\n          for (_iterator3 = _createForOfIteratorHelperLoose(delta.added); !(_step3 = _iterator3()).done;) {\n            _path2 = _step3.value;\n            added.set(_path2, nullthrows(graph.dependencies.get(_path2)));\n          }\n\n          for (_iterator4 = _createForOfIteratorHelperLoose(delta.modified); !(_step4 = _iterator4()).done;) {\n            _path3 = _step4.value;\n\n            if (!delta.added.has(_path3)) {\n              modified.set(_path3, nullthrows(graph.dependencies.get(_path3)));\n            }\n          }\n\n          return _context.abrupt(\"return\", {\n            added: added,\n            modified: modified,\n            deleted: deleted\n          });\n\n        case 18:\n        case \"end\":\n          return _context.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\n\nfunction initialTraverseDependencies(graph, options) {\n  var delta, internalOptions;\n  return _regeneratorRuntime.async(function initialTraverseDependencies$(_context2) {\n    while (1) {\n      switch (_context2.prev = _context2.next) {\n        case 0:\n          delta = {\n            added: new Set(),\n            modified: new Set(),\n            deleted: new Set(),\n            inverseDependencies: new Map()\n          };\n          internalOptions = getInternalOptions(options);\n          _context2.next = 4;\n          return _regeneratorRuntime.awrap(Promise.all(graph.entryPoints.map(function (path) {\n            return traverseDependenciesForSingleFile(path, graph, delta, internalOptions);\n          })));\n\n        case 4:\n          reorderGraph(graph, {\n            shallow: options.shallow\n          });\n          return _context2.abrupt(\"return\", {\n            added: graph.dependencies,\n            modified: new Map(),\n            deleted: new Set()\n          });\n\n        case 6:\n        case \"end\":\n          return _context2.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\n\nfunction traverseDependenciesForSingleFile(path, graph, delta, options) {\n  return _regeneratorRuntime.async(function traverseDependenciesForSingleFile$(_context3) {\n    while (1) {\n      switch (_context3.prev = _context3.next) {\n        case 0:\n          options.onDependencyAdd();\n          _context3.next = 3;\n          return _regeneratorRuntime.awrap(processModule(path, graph, delta, options));\n\n        case 3:\n          options.onDependencyAdded();\n\n        case 4:\n        case \"end\":\n          return _context3.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\n\nfunction processModule(path, graph, delta, options) {\n  var result, currentDependencies, previousModule, previousDependencies, module, _iterator5, _step5, _ref2, _ref3, relativePath, dependency, promises, _iterator6, _step6, _ref8, _ref9, _relativePath, _dependency;\n\n  return _regeneratorRuntime.async(function processModule$(_context4) {\n    while (1) {\n      switch (_context4.prev = _context4.next) {\n        case 0:\n          _context4.next = 2;\n          return _regeneratorRuntime.awrap(options.transform(path));\n\n        case 2:\n          result = _context4.sent;\n          currentDependencies = resolveDependencies(path, result.dependencies, options);\n          previousModule = graph.dependencies.get(path) || {\n            inverseDependencies: delta.inverseDependencies.get(path) || new Set(),\n            path: path\n          };\n          previousDependencies = previousModule.dependencies || new Map();\n          module = _objectSpread(_objectSpread({}, previousModule), {}, {\n            dependencies: new Map(),\n            getSource: result.getSource,\n            output: result.output\n          });\n          graph.dependencies.set(module.path, module);\n\n          for (_iterator5 = _createForOfIteratorHelperLoose(currentDependencies); !(_step5 = _iterator5()).done;) {\n            _ref2 = _step5.value;\n            _ref3 = _slicedToArray(_ref2, 2);\n            relativePath = _ref3[0];\n            dependency = _ref3[1];\n            module.dependencies.set(relativePath, dependency);\n          }\n\n          Array.from(previousDependencies.entries()).filter(function (_ref4) {\n            var _ref5 = _slicedToArray(_ref4, 2),\n                relativePath = _ref5[0],\n                dependency = _ref5[1];\n\n            return !currentDependencies.has(relativePath) || nullthrows(currentDependencies.get(relativePath)).absolutePath !== dependency.absolutePath;\n          }).forEach(function (_ref6) {\n            var _ref7 = _slicedToArray(_ref6, 2),\n                relativePath = _ref7[0],\n                dependency = _ref7[1];\n\n            return removeDependency(module, dependency.absolutePath, graph, delta, new Set());\n          });\n          promises = [];\n\n          for (_iterator6 = _createForOfIteratorHelperLoose(currentDependencies); !(_step6 = _iterator6()).done;) {\n            _ref8 = _step6.value;\n            _ref9 = _slicedToArray(_ref8, 2);\n            _relativePath = _ref9[0];\n            _dependency = _ref9[1];\n\n            if (!options.shallow) {\n              if (options.experimentalImportBundleSupport && _dependency.data.data.asyncType != null) {\n                graph.importBundleNames.add(_dependency.absolutePath);\n              } else if (!previousDependencies.has(_relativePath) || nullthrows(previousDependencies.get(_relativePath)).absolutePath !== _dependency.absolutePath) {\n                promises.push(addDependency(module, _dependency.absolutePath, graph, delta, options));\n              }\n            }\n          }\n\n          _context4.prev = 12;\n          _context4.next = 15;\n          return _regeneratorRuntime.awrap(Promise.all(promises));\n\n        case 15:\n          _context4.next = 21;\n          break;\n\n        case 17:\n          _context4.prev = 17;\n          _context4.t0 = _context4[\"catch\"](12);\n          module.dependencies = previousDependencies;\n          throw _context4.t0;\n\n        case 21:\n          return _context4.abrupt(\"return\", module);\n\n        case 22:\n        case \"end\":\n          return _context4.stop();\n      }\n    }\n  }, null, null, [[12, 17]], Promise);\n}\n\nfunction addDependency(parentModule, path, graph, delta, options) {\n  var existingModule, inverse, module;\n  return _regeneratorRuntime.async(function addDependency$(_context5) {\n    while (1) {\n      switch (_context5.prev = _context5.next) {\n        case 0:\n          existingModule = graph.dependencies.get(path);\n\n          if (!existingModule) {\n            _context5.next = 4;\n            break;\n          }\n\n          existingModule.inverseDependencies.add(parentModule.path);\n          return _context5.abrupt(\"return\");\n\n        case 4:\n          inverse = delta.inverseDependencies.get(path);\n\n          if (!inverse) {\n            _context5.next = 8;\n            break;\n          }\n\n          inverse.add(parentModule.path);\n          return _context5.abrupt(\"return\");\n\n        case 8:\n          delta.added.add(path);\n          delta.inverseDependencies.set(path, new Set([parentModule.path]));\n          options.onDependencyAdd();\n          _context5.next = 13;\n          return _regeneratorRuntime.awrap(processModule(path, graph, delta, options));\n\n        case 13:\n          module = _context5.sent;\n          graph.dependencies.set(module.path, module);\n          module.inverseDependencies.add(parentModule.path);\n          options.onDependencyAdded();\n\n        case 17:\n        case \"end\":\n          return _context5.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\n\nfunction getAllTopLevelInverseDependencies(inverseDependencies, graph, currModule, visited) {\n  if (visited.has(currModule)) {\n    return new Set();\n  }\n\n  visited.add(currModule);\n\n  if (!inverseDependencies.size) {\n    return new Set([currModule]);\n  }\n\n  return Array.from(inverseDependencies).filter(function (inverseDep) {\n    return graph.dependencies.has(inverseDep);\n  }).reduce(function (acc, inverseDep) {\n    var mod = graph.dependencies.get(inverseDep);\n\n    if (!mod) {\n      return acc;\n    }\n\n    getAllTopLevelInverseDependencies(mod.inverseDependencies, graph, inverseDep, visited).forEach(function (x) {\n      acc.add(x);\n    });\n    return acc;\n  }, new Set());\n}\n\nfunction canSafelyRemoveFromParentModule(inverseDependencies, parentModule, graph, canBeRemovedSafely, delta) {\n  var visited = new Set();\n  var topInverseDependencies = getAllTopLevelInverseDependencies(inverseDependencies, graph, \"\", visited);\n\n  if (!topInverseDependencies.size) {\n    return true;\n  }\n\n  var undeletedInverseDependencies = Array.from(topInverseDependencies).filter(function (x) {\n    return !delta.deleted.has(x);\n  });\n  var canSafelyRemove = !undeletedInverseDependencies.length || undeletedInverseDependencies.length === 1 && undeletedInverseDependencies[0] === parentModule;\n\n  if (canSafelyRemove) {\n    visited.forEach(function (mod) {\n      canBeRemovedSafely.add(mod);\n    });\n  }\n\n  return canSafelyRemove;\n}\n\nfunction removeDependency(parentModule, absolutePath, graph, delta) {\n  var canBeRemovedSafely = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : new Set();\n  var module = graph.dependencies.get(absolutePath);\n\n  if (!module) {\n    return;\n  }\n\n  module.inverseDependencies.delete(parentModule.path);\n\n  if (!canBeRemovedSafely.has(module.path)) {\n    if (module.inverseDependencies.size && !canSafelyRemoveFromParentModule(module.inverseDependencies, module.path, graph, canBeRemovedSafely, delta)) {\n      return;\n    }\n  }\n\n  delta.deleted.add(module.path);\n  Array.from(module.dependencies.values()).filter(function (dependency) {\n    return !delta.deleted.has(dependency.absolutePath) && dependency.absolutePath !== parentModule.path;\n  }).forEach(function (dependency) {\n    return removeDependency(module, dependency.absolutePath, graph, delta, canBeRemovedSafely);\n  });\n  graph.dependencies.delete(module.path);\n}\n\nfunction resolveDependencies(parentPath, dependencies, options) {\n  var resolve = function resolve(parentPath, result) {\n    var relativePath = result.name;\n\n    try {\n      return [relativePath, {\n        absolutePath: options.resolve(parentPath, relativePath),\n        data: result\n      }];\n    } catch (error) {\n      if (result.data.isOptional !== true) {\n        throw error;\n      }\n    }\n\n    return undefined;\n  };\n\n  var resolved = dependencies.reduce(function (list, result) {\n    var resolvedPath = resolve(parentPath, result);\n\n    if (resolvedPath) {\n      list.push(resolvedPath);\n    }\n\n    return list;\n  }, []);\n  return new Map(resolved);\n}\n\nfunction reorderGraph(graph, options) {\n  var orderedDependencies = new Map();\n  graph.entryPoints.forEach(function (entryPoint) {\n    var mainModule = graph.dependencies.get(entryPoint);\n\n    if (!mainModule) {\n      throw new ReferenceError(\"Module not registered in graph: \" + entryPoint);\n    }\n\n    reorderDependencies(graph, mainModule, orderedDependencies, options);\n  });\n  graph.dependencies = orderedDependencies;\n}\n\nfunction reorderDependencies(graph, module, orderedDependencies, options) {\n  if (module.path) {\n    if (orderedDependencies.has(module.path)) {\n      return;\n    }\n\n    orderedDependencies.set(module.path, module);\n  }\n\n  module.dependencies.forEach(function (dependency) {\n    var path = dependency.absolutePath;\n    var childModule = graph.dependencies.get(path);\n\n    if (!childModule) {\n      if (dependency.data.data.asyncType != null || options.shallow) {\n        return;\n      } else {\n        throw new ReferenceError(\"Module not registered in graph: \" + path);\n      }\n    }\n\n    reorderDependencies(graph, childModule, orderedDependencies, options);\n  });\n}\n\nmodule.exports = {\n  initialTraverseDependencies: initialTraverseDependencies,\n  traverseDependencies: traverseDependencies,\n  reorderGraph: reorderGraph\n};","map":{"version":3,"names":["nullthrows","require","getInternalOptions","transform","resolve","onProgress","experimentalImportBundleSupport","shallow","numProcessed","total","onDependencyAdd","onDependencyAdded","traverseDependencies","paths","graph","options","delta","added","Set","modified","deleted","inverseDependencies","Map","internalOptions","path","dependencies","get","add","traverseDependenciesForSingleFile","has","delete","set","initialTraverseDependencies","Promise","all","entryPoints","map","reorderGraph","processModule","result","currentDependencies","resolveDependencies","previousModule","previousDependencies","module","getSource","output","relativePath","dependency","Array","from","entries","filter","absolutePath","forEach","removeDependency","promises","data","asyncType","importBundleNames","push","addDependency","parentModule","existingModule","inverse","getAllTopLevelInverseDependencies","currModule","visited","size","inverseDep","reduce","acc","mod","x","canSafelyRemoveFromParentModule","canBeRemovedSafely","topInverseDependencies","undeletedInverseDependencies","canSafelyRemove","length","values","parentPath","name","error","isOptional","undefined","resolved","list","resolvedPath","orderedDependencies","entryPoint","mainModule","ReferenceError","reorderDependencies","childModule","exports"],"sources":["/Users/hozaifa/Documents/Uni App Github/node_modules/@react-native-community/cli-plugin-metro/node_modules/metro/src/DeltaBundler/traverseDependencies.js"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *\n * @format\n */\n\"use strict\";\n\nconst nullthrows = require(\"nullthrows\");\n\nfunction getInternalOptions({\n  transform,\n  resolve,\n  onProgress,\n  experimentalImportBundleSupport,\n  shallow,\n}) {\n  let numProcessed = 0;\n  let total = 0;\n  return {\n    experimentalImportBundleSupport,\n    transform,\n    resolve,\n    onDependencyAdd: () => onProgress && onProgress(numProcessed, ++total),\n    onDependencyAdded: () => onProgress && onProgress(++numProcessed, total),\n    shallow,\n  };\n}\n/**\n * Dependency Traversal logic for the Delta Bundler. This method calculates\n * the modules that should be included in the bundle by traversing the\n * dependency graph.\n * Instead of traversing the whole graph each time, it just calculates the\n * difference between runs by only traversing the added/removed dependencies.\n * To do so, it uses the passed passed graph dependencies and it mutates it.\n * The paths parameter contains the absolute paths of the root files that the\n * method should traverse. Normally, these paths should be the modified files\n * since the last traversal.\n */\n\nasync function traverseDependencies(paths, graph, options) {\n  const delta = {\n    added: new Set(),\n    modified: new Set(),\n    deleted: new Set(),\n    inverseDependencies: new Map(),\n  };\n  const internalOptions = getInternalOptions(options);\n\n  for (const path of paths) {\n    // Only process the path if it's part of the dependency graph. It's possible\n    // that this method receives a path that is no longer part of it (e.g if a\n    // module gets removed from the dependency graph and just afterwards it gets\n    // modified), and we have to ignore these cases.\n    if (graph.dependencies.get(path)) {\n      delta.modified.add(path);\n      await traverseDependenciesForSingleFile(\n        path,\n        graph,\n        delta,\n        internalOptions\n      );\n    }\n  }\n\n  const added = new Map();\n  const modified = new Map();\n  const deleted = new Set();\n\n  for (const path of delta.deleted) {\n    // If a dependency has been marked both as added and deleted, it means that\n    // this is a renamed file (or that dependency has been removed from one path\n    // but added back in a different path). In this case the addition and\n    // deletion \"get cancelled\".\n    if (!delta.added.has(path)) {\n      deleted.add(path);\n    }\n\n    delta.modified.delete(path);\n    delta.added.delete(path);\n  }\n\n  for (const path of delta.added) {\n    added.set(path, nullthrows(graph.dependencies.get(path)));\n  }\n\n  for (const path of delta.modified) {\n    // Similarly to the above, a file can be marked as both added and modified\n    // when its path and dependencies have changed. In this case, we only\n    // consider the addition.\n    if (!delta.added.has(path)) {\n      modified.set(path, nullthrows(graph.dependencies.get(path)));\n    }\n  }\n\n  return {\n    added,\n    modified,\n    deleted,\n  };\n}\n\nasync function initialTraverseDependencies(graph, options) {\n  const delta = {\n    added: new Set(),\n    modified: new Set(),\n    deleted: new Set(),\n    inverseDependencies: new Map(),\n  };\n  const internalOptions = getInternalOptions(options);\n  await Promise.all(\n    graph.entryPoints.map((path) =>\n      traverseDependenciesForSingleFile(path, graph, delta, internalOptions)\n    )\n  );\n  reorderGraph(graph, {\n    shallow: options.shallow,\n  });\n  return {\n    added: graph.dependencies,\n    modified: new Map(),\n    deleted: new Set(),\n  };\n}\n\nasync function traverseDependenciesForSingleFile(path, graph, delta, options) {\n  options.onDependencyAdd();\n  await processModule(path, graph, delta, options);\n  options.onDependencyAdded();\n}\n\nasync function processModule(path, graph, delta, options) {\n  // Transform the file via the given option.\n  const result = await options.transform(path); // Get the absolute path of all sub-dependencies (some of them could have been\n  // moved but maintain the same relative path).\n\n  const currentDependencies = resolveDependencies(\n    path,\n    result.dependencies,\n    options\n  );\n  const previousModule = graph.dependencies.get(path) || {\n    inverseDependencies: delta.inverseDependencies.get(path) || new Set(),\n    path,\n  };\n  const previousDependencies = previousModule.dependencies || new Map(); // Update the module information.\n\n  const module = {\n    ...previousModule,\n    dependencies: new Map(),\n    getSource: result.getSource,\n    output: result.output,\n  };\n  graph.dependencies.set(module.path, module);\n\n  for (const [relativePath, dependency] of currentDependencies) {\n    module.dependencies.set(relativePath, dependency);\n  }\n\n  Array.from(previousDependencies.entries())\n    .filter(\n      ([relativePath, dependency]) =>\n        !currentDependencies.has(relativePath) ||\n        nullthrows(currentDependencies.get(relativePath)).absolutePath !==\n          dependency.absolutePath\n    )\n    .forEach(([relativePath, dependency]) =>\n      removeDependency(module, dependency.absolutePath, graph, delta, new Set())\n    ); // Check all the module dependencies and start traversing the tree from each\n  // added and removed dependency, to get all the modules that have to be added\n  // and removed from the dependency graph.\n\n  const promises = [];\n\n  for (const [relativePath, dependency] of currentDependencies) {\n    if (!options.shallow) {\n      if (\n        options.experimentalImportBundleSupport &&\n        dependency.data.data.asyncType != null\n      ) {\n        graph.importBundleNames.add(dependency.absolutePath);\n      } else if (\n        !previousDependencies.has(relativePath) ||\n        nullthrows(previousDependencies.get(relativePath)).absolutePath !==\n          dependency.absolutePath\n      ) {\n        promises.push(\n          addDependency(module, dependency.absolutePath, graph, delta, options)\n        );\n      }\n    }\n  }\n\n  try {\n    await Promise.all(promises);\n  } catch (err) {\n    // If there is an error, restore the previous dependency list.\n    // This ensures we don't skip over them during the next traversal attempt.\n    // $FlowFixMe[cannot-write]\n    module.dependencies = previousDependencies;\n    throw err;\n  }\n\n  return module;\n}\n\nasync function addDependency(parentModule, path, graph, delta, options) {\n  // The new dependency was already in the graph, we don't need to do anything.\n  const existingModule = graph.dependencies.get(path);\n\n  if (existingModule) {\n    existingModule.inverseDependencies.add(parentModule.path);\n    return;\n  } // This module is being transformed at the moment in parallel, so we should\n  // only mark its parent as an inverse dependency.\n\n  const inverse = delta.inverseDependencies.get(path);\n\n  if (inverse) {\n    inverse.add(parentModule.path);\n    return;\n  }\n\n  delta.added.add(path);\n  delta.inverseDependencies.set(path, new Set([parentModule.path]));\n  options.onDependencyAdd();\n  const module = await processModule(path, graph, delta, options);\n  graph.dependencies.set(module.path, module);\n  module.inverseDependencies.add(parentModule.path);\n  options.onDependencyAdded();\n}\n/**\n * Recursively look up `inverseDependencies` until it is empty,\n * returning a set of paths for the last module that does not have\n * `inverseDependencies`.\n */\n\nfunction getAllTopLevelInverseDependencies(\n  inverseDependencies,\n  graph,\n  currModule,\n  visited\n) {\n  if (visited.has(currModule)) {\n    return new Set();\n  }\n\n  visited.add(currModule);\n\n  if (!inverseDependencies.size) {\n    return new Set([currModule]);\n  }\n\n  return Array.from(inverseDependencies)\n    .filter((inverseDep) => graph.dependencies.has(inverseDep))\n    .reduce((acc, inverseDep) => {\n      const mod = graph.dependencies.get(inverseDep);\n\n      if (!mod) {\n        return acc;\n      }\n\n      getAllTopLevelInverseDependencies(\n        mod.inverseDependencies,\n        graph,\n        inverseDep,\n        visited\n      ).forEach((x) => {\n        acc.add(x);\n      });\n      return acc;\n    }, new Set());\n}\n/**\n * Given `inverseDependencies`, tracing back inverse dependencies to\n * see if it only leads back to `parentModule`.\n */\n\nfunction canSafelyRemoveFromParentModule(\n  inverseDependencies,\n  parentModule,\n  graph,\n  canBeRemovedSafely,\n  delta\n) {\n  const visited = new Set();\n  const topInverseDependencies = getAllTopLevelInverseDependencies(\n    inverseDependencies,\n    graph,\n    \"\", // current module name\n    visited\n  );\n\n  if (!topInverseDependencies.size) {\n    /**\n     * This happens when parentModule and inverseDependencies have a circular dependency.\n     * This will eventually become an empty set due to the `visited` Set being the\n     * base case for the recursive call.\n     */\n    return true;\n  }\n\n  const undeletedInverseDependencies = Array.from(\n    topInverseDependencies\n  ).filter((x) => !delta.deleted.has(x));\n  /**\n   * We can only mark the `visited` Set of modules to be safely removable if\n   * 1. We do not have top a level module to compare with parentModule.\n   *   This can happen when trying to see if we can safely remove from\n   *   a module that was deleted. This is why we filtered them out with `delta.deleted`\n   * 2. We have one top module and it is parentModule\n   */\n\n  const canSafelyRemove =\n    !undeletedInverseDependencies.length ||\n    (undeletedInverseDependencies.length === 1 &&\n      undeletedInverseDependencies[0] === parentModule);\n\n  if (canSafelyRemove) {\n    visited.forEach((mod) => {\n      canBeRemovedSafely.add(mod);\n    });\n  }\n\n  return canSafelyRemove;\n}\n\nfunction removeDependency(\n  parentModule,\n  absolutePath,\n  graph,\n  delta, // We use `canBeRemovedSafely` set to keep track of visited\n  // module(s) that we're sure can be removed. This will skip expensive\n  // inverse dependency traversals.\n  canBeRemovedSafely = new Set()\n) {\n  const module = graph.dependencies.get(absolutePath);\n\n  if (!module) {\n    return;\n  }\n\n  module.inverseDependencies.delete(parentModule.path); // Even if there are modules still using parentModule, we want to ensure\n  // there is no circular dependency. Thus, we check if it can be safely removed\n  // by tracing back the inverseDependencies.\n\n  if (!canBeRemovedSafely.has(module.path)) {\n    if (\n      module.inverseDependencies.size &&\n      !canSafelyRemoveFromParentModule(\n        module.inverseDependencies,\n        module.path,\n        graph,\n        canBeRemovedSafely,\n        delta\n      )\n    ) {\n      return;\n    }\n  }\n\n  delta.deleted.add(module.path); // Now we need to iterate through the module dependencies in order to\n  // clean up everything (we cannot read the module because it may have\n  // been deleted).\n\n  Array.from(module.dependencies.values())\n    .filter(\n      (dependency) =>\n        !delta.deleted.has(dependency.absolutePath) &&\n        dependency.absolutePath !== parentModule.path\n    )\n    .forEach((dependency) =>\n      removeDependency(\n        module,\n        dependency.absolutePath,\n        graph,\n        delta,\n        canBeRemovedSafely\n      )\n    ); // This module is not used anywhere else!! we can clear it from the bundle\n\n  graph.dependencies.delete(module.path);\n}\n\nfunction resolveDependencies(parentPath, dependencies, options) {\n  const resolve = (parentPath, result) => {\n    const relativePath = result.name;\n\n    try {\n      return [\n        relativePath,\n        {\n          absolutePath: options.resolve(parentPath, relativePath),\n          data: result,\n        },\n      ];\n    } catch (error) {\n      // Ignore unavailable optional dependencies. They are guarded\n      // with a try-catch block and will be handled during runtime.\n      if (result.data.isOptional !== true) {\n        throw error;\n      }\n    }\n\n    return undefined;\n  };\n\n  const resolved = dependencies.reduce((list, result) => {\n    const resolvedPath = resolve(parentPath, result);\n\n    if (resolvedPath) {\n      list.push(resolvedPath);\n    }\n\n    return list;\n  }, []);\n  return new Map(resolved);\n}\n/**\n * Re-traverse the dependency graph in DFS order to reorder the modules and\n * guarantee the same order between runs. This method mutates the passed graph.\n */\n\nfunction reorderGraph(graph, options) {\n  const orderedDependencies = new Map();\n  graph.entryPoints.forEach((entryPoint) => {\n    const mainModule = graph.dependencies.get(entryPoint);\n\n    if (!mainModule) {\n      throw new ReferenceError(\"Module not registered in graph: \" + entryPoint);\n    }\n\n    reorderDependencies(graph, mainModule, orderedDependencies, options);\n  });\n  graph.dependencies = orderedDependencies;\n}\n\nfunction reorderDependencies(graph, module, orderedDependencies, options) {\n  if (module.path) {\n    if (orderedDependencies.has(module.path)) {\n      return;\n    }\n\n    orderedDependencies.set(module.path, module);\n  }\n\n  module.dependencies.forEach((dependency) => {\n    const path = dependency.absolutePath;\n    const childModule = graph.dependencies.get(path);\n\n    if (!childModule) {\n      if (dependency.data.data.asyncType != null || options.shallow) {\n        return;\n      } else {\n        throw new ReferenceError(\"Module not registered in graph: \" + path);\n      }\n    }\n\n    reorderDependencies(graph, childModule, orderedDependencies, options);\n  });\n}\n\nmodule.exports = {\n  initialTraverseDependencies,\n  traverseDependencies,\n  reorderGraph,\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}