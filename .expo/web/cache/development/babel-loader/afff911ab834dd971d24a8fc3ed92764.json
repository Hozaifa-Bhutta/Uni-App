{"ast":null,"code":"\"use strict\";\n\nvar _extends = require(\"@babel/runtime/helpers/extends\");\n\nvar _createClass = require(\"@babel/runtime/helpers/createClass\");\n\nvar _classCallCheck = require(\"@babel/runtime/helpers/classCallCheck\");\n\nvar _assertThisInitialized = require(\"@babel/runtime/helpers/assertThisInitialized\");\n\nvar _inherits = require(\"@babel/runtime/helpers/inherits\");\n\nvar _possibleConstructorReturn = require(\"@babel/runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"@babel/runtime/helpers/getPrototypeOf\");\n\nvar _wrapNativeSuper = require(\"@babel/runtime/helpers/wrapNativeSuper\");\n\nvar _toConsumableArray = require(\"@babel/runtime/helpers/toConsumableArray\");\n\nvar _defineProperty = require(\"@babel/runtime/helpers/defineProperty\");\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nvar FailedToResolveNameError = require(\"./FailedToResolveNameError\");\n\nvar FailedToResolvePathError = require(\"./FailedToResolvePathError\");\n\nvar formatFileCandidates = require(\"./formatFileCandidates\");\n\nvar InvalidPackageError = require(\"./InvalidPackageError\");\n\nvar isAbsolutePath = require(\"absolute-path\");\n\nvar path = require(\"path\");\n\nfunction resolve(context, moduleName, platform) {\n  var resolveRequest = context.resolveRequest;\n\n  if (resolveRequest && resolveRequest !== resolve) {\n    return resolveRequest(Object.freeze(_objectSpread(_objectSpread({}, context), {}, {\n      resolveRequest: resolve\n    })), moduleName, platform);\n  }\n\n  if (isRelativeImport(moduleName) || isAbsolutePath(moduleName)) {\n    return resolveModulePath(context, moduleName, platform);\n  }\n\n  var realModuleName = context.redirectModulePath(moduleName);\n\n  if (realModuleName === false) {\n    return {\n      type: \"empty\"\n    };\n  }\n\n  var originModulePath = context.originModulePath;\n  var isDirectImport = isRelativeImport(realModuleName) || isAbsolutePath(realModuleName);\n\n  if (isDirectImport) {\n    var fromModuleParentIdx = originModulePath.lastIndexOf(\"node_modules\" + path.sep) + 13;\n    var originModuleDir = originModulePath.slice(0, originModulePath.indexOf(path.sep, fromModuleParentIdx));\n    var absPath = path.join(originModuleDir, realModuleName);\n    return resolveModulePath(context, absPath, platform);\n  }\n\n  if (context.allowHaste && !isDirectImport) {\n    var normalizedName = normalizePath(realModuleName);\n    var result = resolveHasteName(context, normalizedName, platform);\n\n    if (result.type === \"resolved\") {\n      return result.resolution;\n    }\n  }\n\n  var disableHierarchicalLookup = context.disableHierarchicalLookup;\n  var nodeModulesPaths = [];\n  var next = path.dirname(originModulePath);\n\n  if (!disableHierarchicalLookup) {\n    var candidate;\n\n    do {\n      candidate = next;\n      nodeModulesPaths.push(path.join(candidate, \"node_modules\"));\n      next = path.dirname(candidate);\n    } while (candidate !== next);\n  }\n\n  nodeModulesPaths.push.apply(nodeModulesPaths, _toConsumableArray(context.nodeModulesPaths));\n  var extraPaths = [];\n  var extraNodeModules = context.extraNodeModules;\n\n  if (extraNodeModules) {\n    var bits = path.normalize(moduleName).split(path.sep);\n    var packageName;\n\n    if (bits.length >= 2 && bits[0].startsWith(\"@\")) {\n      packageName = bits.slice(0, 2).join(\"/\");\n      bits = bits.slice(1);\n    } else {\n      packageName = bits[0];\n    }\n\n    if (extraNodeModules[packageName]) {\n      bits[0] = extraNodeModules[packageName];\n      extraPaths.push(path.join.apply(path, bits));\n    }\n  }\n\n  var allDirPaths = nodeModulesPaths.map(function (nodeModulePath) {\n    return path.join(nodeModulePath, realModuleName);\n  }).concat(extraPaths);\n\n  for (var i = 0; i < allDirPaths.length; ++i) {\n    var _candidate = context.redirectModulePath(allDirPaths[i]);\n\n    var _result = resolveFileOrDir(context, _candidate, platform);\n\n    if (_result.type === \"resolved\") {\n      return _result.resolution;\n    }\n  }\n\n  throw new FailedToResolveNameError(nodeModulesPaths, extraPaths);\n}\n\nfunction resolveModulePath(context, toModuleName, platform) {\n  var modulePath = isAbsolutePath(toModuleName) ? resolveWindowsPath(toModuleName) : path.join(path.dirname(context.originModulePath), toModuleName);\n  var redirectedPath = context.redirectModulePath(modulePath);\n\n  if (redirectedPath === false) {\n    return {\n      type: \"empty\"\n    };\n  }\n\n  var result = resolveFileOrDir(context, redirectedPath, platform);\n\n  if (result.type === \"resolved\") {\n    return result.resolution;\n  }\n\n  throw new FailedToResolvePathError(result.candidates);\n}\n\nfunction resolveHasteName(context, moduleName, platform) {\n  var modulePath = context.resolveHasteModule(moduleName);\n\n  if (modulePath != null) {\n    return resolvedAs({\n      type: \"sourceFile\",\n      filePath: modulePath\n    });\n  }\n\n  var packageName = moduleName;\n  var packageJsonPath = context.resolveHastePackage(packageName);\n\n  while (packageJsonPath == null && packageName && packageName !== \".\") {\n    packageName = path.dirname(packageName);\n    packageJsonPath = context.resolveHastePackage(packageName);\n  }\n\n  if (packageJsonPath == null) {\n    return failedFor();\n  }\n\n  var packageDirPath = path.dirname(packageJsonPath);\n  var pathInModule = moduleName.substring(packageName.length + 1);\n  var potentialModulePath = path.join(packageDirPath, pathInModule);\n  var result = resolveFileOrDir(context, potentialModulePath, platform);\n\n  if (result.type === \"resolved\") {\n    return result;\n  }\n\n  var candidates = result.candidates;\n  var opts = {\n    moduleName: moduleName,\n    packageName: packageName,\n    pathInModule: pathInModule,\n    candidates: candidates\n  };\n  throw new MissingFileInHastePackageError(opts);\n}\n\nvar MissingFileInHastePackageError = function (_Error) {\n  _inherits(MissingFileInHastePackageError, _Error);\n\n  var _super = _createSuper(MissingFileInHastePackageError);\n\n  function MissingFileInHastePackageError(opts) {\n    var _this;\n\n    _classCallCheck(this, MissingFileInHastePackageError);\n\n    _this = _super.call(this, \"While resolving module `\" + opts.moduleName + \"`, \" + (\"the Haste package `\" + opts.packageName + \"` was found. However the \") + (\"module `\" + opts.pathInModule + \"` could not be found within \") + \"the package. Indeed, none of these files exist:\\n\\n\" + (\"  * `\" + formatFileCandidates(opts.candidates.file) + \"`\\n\") + (\"  * `\" + formatFileCandidates(opts.candidates.dir) + \"`\"));\n\n    _extends(_assertThisInitialized(_this), opts);\n\n    return _this;\n  }\n\n  return _createClass(MissingFileInHastePackageError);\n}(_wrapNativeSuper(Error));\n\nfunction resolveFileOrDir(context, potentialModulePath, platform) {\n  var dirPath = path.dirname(potentialModulePath);\n  var fileNameHint = path.basename(potentialModulePath);\n  var fileResult = resolveFile(context, dirPath, fileNameHint, platform);\n\n  if (fileResult.type === \"resolved\") {\n    return fileResult;\n  }\n\n  var dirResult = resolveDir(context, potentialModulePath, platform);\n\n  if (dirResult.type === \"resolved\") {\n    return dirResult;\n  }\n\n  return failedFor({\n    file: fileResult.candidates,\n    dir: dirResult.candidates\n  });\n}\n\nfunction resolveDir(context, potentialDirPath, platform) {\n  var packageJsonPath = path.join(potentialDirPath, \"package.json\");\n\n  if (context.doesFileExist(packageJsonPath)) {\n    var resolution = resolvePackage(context, packageJsonPath, platform);\n    return {\n      resolution: resolution,\n      type: \"resolved\"\n    };\n  }\n\n  return resolveFile(context, potentialDirPath, \"index\", platform);\n}\n\nfunction resolvePackage(context, packageJsonPath, platform) {\n  var mainPrefixPath = context.getPackageMainPath(packageJsonPath);\n  var dirPath = path.dirname(mainPrefixPath);\n  var prefixName = path.basename(mainPrefixPath);\n  var fileResult = resolveFile(context, dirPath, prefixName, platform);\n\n  if (fileResult.type === \"resolved\") {\n    return fileResult.resolution;\n  }\n\n  var indexResult = resolveFile(context, mainPrefixPath, \"index\", platform);\n\n  if (indexResult.type === \"resolved\") {\n    return indexResult.resolution;\n  }\n\n  throw new InvalidPackageError({\n    packageJsonPath: packageJsonPath,\n    mainPrefixPath: mainPrefixPath,\n    indexCandidates: indexResult.candidates,\n    fileCandidates: fileResult.candidates\n  });\n}\n\nfunction resolveFile(context, dirPath, fileName, platform) {\n  var isAssetFile = context.isAssetFile,\n      resolveAsset = context.resolveAsset;\n\n  if (isAssetFile(fileName)) {\n    var extension = path.extname(fileName);\n    var basename = path.basename(fileName, extension);\n\n    if (!/@\\d+(?:\\.\\d+)?x$/.test(basename)) {\n      try {\n        var assets = resolveAsset(dirPath, basename, extension);\n\n        if (assets != null) {\n          return mapResult(resolvedAs(assets), function (filePaths) {\n            return {\n              type: \"assetFiles\",\n              filePaths: filePaths\n            };\n          });\n        }\n      } catch (err) {\n        if (err.code === \"ENOENT\") {\n          return failedFor({\n            type: \"asset\",\n            name: fileName\n          });\n        }\n      }\n    }\n\n    return failedFor({\n      type: \"asset\",\n      name: fileName\n    });\n  }\n\n  var candidateExts = [];\n  var filePathPrefix = path.join(dirPath, fileName);\n\n  var sfContext = _objectSpread(_objectSpread({}, context), {}, {\n    candidateExts: candidateExts,\n    filePathPrefix: filePathPrefix\n  });\n\n  var sourceFileResolution = resolveSourceFile(sfContext, platform);\n\n  if (sourceFileResolution != null) {\n    if (typeof sourceFileResolution === \"string\") {\n      return resolvedAs({\n        type: \"sourceFile\",\n        filePath: sourceFileResolution\n      });\n    }\n\n    return resolvedAs(sourceFileResolution);\n  }\n\n  return failedFor({\n    type: \"sourceFile\",\n    filePathPrefix: filePathPrefix,\n    candidateExts: candidateExts\n  });\n}\n\nfunction resolveSourceFile(context, platform) {\n  var filePath = resolveSourceFileForAllExts(context, \"\");\n\n  if (filePath) {\n    return filePath;\n  }\n\n  var sourceExts = context.sourceExts;\n\n  for (var i = 0; i < sourceExts.length; i++) {\n    var ext = \".\" + sourceExts[i];\n    filePath = resolveSourceFileForAllExts(context, ext, platform);\n\n    if (filePath != null) {\n      return filePath;\n    }\n  }\n\n  return null;\n}\n\nfunction resolveSourceFileForAllExts(context, sourceExt, platform) {\n  if (platform != null) {\n    var ext = \".\" + platform + sourceExt;\n\n    var _filePath = resolveSourceFileForExt(context, ext);\n\n    if (_filePath) {\n      return _filePath;\n    }\n  }\n\n  if (context.preferNativePlatform) {\n    var _filePath2 = resolveSourceFileForExt(context, \".native\" + sourceExt);\n\n    if (_filePath2) {\n      return _filePath2;\n    }\n  }\n\n  var filePath = resolveSourceFileForExt(context, sourceExt);\n  return filePath;\n}\n\nfunction resolveSourceFileForExt(context, extension) {\n  var filePath = \"\" + context.filePathPrefix + extension;\n  var redirectedPath = extension !== \"\" ? context.redirectModulePath(filePath) : filePath;\n\n  if (redirectedPath === false) {\n    return {\n      type: \"empty\"\n    };\n  }\n\n  if (context.doesFileExist(redirectedPath)) {\n    return redirectedPath;\n  }\n\n  context.candidateExts.push(extension);\n  return null;\n}\n\nfunction resolveWindowsPath(modulePath) {\n  if (path.sep !== \"\\\\\") {\n    return modulePath;\n  }\n\n  return path.resolve(modulePath);\n}\n\nfunction isRelativeImport(filePath) {\n  return /^[.][.]?(?:[/]|$)/.test(filePath);\n}\n\nfunction normalizePath(modulePath) {\n  if (path.sep === \"/\") {\n    modulePath = path.normalize(modulePath);\n  } else if (path.posix) {\n    modulePath = path.posix.normalize(modulePath);\n  }\n\n  return modulePath.replace(/\\/$/, \"\");\n}\n\nfunction resolvedAs(resolution) {\n  return {\n    type: \"resolved\",\n    resolution: resolution\n  };\n}\n\nfunction failedFor(candidates) {\n  return {\n    type: \"failed\",\n    candidates: candidates\n  };\n}\n\nfunction mapResult(result, mapper) {\n  if (result.type === \"failed\") {\n    return result;\n  }\n\n  return {\n    type: \"resolved\",\n    resolution: mapper(result.resolution)\n  };\n}\n\nmodule.exports = resolve;","map":{"version":3,"names":["FailedToResolveNameError","require","FailedToResolvePathError","formatFileCandidates","InvalidPackageError","isAbsolutePath","path","resolve","context","moduleName","platform","resolveRequest","Object","freeze","isRelativeImport","resolveModulePath","realModuleName","redirectModulePath","type","originModulePath","isDirectImport","fromModuleParentIdx","lastIndexOf","sep","originModuleDir","slice","indexOf","absPath","join","allowHaste","normalizedName","normalizePath","result","resolveHasteName","resolution","disableHierarchicalLookup","nodeModulesPaths","next","dirname","candidate","push","extraPaths","extraNodeModules","bits","normalize","split","packageName","length","startsWith","apply","allDirPaths","map","nodeModulePath","concat","i","resolveFileOrDir","toModuleName","modulePath","resolveWindowsPath","redirectedPath","candidates","resolveHasteModule","resolvedAs","filePath","packageJsonPath","resolveHastePackage","failedFor","packageDirPath","pathInModule","substring","potentialModulePath","opts","MissingFileInHastePackageError","file","dir","Error","dirPath","fileNameHint","basename","fileResult","resolveFile","dirResult","resolveDir","potentialDirPath","doesFileExist","resolvePackage","mainPrefixPath","getPackageMainPath","prefixName","indexResult","indexCandidates","fileCandidates","fileName","isAssetFile","resolveAsset","extension","extname","test","assets","mapResult","filePaths","err","code","name","candidateExts","filePathPrefix","sfContext","sourceFileResolution","resolveSourceFile","resolveSourceFileForAllExts","sourceExts","ext","sourceExt","resolveSourceFileForExt","preferNativePlatform","posix","replace","mapper","module","exports"],"sources":["/Users/hozaifa/Documents/Uni App Github/node_modules/@react-native-community/cli-plugin-metro/node_modules/metro-resolver/src/resolve.js"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *\n * @format\n */\n\"use strict\";\n\nconst FailedToResolveNameError = require(\"./FailedToResolveNameError\");\n\nconst FailedToResolvePathError = require(\"./FailedToResolvePathError\");\n\nconst formatFileCandidates = require(\"./formatFileCandidates\");\n\nconst InvalidPackageError = require(\"./InvalidPackageError\");\n\nconst isAbsolutePath = require(\"absolute-path\");\n\nconst path = require(\"path\");\n\nfunction resolve(context, moduleName, platform) {\n  const resolveRequest = context.resolveRequest;\n\n  if (\n    resolveRequest && // Prevent infinite recursion in the trivial case\n    resolveRequest !== resolve\n  ) {\n    return resolveRequest(\n      Object.freeze({ ...context, resolveRequest: resolve }),\n      moduleName,\n      platform\n    );\n  }\n\n  if (isRelativeImport(moduleName) || isAbsolutePath(moduleName)) {\n    return resolveModulePath(context, moduleName, platform);\n  }\n\n  const realModuleName = context.redirectModulePath(moduleName); // exclude\n\n  if (realModuleName === false) {\n    return {\n      type: \"empty\",\n    };\n  }\n\n  const { originModulePath } = context;\n  const isDirectImport =\n    isRelativeImport(realModuleName) || isAbsolutePath(realModuleName);\n\n  if (isDirectImport) {\n    // derive absolute path /.../node_modules/originModuleDir/realModuleName\n    const fromModuleParentIdx =\n      originModulePath.lastIndexOf(\"node_modules\" + path.sep) + 13;\n    const originModuleDir = originModulePath.slice(\n      0,\n      originModulePath.indexOf(path.sep, fromModuleParentIdx)\n    );\n    const absPath = path.join(originModuleDir, realModuleName);\n    return resolveModulePath(context, absPath, platform);\n  }\n\n  if (context.allowHaste && !isDirectImport) {\n    const normalizedName = normalizePath(realModuleName);\n    const result = resolveHasteName(context, normalizedName, platform);\n\n    if (result.type === \"resolved\") {\n      return result.resolution;\n    }\n  }\n\n  const { disableHierarchicalLookup } = context;\n  const nodeModulesPaths = [];\n  let next = path.dirname(originModulePath);\n\n  if (!disableHierarchicalLookup) {\n    let candidate;\n\n    do {\n      candidate = next;\n      nodeModulesPaths.push(path.join(candidate, \"node_modules\"));\n      next = path.dirname(candidate);\n    } while (candidate !== next);\n  } // Fall back to `nodeModulesPaths` after hierarchical lookup, similar to $NODE_PATH\n\n  nodeModulesPaths.push(...context.nodeModulesPaths);\n  const extraPaths = [];\n  const { extraNodeModules } = context;\n\n  if (extraNodeModules) {\n    let bits = path.normalize(moduleName).split(path.sep);\n    let packageName; // Normalize packageName and bits for scoped modules\n\n    if (bits.length >= 2 && bits[0].startsWith(\"@\")) {\n      packageName = bits.slice(0, 2).join(\"/\");\n      bits = bits.slice(1);\n    } else {\n      packageName = bits[0];\n    }\n\n    if (extraNodeModules[packageName]) {\n      bits[0] = extraNodeModules[packageName];\n      extraPaths.push(path.join.apply(path, bits));\n    }\n  }\n\n  const allDirPaths = nodeModulesPaths\n    .map((nodeModulePath) => path.join(nodeModulePath, realModuleName))\n    .concat(extraPaths);\n\n  for (let i = 0; i < allDirPaths.length; ++i) {\n    const candidate = context.redirectModulePath(allDirPaths[i]); // $FlowFixMe[incompatible-call]\n\n    const result = resolveFileOrDir(context, candidate, platform);\n\n    if (result.type === \"resolved\") {\n      return result.resolution;\n    }\n  }\n\n  throw new FailedToResolveNameError(nodeModulesPaths, extraPaths);\n}\n/**\n * Resolve any kind of module path, whether it's a file or a directory.\n * For example we may want to resolve './foobar'. The closest\n * `package.json` may define a redirection for this path, for example\n * `/smth/lib/foobar`, that may be further resolved to\n * `/smth/lib/foobar/index.ios.js`.\n */\n\nfunction resolveModulePath(context, toModuleName, platform) {\n  const modulePath = isAbsolutePath(toModuleName)\n    ? resolveWindowsPath(toModuleName)\n    : path.join(path.dirname(context.originModulePath), toModuleName);\n  const redirectedPath = context.redirectModulePath(modulePath);\n\n  if (redirectedPath === false) {\n    return {\n      type: \"empty\",\n    };\n  }\n\n  const result = resolveFileOrDir(context, redirectedPath, platform);\n\n  if (result.type === \"resolved\") {\n    return result.resolution;\n  }\n\n  throw new FailedToResolvePathError(result.candidates);\n}\n/**\n * Resolve a module as a Haste module or package. For example we might try to\n * resolve `Foo`, that is provided by file `/smth/Foo.js`. Or, in the case of\n * a Haste package, it could be `/smth/Foo/index.js`.\n */\n\nfunction resolveHasteName(context, moduleName, platform) {\n  const modulePath = context.resolveHasteModule(moduleName);\n\n  if (modulePath != null) {\n    return resolvedAs({\n      type: \"sourceFile\",\n      filePath: modulePath,\n    });\n  }\n\n  let packageName = moduleName;\n  let packageJsonPath = context.resolveHastePackage(packageName);\n\n  while (packageJsonPath == null && packageName && packageName !== \".\") {\n    packageName = path.dirname(packageName);\n    packageJsonPath = context.resolveHastePackage(packageName);\n  }\n\n  if (packageJsonPath == null) {\n    return failedFor();\n  }\n\n  const packageDirPath = path.dirname(packageJsonPath);\n  const pathInModule = moduleName.substring(packageName.length + 1);\n  const potentialModulePath = path.join(packageDirPath, pathInModule);\n  const result = resolveFileOrDir(context, potentialModulePath, platform);\n\n  if (result.type === \"resolved\") {\n    return result;\n  }\n\n  const { candidates } = result;\n  const opts = {\n    moduleName,\n    packageName,\n    pathInModule,\n    candidates,\n  };\n  throw new MissingFileInHastePackageError(opts);\n}\n\nclass MissingFileInHastePackageError extends Error {\n  constructor(opts) {\n    super(\n      `While resolving module \\`${opts.moduleName}\\`, ` +\n        `the Haste package \\`${opts.packageName}\\` was found. However the ` +\n        `module \\`${opts.pathInModule}\\` could not be found within ` +\n        \"the package. Indeed, none of these files exist:\\n\\n\" +\n        `  * \\`${formatFileCandidates(opts.candidates.file)}\\`\\n` +\n        `  * \\`${formatFileCandidates(opts.candidates.dir)}\\``\n    );\n    Object.assign(this, opts);\n  }\n}\n/**\n * In the NodeJS-style module resolution scheme we want to check potential\n * paths both as directories and as files. For example, `/foo/bar` may resolve\n * to `/foo/bar.js` (preferred), but it might also be `/foo/bar/index.js`, or\n * even a package directory.\n */\n\nfunction resolveFileOrDir(context, potentialModulePath, platform) {\n  const dirPath = path.dirname(potentialModulePath);\n  const fileNameHint = path.basename(potentialModulePath);\n  const fileResult = resolveFile(context, dirPath, fileNameHint, platform);\n\n  if (fileResult.type === \"resolved\") {\n    return fileResult;\n  }\n\n  const dirResult = resolveDir(context, potentialModulePath, platform);\n\n  if (dirResult.type === \"resolved\") {\n    return dirResult;\n  }\n\n  return failedFor({\n    file: fileResult.candidates,\n    dir: dirResult.candidates,\n  });\n}\n/**\n * Try to resolve a potential path as if it was a directory-based module.\n * Either this is a directory that contains a package, or that the directory\n * contains an index file. If it fails to resolve these options, it returns\n * `null` and fills the array of `candidates` that were tried.\n *\n * For example we could try to resolve `/foo/bar`, that would eventually\n * resolve to `/foo/bar/lib/index.ios.js` if we're on platform iOS and that\n * `bar` contains a package which entry point is `./lib/index` (or `./lib`).\n */\n\nfunction resolveDir(context, potentialDirPath, platform) {\n  const packageJsonPath = path.join(potentialDirPath, \"package.json\");\n\n  if (context.doesFileExist(packageJsonPath)) {\n    const resolution = resolvePackage(context, packageJsonPath, platform);\n    return {\n      resolution,\n      type: \"resolved\",\n    };\n  }\n\n  return resolveFile(context, potentialDirPath, \"index\", platform);\n}\n/**\n * Resolve the main module of a package that we know exist. The resolution\n * itself cannot fail because we already resolved the path to the package.\n * If the `main` of the package is invalid, this is not a resolution failure,\n * this means the package is invalid, and should purposefully stop the\n * resolution process altogether.\n */\n\nfunction resolvePackage(context, packageJsonPath, platform) {\n  const mainPrefixPath = context.getPackageMainPath(packageJsonPath);\n  const dirPath = path.dirname(mainPrefixPath);\n  const prefixName = path.basename(mainPrefixPath);\n  const fileResult = resolveFile(context, dirPath, prefixName, platform);\n\n  if (fileResult.type === \"resolved\") {\n    return fileResult.resolution;\n  }\n\n  const indexResult = resolveFile(context, mainPrefixPath, \"index\", platform);\n\n  if (indexResult.type === \"resolved\") {\n    return indexResult.resolution;\n  }\n\n  throw new InvalidPackageError({\n    packageJsonPath,\n    mainPrefixPath,\n    indexCandidates: indexResult.candidates,\n    fileCandidates: fileResult.candidates,\n  });\n}\n/**\n * Given a file name for a particular directory, return a resolution result\n * depending on whether or not we found the corresponding module as a file. For\n * example, we might ask for `foo.png`, that resolves to\n * `['/js/beep/foo.ios.png']`. Or we may ask for `boop`, that resolves to\n * `/js/boop.android.ts`. On the other hand this function does not resolve\n * directory-based module names: for example `boop` will not resolve to\n * `/js/boop/index.js` (see `_loadAsDir` for that).\n */\n\nfunction resolveFile(context, dirPath, fileName, platform) {\n  const { isAssetFile, resolveAsset } = context;\n\n  if (isAssetFile(fileName)) {\n    const extension = path.extname(fileName);\n    const basename = path.basename(fileName, extension);\n\n    if (!/@\\d+(?:\\.\\d+)?x$/.test(basename)) {\n      try {\n        const assets = resolveAsset(dirPath, basename, extension);\n\n        if (assets != null) {\n          return mapResult(resolvedAs(assets), (filePaths) => ({\n            type: \"assetFiles\",\n            filePaths,\n          }));\n        }\n      } catch (err) {\n        if (err.code === \"ENOENT\") {\n          return failedFor({\n            type: \"asset\",\n            name: fileName,\n          });\n        }\n      }\n    }\n\n    return failedFor({\n      type: \"asset\",\n      name: fileName,\n    });\n  }\n\n  const candidateExts = [];\n  const filePathPrefix = path.join(dirPath, fileName);\n  const sfContext = { ...context, candidateExts, filePathPrefix };\n  const sourceFileResolution = resolveSourceFile(sfContext, platform);\n\n  if (sourceFileResolution != null) {\n    if (typeof sourceFileResolution === \"string\") {\n      return resolvedAs({\n        type: \"sourceFile\",\n        filePath: sourceFileResolution,\n      });\n    }\n\n    return resolvedAs(sourceFileResolution);\n  }\n\n  return failedFor({\n    type: \"sourceFile\",\n    filePathPrefix,\n    candidateExts,\n  });\n}\n\n/**\n * A particular 'base path' can resolve to a number of possibilities depending\n * on the context. For example `foo/bar` could resolve to `foo/bar.ios.js`, or\n * to `foo/bar.js`. If can also resolve to the bare path `foo/bar` itself, as\n * supported by Node.js resolution. On the other hand it doesn't support\n * `foo/bar.ios`, for historical reasons.\n *\n * Return the full path of the resolved module, `null` if no resolution could\n * be found, or `{type: 'empty'}` if redirected to an empty module.\n */\nfunction resolveSourceFile(context, platform) {\n  let filePath = resolveSourceFileForAllExts(context, \"\");\n\n  if (filePath) {\n    return filePath;\n  }\n\n  const { sourceExts } = context;\n\n  for (let i = 0; i < sourceExts.length; i++) {\n    const ext = `.${sourceExts[i]}`;\n    filePath = resolveSourceFileForAllExts(context, ext, platform);\n\n    if (filePath != null) {\n      return filePath;\n    }\n  }\n\n  return null;\n}\n\n/**\n * For a particular extension, ex. `js`, we want to try a few possibilities,\n * such as `foo.ios.js`, `foo.native.js`, and of course `foo.js`. Return the\n * full path of the resolved module, `null` if no resolution could be found, or\n * `{type: 'empty'}` if redirected to an empty module.\n */\nfunction resolveSourceFileForAllExts(context, sourceExt, platform) {\n  if (platform != null) {\n    const ext = `.${platform}${sourceExt}`;\n    const filePath = resolveSourceFileForExt(context, ext);\n\n    if (filePath) {\n      return filePath;\n    }\n  }\n\n  if (context.preferNativePlatform) {\n    const filePath = resolveSourceFileForExt(context, `.native${sourceExt}`);\n\n    if (filePath) {\n      return filePath;\n    }\n  }\n\n  const filePath = resolveSourceFileForExt(context, sourceExt);\n  return filePath;\n}\n\n/**\n * We try to resolve a single possible extension. If it doesn't exist, then\n * we make sure to add the extension to a list of candidates for reporting.\n */\nfunction resolveSourceFileForExt(context, extension) {\n  const filePath = `${context.filePathPrefix}${extension}`;\n  const redirectedPath = // Any redirections for the bare path have already happened\n    extension !== \"\" ? context.redirectModulePath(filePath) : filePath;\n\n  if (redirectedPath === false) {\n    return {\n      type: \"empty\",\n    };\n  }\n\n  if (context.doesFileExist(redirectedPath)) {\n    return redirectedPath;\n  }\n\n  context.candidateExts.push(extension);\n  return null;\n} // HasteFS stores paths with backslashes on Windows, this ensures the path is in\n// the proper format. Will also add drive letter if not present so `/root` will\n// resolve to `C:\\root`. Noop on other platforms.\n\nfunction resolveWindowsPath(modulePath) {\n  if (path.sep !== \"\\\\\") {\n    return modulePath;\n  }\n\n  return path.resolve(modulePath);\n}\n\nfunction isRelativeImport(filePath) {\n  return /^[.][.]?(?:[/]|$)/.test(filePath);\n}\n\nfunction normalizePath(modulePath) {\n  if (path.sep === \"/\") {\n    modulePath = path.normalize(modulePath);\n  } else if (path.posix) {\n    modulePath = path.posix.normalize(modulePath);\n  }\n\n  return modulePath.replace(/\\/$/, \"\");\n}\n\nfunction resolvedAs(resolution) {\n  return {\n    type: \"resolved\",\n    resolution,\n  };\n}\n\nfunction failedFor(candidates) {\n  return {\n    type: \"failed\",\n    candidates,\n  };\n}\n\nfunction mapResult(result, mapper) {\n  if (result.type === \"failed\") {\n    return result;\n  }\n\n  return {\n    type: \"resolved\",\n    resolution: mapper(result.resolution),\n  };\n}\n\nmodule.exports = resolve;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}