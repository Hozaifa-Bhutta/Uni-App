{"ast":null,"code":"\"use strict\";\n\nvar CHAR_MAP = [0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f, 0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5a, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7a, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x2b, 0x2f];\nvar VLQ_BASE_SHIFT = 5;\nvar VLQ_BASE = 1 << VLQ_BASE_SHIFT;\nvar VLQ_BASE_MASK = VLQ_BASE - 1;\nvar VLQ_CONTINUATION_BIT = VLQ_BASE;\n\nfunction toVLQSigned(value) {\n  return value < 0 ? (-value << 1) + 1 : (value << 1) + 0;\n}\n\nfunction encode(value, buffer, position) {\n  var vlq = toVLQSigned(value);\n  var digit;\n\n  do {\n    digit = vlq & VLQ_BASE_MASK;\n    vlq = vlq >>> VLQ_BASE_SHIFT;\n\n    if (vlq > 0) {\n      digit = digit | VLQ_CONTINUATION_BIT;\n    }\n\n    buffer[position++] = CHAR_MAP[digit];\n  } while (vlq > 0);\n\n  return position;\n}\n\nmodule.exports = encode;","map":{"version":3,"names":["CHAR_MAP","VLQ_BASE_SHIFT","VLQ_BASE","VLQ_BASE_MASK","VLQ_CONTINUATION_BIT","toVLQSigned","value","encode","buffer","position","vlq","digit","module","exports"],"sources":["/Users/hozaifa/Documents/Uni App Github/node_modules/@react-native-community/cli-plugin-metro/node_modules/metro-source-map/src/encode.js"],"sourcesContent":["/**\n * Portions Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *\n * @format\n */\n\n/**\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n *\n * Based on the Base 64 VLQ implementation in Closure Compiler:\n * https://git.io/vymuA\n *\n * Copyright 2011 The Closure Compiler Authors. All rights reserved.\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n *  * Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above\n *    copyright notice, this list of conditions and the following\n *    disclaimer in the documentation and/or other materials provided\n *    with the distribution.\n *  * Neither the name of Google Inc. nor the names of its\n *    contributors may be used to endorse or promote products derived\n *    from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n * @copyright\n */\n\n/* eslint-disable no-bitwise */\n\"use strict\"; // A map of values to characters for the b64 encoding\n\nconst CHAR_MAP = [\n  0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d,\n  0x4e, 0x4f, 0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5a,\n  0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d,\n  0x6e, 0x6f, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7a,\n  0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x2b, 0x2f,\n]; // A single base 64 digit can contain 6 bits of data. For the base 64 variable\n// length quantities we use in the source map spec, the first bit is the sign,\n// the next four bits are the actual value, and the 6th bit is the\n// continuation bit. The continuation bit tells us whether there are more\n// digits in this value following this digit.\n//\n//   Continuation\n//   |    Sign\n//   |    |\n//   V    V\n//   101011\n\nconst VLQ_BASE_SHIFT = 5; // binary: 100000\n\nconst VLQ_BASE = 1 << VLQ_BASE_SHIFT; // binary: 011111\n\nconst VLQ_BASE_MASK = VLQ_BASE - 1; // binary: 100000\n\nconst VLQ_CONTINUATION_BIT = VLQ_BASE;\n/**\n * Converts from a two-complement value to a value where the sign bit is\n * placed in the least significant bit.  For example, as decimals:\n *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)\n *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)\n */\n\nfunction toVLQSigned(value) {\n  return value < 0 ? (-value << 1) + 1 : (value << 1) + 0;\n}\n/**\n * Encodes a number to base64 VLQ format and appends it to the passed-in buffer\n *\n * DON'T USE COMPOUND OPERATORS (eg `>>>=`) ON `let`-DECLARED VARIABLES!\n * V8 WILL DEOPTIMIZE THIS FUNCTION AND MAP CREATION WILL BE 25% SLOWER!\n *\n * DON'T ADD MORE COMMENTS TO THIS FUNCTION TO KEEP ITS LENGTH SHORT ENOUGH FOR\n * V8 OPTIMIZATION!\n */\n\nfunction encode(value, buffer, position) {\n  let vlq = toVLQSigned(value);\n  let digit;\n\n  do {\n    digit = vlq & VLQ_BASE_MASK;\n    vlq = vlq >>> VLQ_BASE_SHIFT;\n\n    if (vlq > 0) {\n      // There are still more digits in this value, so we must make sure the\n      // continuation bit is marked.\n      digit = digit | VLQ_CONTINUATION_BIT;\n    }\n\n    buffer[position++] = CHAR_MAP[digit];\n  } while (vlq > 0);\n\n  return position;\n}\n\nmodule.exports = encode;\n"],"mappings":"AAiDA;;AAEA,IAAMA,QAAQ,GAAG,CACf,IADe,EACT,IADS,EACH,IADG,EACG,IADH,EACS,IADT,EACe,IADf,EACqB,IADrB,EAC2B,IAD3B,EACiC,IADjC,EACuC,IADvC,EAC6C,IAD7C,EACmD,IADnD,EACyD,IADzD,EAEf,IAFe,EAET,IAFS,EAEH,IAFG,EAEG,IAFH,EAES,IAFT,EAEe,IAFf,EAEqB,IAFrB,EAE2B,IAF3B,EAEiC,IAFjC,EAEuC,IAFvC,EAE6C,IAF7C,EAEmD,IAFnD,EAEyD,IAFzD,EAGf,IAHe,EAGT,IAHS,EAGH,IAHG,EAGG,IAHH,EAGS,IAHT,EAGe,IAHf,EAGqB,IAHrB,EAG2B,IAH3B,EAGiC,IAHjC,EAGuC,IAHvC,EAG6C,IAH7C,EAGmD,IAHnD,EAGyD,IAHzD,EAIf,IAJe,EAIT,IAJS,EAIH,IAJG,EAIG,IAJH,EAIS,IAJT,EAIe,IAJf,EAIqB,IAJrB,EAI2B,IAJ3B,EAIiC,IAJjC,EAIuC,IAJvC,EAI6C,IAJ7C,EAImD,IAJnD,EAIyD,IAJzD,EAKf,IALe,EAKT,IALS,EAKH,IALG,EAKG,IALH,EAKS,IALT,EAKe,IALf,EAKqB,IALrB,EAK2B,IAL3B,EAKiC,IALjC,EAKuC,IALvC,EAK6C,IAL7C,EAKmD,IALnD,CAAjB;AAkBA,IAAMC,cAAc,GAAG,CAAvB;AAEA,IAAMC,QAAQ,GAAG,KAAKD,cAAtB;AAEA,IAAME,aAAa,GAAGD,QAAQ,GAAG,CAAjC;AAEA,IAAME,oBAAoB,GAAGF,QAA7B;;AAQA,SAASG,WAAT,CAAqBC,KAArB,EAA4B;EAC1B,OAAOA,KAAK,GAAG,CAAR,GAAY,CAAC,CAACA,KAAD,IAAU,CAAX,IAAgB,CAA5B,GAAgC,CAACA,KAAK,IAAI,CAAV,IAAe,CAAtD;AACD;;AAWD,SAASC,MAAT,CAAgBD,KAAhB,EAAuBE,MAAvB,EAA+BC,QAA/B,EAAyC;EACvC,IAAIC,GAAG,GAAGL,WAAW,CAACC,KAAD,CAArB;EACA,IAAIK,KAAJ;;EAEA,GAAG;IACDA,KAAK,GAAGD,GAAG,GAAGP,aAAd;IACAO,GAAG,GAAGA,GAAG,KAAKT,cAAd;;IAEA,IAAIS,GAAG,GAAG,CAAV,EAAa;MAGXC,KAAK,GAAGA,KAAK,GAAGP,oBAAhB;IACD;;IAEDI,MAAM,CAACC,QAAQ,EAAT,CAAN,GAAqBT,QAAQ,CAACW,KAAD,CAA7B;EACD,CAXD,QAWSD,GAAG,GAAG,CAXf;;EAaA,OAAOD,QAAP;AACD;;AAEDG,MAAM,CAACC,OAAP,GAAiBN,MAAjB"},"metadata":{},"sourceType":"script"}