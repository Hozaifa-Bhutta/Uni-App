{"ast":null,"code":"\"use strict\";\n\nvar _slicedToArray = require(\"@babel/runtime/helpers/slicedToArray\");\n\nfunction _createForOfIteratorHelperLoose(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (it) return (it = it.call(o)).next.bind(it); if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = createMessageSocketEndpoint;\n\nfunction _url() {\n  var data = _interopRequireDefault(require(\"url\"));\n\n  _url = function _url() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _ws() {\n  var data = require(\"ws\");\n\n  _ws = function _ws() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _cliTools() {\n  var data = require(\"@react-native-community/cli-tools\");\n\n  _cliTools = function _cliTools() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nvar PROTOCOL_VERSION = 2;\n\nfunction parseMessage(data, binary) {\n  if (binary) {\n    _cliTools().logger.error('Expected text message, got binary!');\n\n    return undefined;\n  }\n\n  try {\n    var message = JSON.parse(data);\n\n    if (message.version === PROTOCOL_VERSION) {\n      return message;\n    }\n\n    _cliTools().logger.error(\"Received message had wrong protocol version: \" + message.version);\n  } catch (e) {\n    _cliTools().logger.error(\"Failed to parse the message as JSON:\\n\" + data);\n  }\n\n  return undefined;\n}\n\nfunction isBroadcast(message) {\n  return typeof message.method === 'string' && message.id === undefined && message.target === undefined;\n}\n\nfunction isRequest(message) {\n  return typeof message.method === 'string' && typeof message.target === 'string';\n}\n\nfunction isResponse(message) {\n  return typeof message.id === 'object' && typeof message.id.requestId !== 'undefined' && typeof message.id.clientId === 'string' && (message.result !== undefined || message.error !== undefined);\n}\n\nfunction createMessageSocketEndpoint() {\n  var wss = new (_ws().Server)({\n    noServer: true\n  });\n  var clients = new Map();\n  var nextClientId = 0;\n\n  function getClientWs(clientId) {\n    var clientWs = clients.get(clientId);\n\n    if (clientWs === undefined) {\n      throw new Error(\"could not find id \\\"\" + clientId + \"\\\" while forwarding request\");\n    }\n\n    return clientWs;\n  }\n\n  function handleSendBroadcast(broadcasterId, message) {\n    var forwarded = {\n      version: PROTOCOL_VERSION,\n      method: message.method,\n      params: message.params\n    };\n\n    if (clients.size === 0) {\n      _cliTools().logger.warn(\"No apps connected. Sending \\\"\" + message.method + \"\\\" to all React Native apps failed. Make sure your app is running in the simulator or on a phone connected via USB.\");\n    }\n\n    for (var _iterator = _createForOfIteratorHelperLoose(clients), _step; !(_step = _iterator()).done;) {\n      var _ref = _step.value;\n\n      var _ref2 = _slicedToArray(_ref, 2);\n\n      var otherId = _ref2[0];\n      var otherWs = _ref2[1];\n\n      if (otherId !== broadcasterId) {\n        try {\n          otherWs.send(JSON.stringify(forwarded));\n        } catch (e) {\n          _cliTools().logger.error(\"Failed to send broadcast to client: '\" + otherId + \"' \" + (\"due to:\\n \" + e.toString()));\n        }\n      }\n    }\n  }\n\n  wss.on('connection', function (clientWs) {\n    var clientId = \"client#\" + nextClientId++;\n\n    function handleCaughtError(message, error) {\n      var errorMessage = {\n        id: message.id,\n        method: message.method,\n        target: message.target,\n        error: message.error === undefined ? 'undefined' : 'defined',\n        params: message.params === undefined ? 'undefined' : 'defined',\n        result: message.result === undefined ? 'undefined' : 'defined'\n      };\n\n      if (message.id === undefined) {\n        _cliTools().logger.error(\"Handling message from \" + clientId + \" failed with:\\n\" + error + \"\\n\" + (\"message:\\n\" + JSON.stringify(errorMessage)));\n      } else {\n        try {\n          clientWs.send(JSON.stringify({\n            version: PROTOCOL_VERSION,\n            error: error,\n            id: message.id\n          }));\n        } catch (e) {\n          _cliTools().logger.error(\"Failed to reply to \" + clientId + \" with error:\\n\" + error + (\"\\nmessage:\\n\" + JSON.stringify(errorMessage)) + (\"\\ndue to error: \" + e.toString()));\n        }\n      }\n    }\n\n    function handleServerRequest(message) {\n      var result = null;\n\n      switch (message.method) {\n        case 'getid':\n          result = clientId;\n          break;\n\n        case 'getpeers':\n          result = {};\n          clients.forEach(function (otherWs, otherId) {\n            if (clientId !== otherId) {\n              result[otherId] = _url().default.parse(otherWs.upgradeReq.url, true).query;\n            }\n          });\n          break;\n\n        default:\n          throw new Error(\"unknown method: \" + message.method);\n      }\n\n      clientWs.send(JSON.stringify({\n        version: PROTOCOL_VERSION,\n        result: result,\n        id: message.id\n      }));\n    }\n\n    function forwardRequest(message) {\n      getClientWs(message.target).send(JSON.stringify({\n        version: PROTOCOL_VERSION,\n        method: message.method,\n        params: message.params,\n        id: message.id === undefined ? undefined : {\n          requestId: message.id,\n          clientId: clientId\n        }\n      }));\n    }\n\n    function forwardResponse(message) {\n      if (!message.id) {\n        return;\n      }\n\n      getClientWs(message.id.clientId).send(JSON.stringify({\n        version: PROTOCOL_VERSION,\n        result: message.result,\n        error: message.error,\n        id: message.id.requestId\n      }));\n    }\n\n    clients.set(clientId, clientWs);\n\n    var onCloseHandler = function onCloseHandler() {\n      clientWs.onmessage = function () {};\n\n      clients.delete(clientId);\n    };\n\n    clientWs.onclose = onCloseHandler;\n    clientWs.onerror = onCloseHandler;\n\n    clientWs.onmessage = function (event) {\n      var message = parseMessage(event.data, event.binary);\n\n      if (message === undefined) {\n        _cliTools().logger.error('Received message not matching protocol');\n\n        return;\n      }\n\n      try {\n        if (isBroadcast(message)) {\n          handleSendBroadcast(clientId, message);\n        } else if (isRequest(message)) {\n          if (message.target === 'server') {\n            handleServerRequest(message);\n          } else {\n            forwardRequest(message);\n          }\n        } else if (isResponse(message)) {\n          forwardResponse(message);\n        } else {\n          throw new Error('Invalid message, did not match the protocol');\n        }\n      } catch (e) {\n        handleCaughtError(message, e.toString());\n      }\n    };\n  });\n  return {\n    server: wss,\n    broadcast: function broadcast(method, params) {\n      handleSendBroadcast(null, {\n        method: method,\n        params: params\n      });\n    }\n  };\n}","map":{"version":3,"sources":["../../src/websocket/createMessageSocketEndpoint.ts"],"names":["PROTOCOL_VERSION","logger","message","JSON","wss","WebSocketServer","noServer","clients","nextClientId","clientWs","forwarded","version","method","params","otherId","otherWs","e","clientId","errorMessage","id","target","error","result","url","getClientWs","requestId","onCloseHandler","event","parseMessage","isBroadcast","handleSendBroadcast","isRequest","handleServerRequest","forwardRequest","isResponse","forwardResponse","handleCaughtError","server","broadcast"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport url from 'url';\nimport {Server as WebSocketServer} from 'ws';\nimport {logger} from '@react-native-community/cli-tools';\n\nconst PROTOCOL_VERSION = 2;\n\ntype IdObject = {\n  requestId: string;\n  clientId: string;\n};\n\ntype Message = {\n  version?: string;\n  id?: IdObject;\n  method?: string;\n  target: string;\n  result?: any;\n  error?: Error;\n  params?: Record<string, any>;\n};\n\nfunction parseMessage(data: string, binary: any) {\n  if (binary) {\n    logger.error('Expected text message, got binary!');\n    return undefined;\n  }\n  try {\n    const message = JSON.parse(data);\n    if (message.version === PROTOCOL_VERSION) {\n      return message;\n    }\n    logger.error(\n      `Received message had wrong protocol version: ${message.version}`,\n    );\n  } catch (e) {\n    logger.error(`Failed to parse the message as JSON:\\n${data}`);\n  }\n  return undefined;\n}\n\nfunction isBroadcast(message: Message) {\n  return (\n    typeof message.method === 'string' &&\n    message.id === undefined &&\n    message.target === undefined\n  );\n}\n\nfunction isRequest(message: Message) {\n  return (\n    typeof message.method === 'string' && typeof message.target === 'string'\n  );\n}\n\nfunction isResponse(message: Message) {\n  return (\n    typeof message.id === 'object' &&\n    typeof message.id.requestId !== 'undefined' &&\n    typeof message.id.clientId === 'string' &&\n    (message.result !== undefined || message.error !== undefined)\n  );\n}\n\nexport default function createMessageSocketEndpoint(): {\n  server: WebSocketServer;\n  broadcast: (method: string, params?: Record<string, any>) => void;\n} {\n  const wss = new WebSocketServer({\n    noServer: true,\n  });\n  const clients = new Map();\n  let nextClientId = 0;\n\n  function getClientWs(clientId: string) {\n    const clientWs = clients.get(clientId);\n    if (clientWs === undefined) {\n      throw new Error(\n        `could not find id \"${clientId}\" while forwarding request`,\n      );\n    }\n    return clientWs;\n  }\n\n  function handleSendBroadcast(\n    broadcasterId: string | null,\n    message: Partial<Message>,\n  ) {\n    const forwarded = {\n      version: PROTOCOL_VERSION,\n      method: message.method,\n      params: message.params,\n    };\n    if (clients.size === 0) {\n      logger.warn(\n        `No apps connected. Sending \"${message.method}\" to all React Native apps failed. Make sure your app is running in the simulator or on a phone connected via USB.`,\n      );\n    }\n    for (const [otherId, otherWs] of clients) {\n      if (otherId !== broadcasterId) {\n        try {\n          otherWs.send(JSON.stringify(forwarded));\n        } catch (e) {\n          logger.error(\n            `Failed to send broadcast to client: '${otherId}' ` +\n              `due to:\\n ${e.toString()}`,\n          );\n        }\n      }\n    }\n  }\n\n  wss.on('connection', (clientWs) => {\n    const clientId = `client#${nextClientId++}`;\n\n    function handleCaughtError(message: Message, error: Error) {\n      const errorMessage = {\n        id: message.id,\n        method: message.method,\n        target: message.target,\n        error: message.error === undefined ? 'undefined' : 'defined',\n        params: message.params === undefined ? 'undefined' : 'defined',\n        result: message.result === undefined ? 'undefined' : 'defined',\n      };\n\n      if (message.id === undefined) {\n        logger.error(\n          `Handling message from ${clientId} failed with:\\n${error}\\n` +\n            `message:\\n${JSON.stringify(errorMessage)}`,\n        );\n      } else {\n        try {\n          clientWs.send(\n            JSON.stringify({\n              version: PROTOCOL_VERSION,\n              error,\n              id: message.id,\n            }),\n          );\n        } catch (e) {\n          logger.error(\n            `Failed to reply to ${clientId} with error:\\n${error}` +\n              `\\nmessage:\\n${JSON.stringify(errorMessage)}` +\n              `\\ndue to error: ${e.toString()}`,\n          );\n        }\n      }\n    }\n\n    function handleServerRequest(message: Message) {\n      let result = null;\n      switch (message.method) {\n        case 'getid':\n          result = clientId;\n          break;\n        case 'getpeers':\n          result = {};\n          clients.forEach((otherWs, otherId) => {\n            if (clientId !== otherId) {\n              result[otherId] = url.parse(otherWs.upgradeReq.url, true).query;\n            }\n          });\n          break;\n        default:\n          throw new Error(`unknown method: ${message.method}`);\n      }\n\n      clientWs.send(\n        JSON.stringify({\n          version: PROTOCOL_VERSION,\n          result,\n          id: message.id,\n        }),\n      );\n    }\n\n    function forwardRequest(message: Message) {\n      getClientWs(message.target).send(\n        JSON.stringify({\n          version: PROTOCOL_VERSION,\n          method: message.method,\n          params: message.params,\n          id:\n            message.id === undefined\n              ? undefined\n              : {requestId: message.id, clientId},\n        }),\n      );\n    }\n\n    function forwardResponse(message: Message) {\n      if (!message.id) {\n        return;\n      }\n      getClientWs(message.id.clientId).send(\n        JSON.stringify({\n          version: PROTOCOL_VERSION,\n          result: message.result,\n          error: message.error,\n          id: message.id.requestId,\n        }),\n      );\n    }\n\n    clients.set(clientId, clientWs);\n    const onCloseHandler = () => {\n      clientWs.onmessage = () => {};\n      clients.delete(clientId);\n    };\n    clientWs.onclose = onCloseHandler;\n    clientWs.onerror = onCloseHandler;\n    clientWs.onmessage = (event: any) => {\n      const message = parseMessage(event.data, event.binary);\n      if (message === undefined) {\n        logger.error('Received message not matching protocol');\n        return;\n      }\n\n      try {\n        if (isBroadcast(message)) {\n          handleSendBroadcast(clientId, message);\n        } else if (isRequest(message)) {\n          if (message.target === 'server') {\n            handleServerRequest(message);\n          } else {\n            forwardRequest(message);\n          }\n        } else if (isResponse(message)) {\n          forwardResponse(message);\n        } else {\n          throw new Error('Invalid message, did not match the protocol');\n        }\n      } catch (e) {\n        handleCaughtError(message, e.toString());\n      }\n    };\n  });\n\n  return {\n    server: wss,\n    broadcast: (method: string, params?: Record<string, any>) => {\n      handleSendBroadcast(null, {method, params});\n    },\n  };\n}\n"]},"metadata":{},"sourceType":"script"}