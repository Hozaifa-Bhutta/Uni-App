{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"@babel/runtime/helpers/createClass\");\n\nvar _inherits = require(\"@babel/runtime/helpers/inherits\");\n\nvar _possibleConstructorReturn = require(\"@babel/runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"@babel/runtime/helpers/getPrototypeOf\");\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nvar FileStore = require(\"./FileStore\");\n\nvar fs = require(\"fs\");\n\nvar path = require(\"path\");\n\nvar walkSync = function walkSync(dir, filelist) {\n  var files = fs.readdirSync(dir);\n  filelist = filelist || [];\n  files.forEach(function (file) {\n    var fullPath = path.join(dir, file);\n    var stats = fs.statSync(fullPath);\n\n    if (stats.isDirectory()) {\n      filelist = walkSync(fullPath + path.sep, filelist);\n    } else {\n      filelist.push({\n        path: fullPath,\n        stats: stats\n      });\n    }\n  });\n  return filelist;\n};\n\nfunction get(property, defaultValue) {\n  if (property == null) {\n    return defaultValue;\n  }\n\n  return property;\n}\n\nvar AutoCleanFileStore = function (_FileStore) {\n  _inherits(AutoCleanFileStore, _FileStore);\n\n  var _super = _createSuper(AutoCleanFileStore);\n\n  function AutoCleanFileStore(opts) {\n    var _this;\n\n    _classCallCheck(this, AutoCleanFileStore);\n\n    _this = _super.call(this, {\n      root: opts.root\n    });\n    _this._intervalMs = get(opts.intervalMs, 10 * 60 * 1000);\n    _this._cleanupThresholdMs = get(opts.cleanupThresholdMs, 3 * 24 * 60 * 60 * 1000);\n\n    _this._scheduleCleanup();\n\n    return _this;\n  }\n\n  _createClass(AutoCleanFileStore, [{\n    key: \"_scheduleCleanup\",\n    value: function _scheduleCleanup() {\n      setTimeout(this._doCleanup.bind(this), this._intervalMs);\n    }\n  }, {\n    key: \"_doCleanup\",\n    value: function _doCleanup() {\n      var _this2 = this;\n\n      var files = walkSync(this._root, []);\n      var warned = false;\n      files.forEach(function (file) {\n        if (file.stats.mtimeMs < Date.now() - _this2._cleanupThresholdMs) {\n          try {\n            fs.unlinkSync(file.path);\n          } catch (e) {\n            if (!warned) {\n              console.warn(\"Problem cleaning up cache for \" + file.path + \": \" + e.message);\n              warned = true;\n            }\n          }\n        }\n      });\n\n      this._scheduleCleanup();\n    }\n  }]);\n\n  return AutoCleanFileStore;\n}(FileStore);\n\nmodule.exports = AutoCleanFileStore;","map":{"version":3,"names":["FileStore","require","fs","path","walkSync","dir","filelist","files","readdirSync","forEach","file","fullPath","join","stats","statSync","isDirectory","sep","push","get","property","defaultValue","AutoCleanFileStore","opts","root","_intervalMs","intervalMs","_cleanupThresholdMs","cleanupThresholdMs","_scheduleCleanup","setTimeout","_doCleanup","bind","_root","warned","mtimeMs","Date","now","unlinkSync","e","console","warn","message","module","exports"],"sources":["/Users/hozaifa/Documents/Uni App Github/node_modules/@react-native-community/cli-plugin-metro/node_modules/metro-cache/src/stores/AutoCleanFileStore.js"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @format\n *\n */\n\"use strict\";\n\nconst FileStore = require(\"./FileStore\");\n\nconst fs = require(\"fs\");\n\nconst path = require(\"path\");\n\n// List all files in a directory in Node.js recursively in a synchronous fashion\nconst walkSync = function (dir, filelist) {\n  const files = fs.readdirSync(dir);\n  filelist = filelist || [];\n  files.forEach(function (file) {\n    const fullPath = path.join(dir, file);\n    const stats = fs.statSync(fullPath);\n\n    if (stats.isDirectory()) {\n      filelist = walkSync(fullPath + path.sep, filelist);\n    } else {\n      filelist.push({\n        path: fullPath,\n        stats,\n      });\n    }\n  });\n  return filelist;\n};\n\nfunction get(property, defaultValue) {\n  if (property == null) {\n    return defaultValue;\n  }\n\n  return property;\n}\n/**\n * A FileStore that cleans itself up in a given interval\n */\n\nclass AutoCleanFileStore extends FileStore {\n  constructor(opts) {\n    super({\n      root: opts.root,\n    });\n    this._intervalMs = get(opts.intervalMs, 10 * 60 * 1000); // 10 minutes\n\n    this._cleanupThresholdMs = get(\n      opts.cleanupThresholdMs,\n      3 * 24 * 60 * 60 * 1000 // 3 days\n    );\n\n    this._scheduleCleanup();\n  }\n\n  _scheduleCleanup() {\n    // $FlowFixMe[method-unbinding] added when improving typing for this parameters\n    setTimeout(this._doCleanup.bind(this), this._intervalMs);\n  }\n\n  _doCleanup() {\n    const files = walkSync(this._root, []);\n    let warned = false;\n    files.forEach((file) => {\n      if (file.stats.mtimeMs < Date.now() - this._cleanupThresholdMs) {\n        try {\n          fs.unlinkSync(file.path);\n        } catch (e) {\n          if (!warned) {\n            console.warn(\n              \"Problem cleaning up cache for \" + file.path + \": \" + e.message\n            );\n            warned = true;\n          }\n        }\n      }\n    });\n\n    this._scheduleCleanup();\n  }\n}\n\nmodule.exports = AutoCleanFileStore;\n"],"mappings":"AASA;;;;;;;;;;;;;;;;AAEA,IAAMA,SAAS,GAAGC,OAAO,eAAzB;;AAEA,IAAMC,EAAE,GAAGD,OAAO,CAAC,IAAD,CAAlB;;AAEA,IAAME,IAAI,GAAGF,OAAO,CAAC,MAAD,CAApB;;AAGA,IAAMG,QAAQ,GAAG,SAAXA,QAAW,CAAUC,GAAV,EAAeC,QAAf,EAAyB;EACxC,IAAMC,KAAK,GAAGL,EAAE,CAACM,WAAH,CAAeH,GAAf,CAAd;EACAC,QAAQ,GAAGA,QAAQ,IAAI,EAAvB;EACAC,KAAK,CAACE,OAAN,CAAc,UAAUC,IAAV,EAAgB;IAC5B,IAAMC,QAAQ,GAAGR,IAAI,CAACS,IAAL,CAAUP,GAAV,EAAeK,IAAf,CAAjB;IACA,IAAMG,KAAK,GAAGX,EAAE,CAACY,QAAH,CAAYH,QAAZ,CAAd;;IAEA,IAAIE,KAAK,CAACE,WAAN,EAAJ,EAAyB;MACvBT,QAAQ,GAAGF,QAAQ,CAACO,QAAQ,GAAGR,IAAI,CAACa,GAAjB,EAAsBV,QAAtB,CAAnB;IACD,CAFD,MAEO;MACLA,QAAQ,CAACW,IAAT,CAAc;QACZd,IAAI,EAAEQ,QADM;QAEZE,KAAK,EAALA;MAFY,CAAd;IAID;EACF,CAZD;EAaA,OAAOP,QAAP;AACD,CAjBD;;AAmBA,SAASY,GAAT,CAAaC,QAAb,EAAuBC,YAAvB,EAAqC;EACnC,IAAID,QAAQ,IAAI,IAAhB,EAAsB;IACpB,OAAOC,YAAP;EACD;;EAED,OAAOD,QAAP;AACD;;IAKKE,kB;;;;;EACJ,4BAAYC,IAAZ,EAAkB;IAAA;;IAAA;;IAChB,0BAAM;MACJC,IAAI,EAAED,IAAI,CAACC;IADP,CAAN;IAGA,MAAKC,WAAL,GAAmBN,GAAG,CAACI,IAAI,CAACG,UAAN,EAAkB,KAAK,EAAL,GAAU,IAA5B,CAAtB;IAEA,MAAKC,mBAAL,GAA2BR,GAAG,CAC5BI,IAAI,CAACK,kBADuB,EAE5B,IAAI,EAAJ,GAAS,EAAT,GAAc,EAAd,GAAmB,IAFS,CAA9B;;IAKA,MAAKC,gBAAL;;IAXgB;EAYjB;;;;WAED,4BAAmB;MAEjBC,UAAU,CAAC,KAAKC,UAAL,CAAgBC,IAAhB,CAAqB,IAArB,CAAD,EAA6B,KAAKP,WAAlC,CAAV;IACD;;;WAED,sBAAa;MAAA;;MACX,IAAMjB,KAAK,GAAGH,QAAQ,CAAC,KAAK4B,KAAN,EAAa,EAAb,CAAtB;MACA,IAAIC,MAAM,GAAG,KAAb;MACA1B,KAAK,CAACE,OAAN,CAAc,UAACC,IAAD,EAAU;QACtB,IAAIA,IAAI,CAACG,KAAL,CAAWqB,OAAX,GAAqBC,IAAI,CAACC,GAAL,KAAa,MAAI,CAACV,mBAA3C,EAAgE;UAC9D,IAAI;YACFxB,EAAE,CAACmC,UAAH,CAAc3B,IAAI,CAACP,IAAnB;UACD,CAFD,CAEE,OAAOmC,CAAP,EAAU;YACV,IAAI,CAACL,MAAL,EAAa;cACXM,OAAO,CAACC,IAAR,CACE,mCAAmC9B,IAAI,CAACP,IAAxC,GAA+C,IAA/C,GAAsDmC,CAAC,CAACG,OAD1D;cAGAR,MAAM,GAAG,IAAT;YACD;UACF;QACF;MACF,CAbD;;MAeA,KAAKL,gBAAL;IACD;;;;EAvC8B5B,S;;AA0CjC0C,MAAM,CAACC,OAAP,GAAiBtB,kBAAjB"},"metadata":{},"sourceType":"script"}