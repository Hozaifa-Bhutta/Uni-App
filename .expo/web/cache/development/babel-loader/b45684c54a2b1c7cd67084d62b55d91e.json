{"ast":null,"code":"\"use strict\";\n\nvar _toConsumableArray = require(\"@babel/runtime/helpers/toConsumableArray\");\n\nvar _defineProperty = require(\"@babel/runtime/helpers/defineProperty\");\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nfunction _createForOfIteratorHelperLoose(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (it) return (it = it.call(o)).next.bind(it); if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nvar _require = require(\"./helpers/js\"),\n    isJsModule = _require.isJsModule,\n    wrapModule = _require.wrapModule;\n\nvar _require2 = require(\"metro-transform-plugins\"),\n    addParamsToDefineCall = _require2.addParamsToDefineCall;\n\nvar path = require(\"path\");\n\nvar url = require(\"url\");\n\nfunction generateModules(sourceModules, graph, options) {\n  var modules = [];\n\n  var _loop = function _loop(_module) {\n    if (isJsModule(_module)) {\n      var getURL = function getURL(extension) {\n        options.clientUrl.pathname = path.relative(options.projectRoot, path.join(path.dirname(_module.path), path.basename(_module.path, path.extname(_module.path)) + \".\" + extension));\n        return url.format(options.clientUrl);\n      };\n\n      var sourceMappingURL = getURL(\"map\");\n      var sourceURL = getURL(\"bundle\");\n      var code = prepareModule(_module, graph, options) + (\"\\n//# sourceMappingURL=\" + sourceMappingURL + \"\\n\") + (\"//# sourceURL=\" + sourceURL + \"\\n\");\n      modules.push({\n        module: [options.createModuleId(_module.path), code],\n        sourceMappingURL: sourceMappingURL,\n        sourceURL: sourceURL\n      });\n    }\n  };\n\n  for (var _iterator = _createForOfIteratorHelperLoose(sourceModules), _step; !(_step = _iterator()).done;) {\n    var _module = _step.value;\n\n    _loop(_module);\n  }\n\n  return modules;\n}\n\nfunction prepareModule(module, graph, options) {\n  var code = wrapModule(module, _objectSpread(_objectSpread({}, options), {}, {\n    dev: true\n  }));\n  var inverseDependencies = getInverseDependencies(module.path, graph);\n  var inverseDependenciesById = Object.create(null);\n  Object.keys(inverseDependencies).forEach(function (path) {\n    inverseDependenciesById[options.createModuleId(path)] = inverseDependencies[path].map(options.createModuleId);\n  });\n  return addParamsToDefineCall(code, inverseDependenciesById);\n}\n\nfunction getInverseDependencies(path, graph) {\n  var inverseDependencies = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n  if (path in inverseDependencies) {\n    return inverseDependencies;\n  }\n\n  var module = graph.dependencies.get(path);\n\n  if (!module) {\n    return inverseDependencies;\n  }\n\n  inverseDependencies[path] = [];\n\n  for (var _iterator2 = _createForOfIteratorHelperLoose(module.inverseDependencies), _step2; !(_step2 = _iterator2()).done;) {\n    var inverse = _step2.value;\n    inverseDependencies[path].push(inverse);\n    getInverseDependencies(inverse, graph, inverseDependencies);\n  }\n\n  return inverseDependencies;\n}\n\nfunction hmrJSBundle(delta, graph, options) {\n  return {\n    added: generateModules(delta.added.values(), graph, options),\n    modified: generateModules(delta.modified.values(), graph, options),\n    deleted: _toConsumableArray(delta.deleted).map(function (path) {\n      return options.createModuleId(path);\n    })\n  };\n}\n\nmodule.exports = hmrJSBundle;","map":{"version":3,"names":["require","isJsModule","wrapModule","addParamsToDefineCall","path","url","generateModules","sourceModules","graph","options","modules","module","getURL","extension","clientUrl","pathname","relative","projectRoot","join","dirname","basename","extname","format","sourceMappingURL","sourceURL","code","prepareModule","push","createModuleId","dev","inverseDependencies","getInverseDependencies","inverseDependenciesById","Object","create","keys","forEach","map","dependencies","get","inverse","hmrJSBundle","delta","added","values","modified","deleted","exports"],"sources":["/Users/hozaifa/Documents/Uni App Github/node_modules/@react-native-community/cli-plugin-metro/node_modules/metro/src/DeltaBundler/Serializers/hmrJSBundle.js"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *\n * @format\n */\n\"use strict\";\n\nconst { isJsModule, wrapModule } = require(\"./helpers/js\");\n\nconst { addParamsToDefineCall } = require(\"metro-transform-plugins\");\n\nconst path = require(\"path\");\n\nconst url = require(\"url\");\n\nfunction generateModules(sourceModules, graph, options) {\n  const modules = [];\n\n  for (const module of sourceModules) {\n    if (isJsModule(module)) {\n      // Construct a bundle URL for this specific module only\n      const getURL = (extension) => {\n        options.clientUrl.pathname = path.relative(\n          options.projectRoot,\n          path.join(\n            path.dirname(module.path),\n            path.basename(module.path, path.extname(module.path)) +\n              \".\" +\n              extension\n          )\n        );\n        return url.format(options.clientUrl);\n      };\n\n      const sourceMappingURL = getURL(\"map\");\n      const sourceURL = getURL(\"bundle\");\n      const code =\n        prepareModule(module, graph, options) +\n        `\\n//# sourceMappingURL=${sourceMappingURL}\\n` +\n        `//# sourceURL=${sourceURL}\\n`;\n      modules.push({\n        module: [options.createModuleId(module.path), code],\n        sourceMappingURL,\n        sourceURL,\n      });\n    }\n  }\n\n  return modules;\n}\n\nfunction prepareModule(module, graph, options) {\n  const code = wrapModule(module, { ...options, dev: true });\n  const inverseDependencies = getInverseDependencies(module.path, graph); // Transform the inverse dependency paths to ids.\n\n  const inverseDependenciesById = Object.create(null);\n  Object.keys(inverseDependencies).forEach((path) => {\n    inverseDependenciesById[options.createModuleId(path)] = inverseDependencies[\n      path\n    ].map(options.createModuleId);\n  });\n  return addParamsToDefineCall(code, inverseDependenciesById);\n}\n/**\n * Instead of adding the whole inverseDependncies object into each changed\n * module (which can be really huge if the dependency graph is big), we only\n * add the needed inverseDependencies for each changed module (we do this by\n * traversing upwards the dependency graph).\n */\n\nfunction getInverseDependencies(path, graph, inverseDependencies = {}) {\n  // Dependency alredy traversed.\n  if (path in inverseDependencies) {\n    return inverseDependencies;\n  }\n\n  const module = graph.dependencies.get(path);\n\n  if (!module) {\n    return inverseDependencies;\n  }\n\n  inverseDependencies[path] = [];\n\n  for (const inverse of module.inverseDependencies) {\n    inverseDependencies[path].push(inverse);\n    getInverseDependencies(inverse, graph, inverseDependencies);\n  }\n\n  return inverseDependencies;\n}\n\nfunction hmrJSBundle(delta, graph, options) {\n  return {\n    added: generateModules(delta.added.values(), graph, options),\n    modified: generateModules(delta.modified.values(), graph, options),\n    deleted: [...delta.deleted].map((path) => options.createModuleId(path)),\n  };\n}\n\nmodule.exports = hmrJSBundle;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}