{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"@babel/runtime/helpers/createClass\");\n\nvar fs = _interopRequireWildcard(require(\"fs\"));\n\nvar path = _interopRequireWildcard(require(\"path\"));\n\nvar _ws = _interopRequireDefault(require(\"ws\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _getRequireWildcardCache(nodeInterop) {\n  if (typeof WeakMap !== \"function\") return null;\n  var cacheBabelInterop = new WeakMap();\n  var cacheNodeInterop = new WeakMap();\n  return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) {\n    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\n  })(nodeInterop);\n}\n\nfunction _interopRequireWildcard(obj, nodeInterop) {\n  if (!nodeInterop && obj && obj.__esModule) {\n    return obj;\n  }\n\n  if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n    return {\n      default: obj\n    };\n  }\n\n  var cache = _getRequireWildcardCache(nodeInterop);\n\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n\n  for (var key in obj) {\n    if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n\n  newObj.default = obj;\n\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n\n  return newObj;\n}\n\nvar debug = require(\"debug\")(\"Metro:InspectorProxy\");\n\nvar PAGES_POLLING_INTERVAL = 1000;\nvar EMULATOR_LOCALHOST_ADDRESSES = [\"10.0.2.2\", \"10.0.3.2\"];\nvar FILE_PREFIX = \"file://\";\nvar REACT_NATIVE_RELOADABLE_PAGE_ID = \"-1\";\n\nvar Device = function () {\n  function Device(id, name, app, socket, projectRoot) {\n    var _this = this;\n\n    _classCallCheck(this, Device);\n\n    this._debuggerConnection = null;\n    this._lastConnectedReactNativePage = null;\n    this._isReloading = false;\n    this._lastGetPagesMessage = \"\";\n    this._scriptIdToSourcePathMapping = new Map();\n    this._id = id;\n    this._name = name;\n    this._app = app;\n    this._pages = [];\n    this._deviceSocket = socket;\n    this._projectRoot = projectRoot;\n\n    this._deviceSocket.on(\"message\", function (message) {\n      var parsedMessage = JSON.parse(message);\n\n      if (parsedMessage.event === \"getPages\") {\n        if (message !== _this._lastGetPagesMessage) {\n          debug(\"(Debugger)    (Proxy) <- (Device), getPages ping has changed: \" + message);\n          _this._lastGetPagesMessage = message;\n        }\n      } else {\n        debug(\"(Debugger)    (Proxy) <- (Device): \" + message);\n      }\n\n      _this._handleMessageFromDevice(parsedMessage);\n    });\n\n    this._deviceSocket.on(\"close\", function () {\n      if (_this._debuggerConnection) {\n        _this._debuggerConnection.socket.close();\n\n        _this._debuggerConnection = null;\n      }\n    });\n\n    this._setPagesPolling();\n  }\n\n  _createClass(Device, [{\n    key: \"getName\",\n    value: function getName() {\n      return this._name;\n    }\n  }, {\n    key: \"getPagesList\",\n    value: function getPagesList() {\n      if (this._lastConnectedReactNativePage) {\n        var reactNativeReloadablePage = {\n          id: REACT_NATIVE_RELOADABLE_PAGE_ID,\n          title: \"React Native Experimental (Improved Chrome Reloads)\",\n          vm: \"don't use\",\n          app: this._app\n        };\n        return this._pages.concat(reactNativeReloadablePage);\n      } else {\n        return this._pages;\n      }\n    }\n  }, {\n    key: \"handleDebuggerConnection\",\n    value: function handleDebuggerConnection(socket, pageId) {\n      var _this2 = this;\n\n      if (this._debuggerConnection) {\n        this._debuggerConnection.socket.close();\n\n        this._debuggerConnection = null;\n      }\n\n      var debuggerInfo = {\n        socket: socket,\n        prependedFilePrefix: false,\n        pageId: pageId\n      };\n      this._debuggerConnection = debuggerInfo;\n      debug(\"Got new debugger connection for page \" + pageId + \" of \" + this._name);\n\n      this._sendMessageToDevice({\n        event: \"connect\",\n        payload: {\n          pageId: this._mapToDevicePageId(pageId)\n        }\n      });\n\n      socket.on(\"message\", function (message) {\n        debug(\"(Debugger) -> (Proxy)    (Device): \" + message);\n        var debuggerRequest = JSON.parse(message);\n\n        var interceptedResponse = _this2._interceptMessageFromDebugger(debuggerRequest, debuggerInfo);\n\n        if (interceptedResponse) {\n          socket.send(JSON.stringify(interceptedResponse));\n        } else {\n          _this2._sendMessageToDevice({\n            event: \"wrappedEvent\",\n            payload: {\n              pageId: _this2._mapToDevicePageId(pageId),\n              wrappedEvent: JSON.stringify(debuggerRequest)\n            }\n          });\n        }\n      });\n      socket.on(\"close\", function () {\n        debug(\"Debugger for page \" + pageId + \" and \" + _this2._name + \" disconnected.\");\n\n        _this2._sendMessageToDevice({\n          event: \"disconnect\",\n          payload: {\n            pageId: _this2._mapToDevicePageId(pageId)\n          }\n        });\n\n        _this2._debuggerConnection = null;\n      });\n      var sendFunc = socket.send;\n\n      socket.send = function (message) {\n        debug(\"(Debugger) <- (Proxy)    (Device): \" + message);\n        return sendFunc.call(socket, message);\n      };\n    }\n  }, {\n    key: \"_handleMessageFromDevice\",\n    value: function _handleMessageFromDevice(message) {\n      if (message.event === \"getPages\") {\n        this._pages = message.payload;\n\n        for (var i = 0; i < this._pages.length; ++i) {\n          if (this._pages[i].title.indexOf(\"React\") >= 0) {\n            var _this$_lastConnectedR;\n\n            if (this._pages[i].id != ((_this$_lastConnectedR = this._lastConnectedReactNativePage) === null || _this$_lastConnectedR === void 0 ? void 0 : _this$_lastConnectedR.id)) {\n              this._newReactNativePage(this._pages[i]);\n\n              break;\n            }\n          }\n        }\n      } else if (message.event === \"disconnect\") {\n        var pageId = message.payload.pageId;\n        var debuggerSocket = this._debuggerConnection ? this._debuggerConnection.socket : null;\n\n        if (debuggerSocket && debuggerSocket.readyState === _ws.default.OPEN) {\n          if (this._debuggerConnection != null && this._debuggerConnection.pageId !== REACT_NATIVE_RELOADABLE_PAGE_ID) {\n            debug(\"Page \" + pageId + \" is reloading.\");\n            debuggerSocket.send(JSON.stringify({\n              method: \"reload\"\n            }));\n          }\n        }\n      } else if (message.event === \"wrappedEvent\") {\n        if (this._debuggerConnection == null) {\n          return;\n        }\n\n        var _debuggerSocket = this._debuggerConnection.socket;\n\n        if (_debuggerSocket == null || _debuggerSocket.readyState !== _ws.default.OPEN) {\n          return;\n        }\n\n        var parsedPayload = JSON.parse(message.payload.wrappedEvent);\n\n        if (this._debuggerConnection) {\n          this._processMessageFromDevice(parsedPayload, this._debuggerConnection);\n        }\n\n        var messageToSend = JSON.stringify(parsedPayload);\n\n        _debuggerSocket.send(messageToSend);\n      }\n    }\n  }, {\n    key: \"_sendMessageToDevice\",\n    value: function _sendMessageToDevice(message) {\n      try {\n        if (message.event !== \"getPages\") {\n          debug(\"(Debugger)    (Proxy) -> (Device): \" + JSON.stringify(message));\n        }\n\n        this._deviceSocket.send(JSON.stringify(message));\n      } catch (error) {}\n    }\n  }, {\n    key: \"_setPagesPolling\",\n    value: function _setPagesPolling() {\n      var _this3 = this;\n\n      setInterval(function () {\n        return _this3._sendMessageToDevice({\n          event: \"getPages\"\n        });\n      }, PAGES_POLLING_INTERVAL);\n    }\n  }, {\n    key: \"_newReactNativePage\",\n    value: function _newReactNativePage(page) {\n      var _this$_lastConnectedR2;\n\n      debug(\"React Native page updated to \" + page.id);\n\n      if (this._debuggerConnection == null || this._debuggerConnection.pageId !== REACT_NATIVE_RELOADABLE_PAGE_ID) {\n        this._lastConnectedReactNativePage = page;\n        return;\n      }\n\n      var oldPageId = (_this$_lastConnectedR2 = this._lastConnectedReactNativePage) === null || _this$_lastConnectedR2 === void 0 ? void 0 : _this$_lastConnectedR2.id;\n      this._lastConnectedReactNativePage = page;\n      this._isReloading = true;\n\n      if (oldPageId != null) {\n        this._sendMessageToDevice({\n          event: \"disconnect\",\n          payload: {\n            pageId: oldPageId\n          }\n        });\n      }\n\n      this._sendMessageToDevice({\n        event: \"connect\",\n        payload: {\n          pageId: page.id\n        }\n      });\n\n      var toSend = [{\n        method: \"Runtime.enable\",\n        id: 1e9\n      }, {\n        method: \"Debugger.enable\",\n        id: 1e9\n      }];\n\n      for (var _i = 0, _toSend = toSend; _i < _toSend.length; _i++) {\n        var message = _toSend[_i];\n\n        this._sendMessageToDevice({\n          event: \"wrappedEvent\",\n          payload: {\n            pageId: this._mapToDevicePageId(page.id),\n            wrappedEvent: JSON.stringify(message)\n          }\n        });\n      }\n    }\n  }, {\n    key: \"_processMessageFromDevice\",\n    value: function _processMessageFromDevice(payload, debuggerInfo) {\n      if (payload.method === \"Debugger.scriptParsed\") {\n        var params = payload.params || {};\n\n        if (\"sourceMapURL\" in params) {\n          for (var i = 0; i < EMULATOR_LOCALHOST_ADDRESSES.length; ++i) {\n            var address = EMULATOR_LOCALHOST_ADDRESSES[i];\n\n            if (params.sourceMapURL.indexOf(address) >= 0) {\n              payload.params.sourceMapURL = params.sourceMapURL.replace(address, \"localhost\");\n              debuggerInfo.originalSourceURLAddress = address;\n            }\n          }\n        }\n\n        if (\"url\" in params) {\n          for (var _i2 = 0; _i2 < EMULATOR_LOCALHOST_ADDRESSES.length; ++_i2) {\n            var _address = EMULATOR_LOCALHOST_ADDRESSES[_i2];\n\n            if (params.url.indexOf(_address) >= 0) {\n              payload.params.url = params.url.replace(_address, \"localhost\");\n              debuggerInfo.originalSourceURLAddress = _address;\n            }\n          }\n\n          if (payload.params.url.match(/^[0-9a-z]+$/)) {\n            payload.params.url = FILE_PREFIX + payload.params.url;\n            debuggerInfo.prependedFilePrefix = true;\n          }\n\n          if (params.scriptId != null) {\n            this._scriptIdToSourcePathMapping.set(params.scriptId, params.url);\n          }\n        }\n\n        if (debuggerInfo.pageId == REACT_NATIVE_RELOADABLE_PAGE_ID) {\n          if (payload.params.sourceMapURL) {\n            payload.params.sourceMapURL += \"&cachePrevention=\" + this._mapToDevicePageId(debuggerInfo.pageId);\n          }\n\n          if (payload.params.url) {\n            payload.params.url += \"&cachePrevention=\" + this._mapToDevicePageId(debuggerInfo.pageId);\n          }\n        }\n      }\n\n      if (payload.method === \"Runtime.executionContextCreated\" && this._isReloading) {\n        debuggerInfo.socket.send(JSON.stringify({\n          method: \"Runtime.executionContextsCleared\"\n        }));\n\n        this._sendMessageToDevice({\n          event: \"wrappedEvent\",\n          payload: {\n            pageId: this._mapToDevicePageId(debuggerInfo.pageId),\n            wrappedEvent: JSON.stringify({\n              method: \"Debugger.resume\",\n              id: 0\n            })\n          }\n        });\n\n        this._isReloading = false;\n      }\n    }\n  }, {\n    key: \"_interceptMessageFromDebugger\",\n    value: function _interceptMessageFromDebugger(req, debuggerInfo) {\n      var response = null;\n\n      if (req.method === \"Debugger.setBreakpointByUrl\") {\n        this._processDebuggerSetBreakpointByUrl(req, debuggerInfo);\n      } else if (req.method === \"Debugger.getScriptSource\") {\n        response = {\n          id: req.id,\n          result: this._processDebuggerGetScriptSource(req)\n        };\n      }\n\n      return response;\n    }\n  }, {\n    key: \"_processDebuggerSetBreakpointByUrl\",\n    value: function _processDebuggerSetBreakpointByUrl(req, debuggerInfo) {\n      if (debuggerInfo.originalSourceURLAddress) {\n        if (req.params.url) {\n          req.params.url = req.params.url.replace(\"localhost\", debuggerInfo.originalSourceURLAddress);\n\n          if (req.params.url && req.params.url.startsWith(FILE_PREFIX) && debuggerInfo.prependedFilePrefix) {\n            req.params.url = req.params.url.slice(FILE_PREFIX.length);\n          }\n        }\n\n        if (req.params.urlRegex) {\n          req.params.urlRegex = req.params.urlRegex.replace(/localhost/g, debuggerInfo.originalSourceURLAddress);\n        }\n      }\n    }\n  }, {\n    key: \"_processDebuggerGetScriptSource\",\n    value: function _processDebuggerGetScriptSource(req) {\n      var scriptSource = \"Source for script with id '\" + req.params.scriptId + \"' was not found.\";\n\n      var pathToSource = this._scriptIdToSourcePathMapping.get(req.params.scriptId);\n\n      if (pathToSource) {\n        try {\n          scriptSource = fs.readFileSync(path.resolve(this._projectRoot, pathToSource), \"utf8\");\n        } catch (err) {\n          scriptSource = err.message;\n        }\n      }\n\n      return {\n        scriptSource: scriptSource\n      };\n    }\n  }, {\n    key: \"_mapToDevicePageId\",\n    value: function _mapToDevicePageId(pageId) {\n      if (pageId === REACT_NATIVE_RELOADABLE_PAGE_ID && this._lastConnectedReactNativePage != null) {\n        return this._lastConnectedReactNativePage.id;\n      } else {\n        return pageId;\n      }\n    }\n  }]);\n\n  return Device;\n}();\n\nmodule.exports = Device;","map":{"version":3,"names":["fs","_interopRequireWildcard","require","path","_ws","_interopRequireDefault","obj","__esModule","default","_getRequireWildcardCache","nodeInterop","WeakMap","cacheBabelInterop","cacheNodeInterop","cache","has","get","newObj","hasPropertyDescriptor","Object","defineProperty","getOwnPropertyDescriptor","key","prototype","hasOwnProperty","call","desc","set","debug","PAGES_POLLING_INTERVAL","EMULATOR_LOCALHOST_ADDRESSES","FILE_PREFIX","REACT_NATIVE_RELOADABLE_PAGE_ID","Device","id","name","app","socket","projectRoot","_debuggerConnection","_lastConnectedReactNativePage","_isReloading","_lastGetPagesMessage","_scriptIdToSourcePathMapping","Map","_id","_name","_app","_pages","_deviceSocket","_projectRoot","on","message","parsedMessage","JSON","parse","event","_handleMessageFromDevice","close","_setPagesPolling","reactNativeReloadablePage","title","vm","concat","pageId","debuggerInfo","prependedFilePrefix","_sendMessageToDevice","payload","_mapToDevicePageId","debuggerRequest","interceptedResponse","_interceptMessageFromDebugger","send","stringify","wrappedEvent","sendFunc","i","length","indexOf","_this$_lastConnectedR","_newReactNativePage","debuggerSocket","readyState","OPEN","method","parsedPayload","_processMessageFromDevice","messageToSend","error","setInterval","page","_this$_lastConnectedR2","oldPageId","toSend","params","address","sourceMapURL","replace","originalSourceURLAddress","url","match","scriptId","req","response","_processDebuggerSetBreakpointByUrl","result","_processDebuggerGetScriptSource","startsWith","slice","urlRegex","scriptSource","pathToSource","readFileSync","resolve","err","module","exports"],"sources":["/Users/hozaifa/Documents/Uni App Github/node_modules/@react-native-community/cli-plugin-metro/node_modules/metro-inspector-proxy/src/Device.js"],"sourcesContent":["\"use strict\";\n\nvar fs = _interopRequireWildcard(require(\"fs\"));\n\nvar path = _interopRequireWildcard(require(\"path\"));\n\nvar _ws = _interopRequireDefault(require(\"ws\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : { default: obj };\n}\n\nfunction _getRequireWildcardCache(nodeInterop) {\n  if (typeof WeakMap !== \"function\") return null;\n  var cacheBabelInterop = new WeakMap();\n  var cacheNodeInterop = new WeakMap();\n  return (_getRequireWildcardCache = function (nodeInterop) {\n    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\n  })(nodeInterop);\n}\n\nfunction _interopRequireWildcard(obj, nodeInterop) {\n  if (!nodeInterop && obj && obj.__esModule) {\n    return obj;\n  }\n  if (obj === null || (typeof obj !== \"object\" && typeof obj !== \"function\")) {\n    return { default: obj };\n  }\n  var cache = _getRequireWildcardCache(nodeInterop);\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n  var newObj = {};\n  var hasPropertyDescriptor =\n    Object.defineProperty && Object.getOwnPropertyDescriptor;\n  for (var key in obj) {\n    if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor\n        ? Object.getOwnPropertyDescriptor(obj, key)\n        : null;\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n  newObj.default = obj;\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n  return newObj;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *\n * @format\n */\nconst debug = require(\"debug\")(\"Metro:InspectorProxy\");\n\nconst PAGES_POLLING_INTERVAL = 1000; // Android's stock emulator and other emulators such as genymotion use a standard localhost alias.\n\nconst EMULATOR_LOCALHOST_ADDRESSES = [\"10.0.2.2\", \"10.0.3.2\"]; // Prefix for script URLs that are alphanumeric IDs. See comment in _processMessageFromDevice method for\n// more details.\n\nconst FILE_PREFIX = \"file://\";\nconst REACT_NATIVE_RELOADABLE_PAGE_ID = \"-1\";\n/**\n * Device class represents single device connection to Inspector Proxy. Each device\n * can have multiple inspectable pages.\n */\n\nclass Device {\n  // ID of the device.\n  // Name of the device.\n  // Package name of the app.\n  // Stores socket connection between Inspector Proxy and device.\n  // Stores last list of device's pages.\n  // Stores information about currently connected debugger (if any).\n  _debuggerConnection = null; // Last known Page ID of the React Native page.\n  // This is used by debugger connections that don't have PageID specified\n  // (and will interact with the latest React Native page).\n\n  _lastConnectedReactNativePage = null; // Whether we are in the middle of a reload in the REACT_NATIVE_RELOADABLE_PAGE.\n\n  _isReloading = false; // The previous \"GetPages\" message, for deduplication in debug logs.\n\n  _lastGetPagesMessage = \"\"; // Mapping built from scriptParsed events and used to fetch file content in `Debugger.getScriptSource`.\n\n  _scriptIdToSourcePathMapping = new Map(); // Root of the project used for relative to absolute source path conversion.\n\n  constructor(id, name, app, socket, projectRoot) {\n    this._id = id;\n    this._name = name;\n    this._app = app;\n    this._pages = [];\n    this._deviceSocket = socket;\n    this._projectRoot = projectRoot;\n\n    this._deviceSocket.on(\"message\", (message) => {\n      const parsedMessage = JSON.parse(message);\n\n      if (parsedMessage.event === \"getPages\") {\n        // There's a 'getPages' message every second, so only show them if they change\n        if (message !== this._lastGetPagesMessage) {\n          debug(\n            \"(Debugger)    (Proxy) <- (Device), getPages ping has changed: \" +\n              message\n          );\n          this._lastGetPagesMessage = message;\n        }\n      } else {\n        debug(\"(Debugger)    (Proxy) <- (Device): \" + message);\n      }\n\n      this._handleMessageFromDevice(parsedMessage);\n    });\n\n    this._deviceSocket.on(\"close\", () => {\n      // Device disconnected - close debugger connection.\n      if (this._debuggerConnection) {\n        this._debuggerConnection.socket.close();\n\n        this._debuggerConnection = null;\n      }\n    });\n\n    this._setPagesPolling();\n  }\n\n  getName() {\n    return this._name;\n  }\n\n  getPagesList() {\n    if (this._lastConnectedReactNativePage) {\n      const reactNativeReloadablePage = {\n        id: REACT_NATIVE_RELOADABLE_PAGE_ID,\n        title: \"React Native Experimental (Improved Chrome Reloads)\",\n        vm: \"don't use\",\n        app: this._app,\n      };\n      return this._pages.concat(reactNativeReloadablePage);\n    } else {\n      return this._pages;\n    }\n  } // Handles new debugger connection to this device:\n  // 1. Sends connect event to device\n  // 2. Forwards all messages from the debugger to device as wrappedEvent\n  // 3. Sends disconnect event to device when debugger connection socket closes.\n\n  handleDebuggerConnection(socket, pageId) {\n    // Disconnect current debugger if we already have debugger connected.\n    if (this._debuggerConnection) {\n      this._debuggerConnection.socket.close();\n\n      this._debuggerConnection = null;\n    }\n\n    const debuggerInfo = {\n      socket,\n      prependedFilePrefix: false,\n      pageId,\n    };\n    this._debuggerConnection = debuggerInfo;\n    debug(`Got new debugger connection for page ${pageId} of ${this._name}`);\n\n    this._sendMessageToDevice({\n      event: \"connect\",\n      payload: {\n        pageId: this._mapToDevicePageId(pageId),\n      },\n    });\n\n    socket.on(\"message\", (message) => {\n      debug(\"(Debugger) -> (Proxy)    (Device): \" + message);\n      const debuggerRequest = JSON.parse(message);\n\n      const interceptedResponse = this._interceptMessageFromDebugger(\n        debuggerRequest,\n        debuggerInfo\n      );\n\n      if (interceptedResponse) {\n        socket.send(JSON.stringify(interceptedResponse));\n      } else {\n        this._sendMessageToDevice({\n          event: \"wrappedEvent\",\n          payload: {\n            pageId: this._mapToDevicePageId(pageId),\n            wrappedEvent: JSON.stringify(debuggerRequest),\n          },\n        });\n      }\n    });\n    socket.on(\"close\", () => {\n      debug(`Debugger for page ${pageId} and ${this._name} disconnected.`);\n\n      this._sendMessageToDevice({\n        event: \"disconnect\",\n        payload: {\n          pageId: this._mapToDevicePageId(pageId),\n        },\n      });\n\n      this._debuggerConnection = null;\n    });\n    const sendFunc = socket.send;\n\n    socket.send = function (message) {\n      debug(\"(Debugger) <- (Proxy)    (Device): \" + message);\n      return sendFunc.call(socket, message);\n    };\n  } // Handles messages received from device:\n  // 1. For getPages responses updates local _pages list.\n  // 2. All other messages are forwarded to debugger as wrappedEvent.\n  //\n  // In the future more logic will be added to this method for modifying\n  // some of the messages (like updating messages with source maps and file\n  // locations).\n\n  _handleMessageFromDevice(message) {\n    if (message.event === \"getPages\") {\n      this._pages = message.payload; // Check if device have new React Native page.\n      // There is usually no more than 2-3 pages per device so this operation\n      // is not expensive.\n      // TODO(hypuk): It is better for VM to send update event when new page is\n      // created instead of manually checking this on every getPages result.\n\n      for (let i = 0; i < this._pages.length; ++i) {\n        if (this._pages[i].title.indexOf(\"React\") >= 0) {\n          var _this$_lastConnectedR;\n\n          if (\n            this._pages[i].id !=\n            ((_this$_lastConnectedR = this._lastConnectedReactNativePage) ===\n              null || _this$_lastConnectedR === void 0\n              ? void 0\n              : _this$_lastConnectedR.id)\n          ) {\n            this._newReactNativePage(this._pages[i]);\n\n            break;\n          }\n        }\n      }\n    } else if (message.event === \"disconnect\") {\n      // Device sends disconnect events only when page is reloaded or\n      // if debugger socket was disconnected.\n      const pageId = message.payload.pageId;\n      const debuggerSocket = this._debuggerConnection\n        ? this._debuggerConnection.socket\n        : null;\n\n      if (debuggerSocket && debuggerSocket.readyState === _ws.default.OPEN) {\n        if (\n          this._debuggerConnection != null &&\n          this._debuggerConnection.pageId !== REACT_NATIVE_RELOADABLE_PAGE_ID\n        ) {\n          debug(`Page ${pageId} is reloading.`);\n          debuggerSocket.send(\n            JSON.stringify({\n              method: \"reload\",\n            })\n          );\n        }\n      }\n    } else if (message.event === \"wrappedEvent\") {\n      if (this._debuggerConnection == null) {\n        return;\n      } // FIXME: Is it possible that we received message for pageID that does not\n      // correspond to current debugger connection?\n\n      const debuggerSocket = this._debuggerConnection.socket;\n\n      if (\n        debuggerSocket == null ||\n        debuggerSocket.readyState !== _ws.default.OPEN\n      ) {\n        // TODO(hypuk): Send error back to device?\n        return;\n      }\n\n      const parsedPayload = JSON.parse(message.payload.wrappedEvent);\n\n      if (this._debuggerConnection) {\n        // Wrapping just to make flow happy :)\n        this._processMessageFromDevice(parsedPayload, this._debuggerConnection);\n      }\n\n      const messageToSend = JSON.stringify(parsedPayload);\n      debuggerSocket.send(messageToSend);\n    }\n  } // Sends single message to device.\n\n  _sendMessageToDevice(message) {\n    try {\n      if (message.event !== \"getPages\") {\n        debug(\"(Debugger)    (Proxy) -> (Device): \" + JSON.stringify(message));\n      }\n\n      this._deviceSocket.send(JSON.stringify(message));\n    } catch (error) {}\n  } // Sends 'getPages' request to device every PAGES_POLLING_INTERVAL milliseconds.\n\n  _setPagesPolling() {\n    setInterval(\n      () =>\n        this._sendMessageToDevice({\n          event: \"getPages\",\n        }),\n      PAGES_POLLING_INTERVAL\n    );\n  } // We received new React Native Page ID.\n\n  _newReactNativePage(page) {\n    var _this$_lastConnectedR2;\n\n    debug(`React Native page updated to ${page.id}`);\n\n    if (\n      this._debuggerConnection == null ||\n      this._debuggerConnection.pageId !== REACT_NATIVE_RELOADABLE_PAGE_ID\n    ) {\n      // We can just remember new page ID without any further actions if no\n      // debugger is currently attached or attached debugger is not\n      // \"Reloadable React Native\" connection.\n      this._lastConnectedReactNativePage = page;\n      return;\n    }\n\n    const oldPageId =\n      (_this$_lastConnectedR2 = this._lastConnectedReactNativePage) === null ||\n      _this$_lastConnectedR2 === void 0\n        ? void 0\n        : _this$_lastConnectedR2.id;\n    this._lastConnectedReactNativePage = page;\n    this._isReloading = true; // We already had a debugger connected to React Native page and a\n    // new one appeared - in this case we need to emulate execution context\n    // detroy and resend Debugger.enable and Runtime.enable commands to new\n    // page.\n\n    if (oldPageId != null) {\n      this._sendMessageToDevice({\n        event: \"disconnect\",\n        payload: {\n          pageId: oldPageId,\n        },\n      });\n    }\n\n    this._sendMessageToDevice({\n      event: \"connect\",\n      payload: {\n        pageId: page.id,\n      },\n    });\n\n    const toSend = [\n      {\n        method: \"Runtime.enable\",\n        id: 1e9,\n      },\n      {\n        method: \"Debugger.enable\",\n        id: 1e9,\n      },\n    ];\n\n    for (const message of toSend) {\n      this._sendMessageToDevice({\n        event: \"wrappedEvent\",\n        payload: {\n          pageId: this._mapToDevicePageId(page.id),\n          wrappedEvent: JSON.stringify(message),\n        },\n      });\n    }\n  } // Allows to make changes in incoming message from device.\n\n  _processMessageFromDevice(payload, debuggerInfo) {\n    // Replace Android addresses for scriptParsed event.\n    if (payload.method === \"Debugger.scriptParsed\") {\n      const params = payload.params || {};\n\n      if (\"sourceMapURL\" in params) {\n        for (let i = 0; i < EMULATOR_LOCALHOST_ADDRESSES.length; ++i) {\n          const address = EMULATOR_LOCALHOST_ADDRESSES[i];\n\n          if (params.sourceMapURL.indexOf(address) >= 0) {\n            payload.params.sourceMapURL = params.sourceMapURL.replace(\n              address,\n              \"localhost\"\n            );\n            debuggerInfo.originalSourceURLAddress = address;\n          }\n        }\n      }\n\n      if (\"url\" in params) {\n        for (let i = 0; i < EMULATOR_LOCALHOST_ADDRESSES.length; ++i) {\n          const address = EMULATOR_LOCALHOST_ADDRESSES[i];\n\n          if (params.url.indexOf(address) >= 0) {\n            payload.params.url = params.url.replace(address, \"localhost\");\n            debuggerInfo.originalSourceURLAddress = address;\n          }\n        } // Chrome doesn't download source maps if URL param is not a valid\n        // URL. Some frameworks pass alphanumeric script ID instead of URL which causes\n        // Chrome to not download source maps. In this case we want to prepend script ID\n        // with 'file://' prefix.\n\n        if (payload.params.url.match(/^[0-9a-z]+$/)) {\n          payload.params.url = FILE_PREFIX + payload.params.url;\n          debuggerInfo.prependedFilePrefix = true;\n        } // $FlowFixMe[prop-missing]\n\n        if (params.scriptId != null) {\n          this._scriptIdToSourcePathMapping.set(params.scriptId, params.url);\n        }\n      }\n\n      if (debuggerInfo.pageId == REACT_NATIVE_RELOADABLE_PAGE_ID) {\n        // Chrome won't use the source map unless it appears to be new.\n        if (payload.params.sourceMapURL) {\n          payload.params.sourceMapURL +=\n            \"&cachePrevention=\" + this._mapToDevicePageId(debuggerInfo.pageId);\n        }\n\n        if (payload.params.url) {\n          payload.params.url +=\n            \"&cachePrevention=\" + this._mapToDevicePageId(debuggerInfo.pageId);\n        }\n      }\n    }\n\n    if (\n      payload.method === \"Runtime.executionContextCreated\" &&\n      this._isReloading\n    ) {\n      // The new context is ready. First notify Chrome that we've reloaded so\n      // it'll resend its breakpoints. If we do this earlier, we may not be\n      // ready to receive them.\n      debuggerInfo.socket.send(\n        JSON.stringify({\n          method: \"Runtime.executionContextsCleared\",\n        })\n      ); // The VM starts in a paused mode. Ask it to resume.\n      // Note that if setting breakpoints in early initialization functions,\n      // there's a currently race condition between these functions executing\n      // and Chrome re-applying the breakpoints due to the message above.\n      //\n      // This is not an issue in VSCode/Nuclide where the IDE knows to resume\n      // at its convenience.\n\n      this._sendMessageToDevice({\n        event: \"wrappedEvent\",\n        payload: {\n          pageId: this._mapToDevicePageId(debuggerInfo.pageId),\n          wrappedEvent: JSON.stringify({\n            method: \"Debugger.resume\",\n            id: 0,\n          }),\n        },\n      });\n\n      this._isReloading = false;\n    }\n  } // Allows to make changes in incoming messages from debugger.\n\n  _interceptMessageFromDebugger(req, debuggerInfo) {\n    let response = null;\n\n    if (req.method === \"Debugger.setBreakpointByUrl\") {\n      this._processDebuggerSetBreakpointByUrl(req, debuggerInfo);\n    } else if (req.method === \"Debugger.getScriptSource\") {\n      response = {\n        id: req.id,\n        result: this._processDebuggerGetScriptSource(req),\n      };\n    }\n\n    return response;\n  }\n\n  _processDebuggerSetBreakpointByUrl(req, debuggerInfo) {\n    // If we replaced Android emulator's address to localhost we need to change it back.\n    if (debuggerInfo.originalSourceURLAddress) {\n      if (req.params.url) {\n        req.params.url = req.params.url.replace(\n          \"localhost\",\n          debuggerInfo.originalSourceURLAddress\n        );\n\n        if (\n          req.params.url &&\n          req.params.url.startsWith(FILE_PREFIX) &&\n          debuggerInfo.prependedFilePrefix\n        ) {\n          // Remove fake URL prefix if we modified URL in _processMessageFromDevice.\n          req.params.url = req.params.url.slice(FILE_PREFIX.length);\n        }\n      }\n\n      if (req.params.urlRegex) {\n        req.params.urlRegex = req.params.urlRegex.replace(\n          /localhost/g,\n          debuggerInfo.originalSourceURLAddress\n        );\n      }\n    }\n  }\n\n  _processDebuggerGetScriptSource(req) {\n    let scriptSource = `Source for script with id '${req.params.scriptId}' was not found.`;\n\n    const pathToSource = this._scriptIdToSourcePathMapping.get(\n      req.params.scriptId\n    );\n\n    if (pathToSource) {\n      try {\n        scriptSource = fs.readFileSync(\n          path.resolve(this._projectRoot, pathToSource),\n          \"utf8\"\n        );\n      } catch (err) {\n        scriptSource = err.message;\n      }\n    }\n\n    return {\n      scriptSource,\n    };\n  }\n\n  _mapToDevicePageId(pageId) {\n    if (\n      pageId === REACT_NATIVE_RELOADABLE_PAGE_ID &&\n      this._lastConnectedReactNativePage != null\n    ) {\n      return this._lastConnectedReactNativePage.id;\n    } else {\n      return pageId;\n    }\n  }\n}\n\nmodule.exports = Device;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}