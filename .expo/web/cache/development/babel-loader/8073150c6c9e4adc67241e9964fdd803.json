{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = assign;\n\nfunction assign(target) {\n  for (var _len = arguments.length, sources = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    sources[_key - 1] = arguments[_key];\n  }\n\n  sources.forEach(function (source) {\n    var descriptors = Object.keys(source).reduce(function (acc, key) {\n      var propertyDescriptor = Object.getOwnPropertyDescriptor(source, key);\n\n      if (propertyDescriptor !== undefined) {\n        acc[key] = propertyDescriptor;\n      }\n\n      return acc;\n    }, {});\n    Object.getOwnPropertySymbols(source).forEach(function (sym) {\n      var descriptor = Object.getOwnPropertyDescriptor(source, sym);\n\n      if (descriptor && descriptor.enumerable) {\n        descriptors[sym.toString()] = descriptor;\n      }\n    });\n    Object.defineProperties(target, descriptors);\n  });\n  return target;\n}","map":{"version":3,"sources":["../src/assign.ts"],"names":["sources","source","descriptors","propertyDescriptor","Object","acc","sym","descriptor"],"mappings":";;;;;;;AAOe,SAAA,MAAA,CAAA,MAAA,EAAsD;EAAA,kCAAtD,OAAsD;IAAtD,OAAsD;EAAA;;EACnEA,OAAO,CAAPA,OAAAA,CAAiBC,UAAAA,MAAD,EAAY;IAC1B,IAAIC,WAAW,GAAG,MAAM,CAAN,IAAA,CAAA,MAAA,EAAA,MAAA,CAA2B,UAAA,GAAA,EAAA,GAAA,EAAc;MACzD,IAAMC,kBAAkB,GAAGC,MAAM,CAANA,wBAAAA,CAAAA,MAAAA,EAA3B,GAA2BA,CAA3B;;MACA,IAAID,kBAAkB,KAAtB,SAAA,EAAsC;QACpCE,GAAG,CAAHA,GAAG,CAAHA,GAAAA,kBAAAA;MACD;;MACD,OAAA,GAAA;IALgB,CAAA,EADQ,EACR,CAAlB;IAQAD,MAAM,CAANA,qBAAAA,CAAAA,MAAAA,EAAAA,OAAAA,CAA8CE,UAAAA,GAAD,EAAS;MACpD,IAAIC,UAAU,GAAGH,MAAM,CAANA,wBAAAA,CAAAA,MAAAA,EAAjB,GAAiBA,CAAjB;;MACA,IAAIG,UAAU,IAAIA,UAAU,CAA5B,UAAA,EAAyC;QACvCL,WAAW,CAACI,GAAG,CAAfJ,QAAYI,EAAD,CAAXJ,GAAAA,UAAAA;MACD;IAJHE,CAAAA;IAMAA,MAAM,CAANA,gBAAAA,CAAAA,MAAAA,EAAAA,WAAAA;EAfFJ,CAAAA;EAiBA,OAAA,MAAA;AACD","sourcesContent":["/**\n * Source: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign\n *\n * Similar to Object.assign(), but it doesn't execute getters. This allows us to have\n * lazy properties on an object and still be able to merge them together\n *\n */\nexport default function assign(target: Object, ...sources: Object[]) {\n  sources.forEach((source) => {\n    let descriptors = Object.keys(source).reduce((acc, key) => {\n      const propertyDescriptor = Object.getOwnPropertyDescriptor(source, key);\n      if (propertyDescriptor !== undefined) {\n        acc[key] = propertyDescriptor;\n      }\n      return acc;\n    }, {} as PropertyDescriptorMap);\n    // by default, Object.assign copies enumerable Symbols too\n    Object.getOwnPropertySymbols(source).forEach((sym) => {\n      let descriptor = Object.getOwnPropertyDescriptor(source, sym);\n      if (descriptor && descriptor.enumerable) {\n        descriptors[sym.toString()] = descriptor;\n      }\n    });\n    Object.defineProperties(target, descriptors);\n  });\n  return target;\n}\n"]},"metadata":{},"sourceType":"script"}