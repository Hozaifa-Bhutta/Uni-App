{"ast":null,"code":"\"use strict\";\n\nvar _toConsumableArray = require(\"@babel/runtime/helpers/toConsumableArray\");\n\nvar _defineProperty = require(\"@babel/runtime/helpers/defineProperty\");\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nvar template = require(\"@babel/template\").default;\n\nvar nullthrows = require(\"nullthrows\");\n\nvar importTemplate = template.statement(\"\\n  var LOCAL = IMPORT(FILE);\\n\");\nvar importNamedTemplate = template.statement(\"\\n  var LOCAL = require(FILE).REMOTE;\\n\");\nvar importSideEffectTemplate = template.statement(\"\\n  require(FILE);\\n\");\nvar exportAllTemplate = template.statements(\"\\n  var REQUIRED = require(FILE);\\n\\n  for (var KEY in REQUIRED) {\\n    exports[KEY] = REQUIRED[KEY];\\n  }\\n\");\nvar exportTemplate = template.statement(\"\\n  exports.REMOTE = LOCAL;\\n\");\nvar esModuleExportTemplate = template.statement(\"\\n  Object.defineProperty(exports, '__esModule', {value: true});\\n\");\nvar resolveTemplate = template.expression(\"\\n  require.resolve(NODE)\\n\");\n\nfunction resolvePath(node, resolve) {\n  if (!resolve) {\n    return node;\n  }\n\n  return resolveTemplate({\n    NODE: node\n  });\n}\n\nfunction withLocation(node, loc) {\n  if (Array.isArray(node)) {\n    return node.map(function (n) {\n      return withLocation(n, loc);\n    });\n  }\n\n  if (!node.loc) {\n    return _objectSpread(_objectSpread({}, node), {}, {\n      loc: loc\n    });\n  }\n\n  return node;\n}\n\nfunction importExportPlugin(_ref) {\n  var t = _ref.types;\n  var isDeclaration = t.isDeclaration,\n      isVariableDeclaration = t.isVariableDeclaration;\n  return {\n    visitor: {\n      ExportAllDeclaration: function ExportAllDeclaration(path, state) {\n        state.exportAll.push({\n          file: path.node.source.value,\n          loc: path.node.loc\n        });\n        path.remove();\n      },\n      ExportDefaultDeclaration: function ExportDefaultDeclaration(path, state) {\n        var declaration = path.node.declaration;\n        var id = declaration.id || path.scope.generateUidIdentifier(\"default\");\n        declaration.id = id;\n        var loc = path.node.loc;\n        state.exportDefault.push({\n          local: id.name,\n          loc: loc\n        });\n\n        if (isDeclaration(declaration)) {\n          path.insertBefore(withLocation(declaration, loc));\n        } else {\n          path.insertBefore(withLocation(t.variableDeclaration(\"var\", [t.variableDeclarator(id, declaration)]), loc));\n        }\n\n        path.remove();\n      },\n      ExportNamedDeclaration: function ExportNamedDeclaration(path, state) {\n        if (path.node.exportKind && path.node.exportKind !== \"value\") {\n          return;\n        }\n\n        var declaration = path.node.declaration;\n        var loc = path.node.loc;\n\n        if (declaration) {\n          if (isVariableDeclaration(declaration)) {\n            declaration.declarations.forEach(function (d) {\n              switch (d.id.type) {\n                case \"ObjectPattern\":\n                  {\n                    var properties = d.id.properties;\n                    properties.forEach(function (p) {\n                      var name = p.key.name;\n                      state.exportNamed.push({\n                        local: name,\n                        remote: name,\n                        loc: loc\n                      });\n                    });\n                  }\n                  break;\n\n                case \"ArrayPattern\":\n                  {\n                    var elements = d.id.elements;\n                    elements.forEach(function (e) {\n                      var name = e.name;\n                      state.exportNamed.push({\n                        local: name,\n                        remote: name,\n                        loc: loc\n                      });\n                    });\n                  }\n                  break;\n\n                default:\n                  {\n                    var name = d.id.name;\n                    state.exportNamed.push({\n                      local: name,\n                      remote: name,\n                      loc: loc\n                    });\n                  }\n                  break;\n              }\n            });\n          } else {\n            var id = declaration.id || path.scope.generateUidIdentifier();\n            var name = id.name;\n            declaration.id = id;\n            state.exportNamed.push({\n              local: name,\n              remote: name,\n              loc: loc\n            });\n          }\n\n          path.insertBefore(declaration);\n        }\n\n        var specifiers = path.node.specifiers;\n\n        if (specifiers) {\n          specifiers.forEach(function (s) {\n            var local = s.local;\n            var remote = s.exported;\n\n            if (remote.type === \"StringLiteral\") {\n              throw path.buildCodeFrameError(\"Module string names are not supported\");\n            }\n\n            if (path.node.source) {\n              var temp = path.scope.generateUidIdentifier(local.name);\n\n              if (local.name === \"default\") {\n                path.insertBefore(withLocation(importTemplate({\n                  IMPORT: t.cloneNode(state.importDefault),\n                  FILE: resolvePath(t.cloneNode(nullthrows(path.node.source)), state.opts.resolve),\n                  LOCAL: temp\n                }), loc));\n                state.exportNamed.push({\n                  local: temp.name,\n                  remote: remote.name,\n                  loc: loc\n                });\n              } else if (remote.name === \"default\") {\n                path.insertBefore(withLocation(importNamedTemplate({\n                  FILE: resolvePath(t.cloneNode(nullthrows(path.node.source)), state.opts.resolve),\n                  LOCAL: temp,\n                  REMOTE: local\n                }), loc));\n                state.exportDefault.push({\n                  local: temp.name,\n                  loc: loc\n                });\n              } else {\n                path.insertBefore(withLocation(importNamedTemplate({\n                  FILE: resolvePath(t.cloneNode(nullthrows(path.node.source)), state.opts.resolve),\n                  LOCAL: temp,\n                  REMOTE: local\n                }), loc));\n                state.exportNamed.push({\n                  local: temp.name,\n                  remote: remote.name,\n                  loc: loc\n                });\n              }\n            } else {\n              if (remote.name === \"default\") {\n                state.exportDefault.push({\n                  local: local.name,\n                  loc: loc\n                });\n              } else {\n                state.exportNamed.push({\n                  local: local.name,\n                  remote: remote.name,\n                  loc: loc\n                });\n              }\n            }\n          });\n        }\n\n        path.remove();\n      },\n      ImportDeclaration: function ImportDeclaration(path, state) {\n        if (path.node.importKind && path.node.importKind !== \"value\") {\n          return;\n        }\n\n        var file = path.node.source;\n        var specifiers = path.node.specifiers;\n        var loc = path.node.loc;\n\n        if (!specifiers.length) {\n          state.imports.push({\n            node: withLocation(importSideEffectTemplate({\n              FILE: resolvePath(t.cloneNode(file), state.opts.resolve)\n            }), loc)\n          });\n        } else {\n          var sharedModuleImport;\n          var sharedModuleVariableDeclaration = null;\n\n          if (specifiers.filter(function (s) {\n            return s.type === \"ImportSpecifier\" && (s.imported.type === \"StringLiteral\" || s.imported.name !== \"default\");\n          }).length > 1) {\n            sharedModuleImport = path.scope.generateUidIdentifierBasedOnNode(file);\n            sharedModuleVariableDeclaration = withLocation(t.variableDeclaration(\"var\", [t.variableDeclarator(t.cloneNode(sharedModuleImport), t.callExpression(t.identifier(\"require\"), [resolvePath(t.cloneNode(file), state.opts.resolve)]))]), loc);\n            state.imports.push({\n              node: sharedModuleVariableDeclaration\n            });\n          }\n\n          specifiers.forEach(function (s) {\n            var imported = s.imported;\n            var local = s.local;\n\n            switch (s.type) {\n              case \"ImportNamespaceSpecifier\":\n                state.imports.push({\n                  node: withLocation(importTemplate({\n                    IMPORT: t.cloneNode(state.importAll),\n                    FILE: resolvePath(t.cloneNode(file), state.opts.resolve),\n                    LOCAL: t.cloneNode(local)\n                  }), loc)\n                });\n                break;\n\n              case \"ImportDefaultSpecifier\":\n                state.imports.push({\n                  node: withLocation(importTemplate({\n                    IMPORT: t.cloneNode(state.importDefault),\n                    FILE: resolvePath(t.cloneNode(file), state.opts.resolve),\n                    LOCAL: t.cloneNode(local)\n                  }), loc)\n                });\n                break;\n\n              case \"ImportSpecifier\":\n                if (imported.name === \"default\") {\n                  state.imports.push({\n                    node: withLocation(importTemplate({\n                      IMPORT: t.cloneNode(state.importDefault),\n                      FILE: resolvePath(t.cloneNode(file), state.opts.resolve),\n                      LOCAL: t.cloneNode(local)\n                    }), loc)\n                  });\n                } else if (sharedModuleVariableDeclaration != null) {\n                  sharedModuleVariableDeclaration.declarations.push(withLocation(t.variableDeclarator(t.cloneNode(local), t.memberExpression(t.cloneNode(sharedModuleImport), t.cloneNode(imported))), loc));\n                } else {\n                  state.imports.push({\n                    node: withLocation(importNamedTemplate({\n                      FILE: resolvePath(t.cloneNode(file), state.opts.resolve),\n                      LOCAL: t.cloneNode(local),\n                      REMOTE: t.cloneNode(imported)\n                    }), loc)\n                  });\n                }\n\n                break;\n\n              default:\n                throw new TypeError(\"Unknown import type: \" + s.type);\n            }\n          });\n        }\n\n        path.remove();\n      },\n      Program: {\n        enter: function enter(path, state) {\n          state.exportAll = [];\n          state.exportDefault = [];\n          state.exportNamed = [];\n          state.imports = [];\n          state.importAll = t.identifier(state.opts.importAll);\n          state.importDefault = t.identifier(state.opts.importDefault);\n        },\n        exit: function exit(path, state) {\n          var body = path.node.body;\n          state.imports.reverse().forEach(function (e) {\n            body.unshift(e.node);\n          });\n          state.exportDefault.forEach(function (e) {\n            body.push(withLocation(exportTemplate({\n              LOCAL: t.identifier(e.local),\n              REMOTE: t.identifier(\"default\")\n            }), e.loc));\n          });\n          state.exportAll.forEach(function (e) {\n            body.push.apply(body, _toConsumableArray(withLocation(exportAllTemplate({\n              FILE: resolvePath(t.stringLiteral(e.file), state.opts.resolve),\n              REQUIRED: path.scope.generateUidIdentifier(e.file),\n              KEY: path.scope.generateUidIdentifier(\"key\")\n            }), e.loc)));\n          });\n          state.exportNamed.forEach(function (e) {\n            body.push(withLocation(exportTemplate({\n              LOCAL: t.identifier(e.local),\n              REMOTE: t.identifier(e.remote)\n            }), e.loc));\n          });\n\n          if (state.exportDefault.length || state.exportAll.length || state.exportNamed.length) {\n            body.unshift(esModuleExportTemplate());\n\n            if (state.opts.out) {\n              state.opts.out.isESModule = true;\n            }\n          } else if (state.opts.out) {\n            state.opts.out.isESModule = false;\n          }\n        }\n      }\n    }\n  };\n}\n\nmodule.exports = importExportPlugin;","map":{"version":3,"names":["template","require","default","nullthrows","importTemplate","statement","importNamedTemplate","importSideEffectTemplate","exportAllTemplate","statements","exportTemplate","esModuleExportTemplate","resolveTemplate","expression","resolvePath","node","resolve","NODE","withLocation","loc","Array","isArray","map","n","importExportPlugin","t","types","isDeclaration","isVariableDeclaration","visitor","ExportAllDeclaration","path","state","exportAll","push","file","source","value","remove","ExportDefaultDeclaration","declaration","id","scope","generateUidIdentifier","exportDefault","local","name","insertBefore","variableDeclaration","variableDeclarator","ExportNamedDeclaration","exportKind","declarations","forEach","d","type","properties","p","key","exportNamed","remote","elements","e","specifiers","s","exported","buildCodeFrameError","temp","IMPORT","cloneNode","importDefault","FILE","opts","LOCAL","REMOTE","ImportDeclaration","importKind","length","imports","sharedModuleImport","sharedModuleVariableDeclaration","filter","imported","generateUidIdentifierBasedOnNode","callExpression","identifier","importAll","memberExpression","TypeError","Program","enter","exit","body","reverse","unshift","stringLiteral","REQUIRED","KEY","out","isESModule","module","exports"],"sources":["/Users/hozaifa/Documents/Uni App Github/node_modules/@react-native-community/cli-plugin-metro/node_modules/metro-transform-plugins/src/import-export-plugin.js"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *\n * @format\n */\n\"use strict\";\n\n// Type only dependency. This is not a runtime dependency\n// eslint-disable-next-line import/no-extraneous-dependencies\nconst template = require(\"@babel/template\").default;\n\nconst nullthrows = require(\"nullthrows\");\n\n/**\n * Produces a Babel template that transforms an \"import * as x from ...\" or an\n * \"import x from ...\" call into a \"const x = importAll(...)\" call with the\n * corresponding id in it.\n */\nconst importTemplate = template.statement(`\n  var LOCAL = IMPORT(FILE);\n`);\n/**\n * Produces a Babel template that transforms an \"import {x as y} from ...\" into\n * \"const y = require(...).x\" call with the corresponding id in it.\n */\n\nconst importNamedTemplate = template.statement(`\n  var LOCAL = require(FILE).REMOTE;\n`);\n/**\n * Produces a Babel template that transforms an \"import ...\" into\n * \"require(...)\", which is considered a side-effect call.\n */\n\nconst importSideEffectTemplate = template.statement(`\n  require(FILE);\n`);\n/**\n * Produces an \"export all\" template that traverses all exported symbols and\n * re-exposes them.\n */\n\nconst exportAllTemplate = template.statements(`\n  var REQUIRED = require(FILE);\n\n  for (var KEY in REQUIRED) {\n    exports[KEY] = REQUIRED[KEY];\n  }\n`);\n/**\n * Produces a \"named export\" or \"default export\" template to export a single\n * symbol.\n */\n\nconst exportTemplate = template.statement(`\n  exports.REMOTE = LOCAL;\n`);\n/**\n * Flags the exported module as a transpiled ES module. Needs to be kept in 1:1\n * compatibility with Babel.\n */\n\nconst esModuleExportTemplate = template.statement(`\n  Object.defineProperty(exports, '__esModule', {value: true});\n`);\n/**\n * Resolution template in case it is requested.\n */\n\nconst resolveTemplate = template.expression(`\n  require.resolve(NODE)\n`);\n/**\n * Enforces the resolution of a path to a fully-qualified one, if set.\n */\n\nfunction resolvePath(node, resolve) {\n  if (!resolve) {\n    return node;\n  }\n\n  return resolveTemplate({\n    NODE: node,\n  });\n}\n\n// eslint-disable-next-line no-redeclare\nfunction withLocation(node, loc) {\n  if (Array.isArray(node)) {\n    return node.map((n) => withLocation(n, loc));\n  }\n\n  if (!node.loc) {\n    return { ...node, loc };\n  }\n\n  return node;\n}\n\nfunction importExportPlugin({ types: t }) {\n  const { isDeclaration, isVariableDeclaration } = t;\n  return {\n    visitor: {\n      ExportAllDeclaration(path, state) {\n        state.exportAll.push({\n          file: path.node.source.value,\n          loc: path.node.loc,\n        });\n        path.remove();\n      },\n\n      ExportDefaultDeclaration(path, state) {\n        const declaration = path.node.declaration;\n        const id =\n          declaration.id || path.scope.generateUidIdentifier(\"default\"); // $FlowFixMe Flow error uncovered by typing Babel more strictly\n\n        declaration.id = id;\n        const loc = path.node.loc;\n        state.exportDefault.push({\n          local: id.name,\n          loc,\n        });\n\n        if (isDeclaration(declaration)) {\n          path.insertBefore(withLocation(declaration, loc));\n        } else {\n          path.insertBefore(\n            withLocation(\n              t.variableDeclaration(\"var\", [\n                t.variableDeclarator(id, declaration),\n              ]),\n              loc\n            )\n          );\n        }\n\n        path.remove();\n      },\n\n      ExportNamedDeclaration(path, state) {\n        if (path.node.exportKind && path.node.exportKind !== \"value\") {\n          return;\n        }\n\n        const declaration = path.node.declaration;\n        const loc = path.node.loc;\n\n        if (declaration) {\n          if (isVariableDeclaration(declaration)) {\n            declaration.declarations.forEach((d) => {\n              switch (d.id.type) {\n                case \"ObjectPattern\":\n                  {\n                    const properties = d.id.properties;\n                    properties.forEach((p) => {\n                      // $FlowFixMe Flow error uncovered by typing Babel more strictly\n                      const name = p.key.name; // $FlowFixMe[incompatible-call]\n\n                      state.exportNamed.push({\n                        local: name,\n                        remote: name,\n                        loc,\n                      });\n                    });\n                  }\n                  break;\n\n                case \"ArrayPattern\":\n                  {\n                    const elements = d.id.elements;\n                    elements.forEach((e) => {\n                      // $FlowFixMe Flow error uncovered by typing Babel more strictly\n                      const name = e.name; // $FlowFixMe[incompatible-call]\n\n                      state.exportNamed.push({\n                        local: name,\n                        remote: name,\n                        loc,\n                      });\n                    });\n                  }\n                  break;\n\n                default:\n                  {\n                    // $FlowFixMe Flow error uncovered by typing Babel more strictly\n                    const name = d.id.name; // $FlowFixMe[incompatible-call]\n\n                    state.exportNamed.push({\n                      local: name,\n                      remote: name,\n                      loc,\n                    });\n                  }\n                  break;\n              }\n            });\n          } else {\n            const id = declaration.id || path.scope.generateUidIdentifier(); // $FlowFixMe Flow error uncovered by typing Babel more strictly\n\n            const name = id.name; // $FlowFixMe Flow error uncovered by typing Babel more strictly\n\n            declaration.id = id; // $FlowFixMe[incompatible-call]\n\n            state.exportNamed.push({\n              local: name,\n              remote: name,\n              loc,\n            });\n          }\n\n          path.insertBefore(declaration);\n        }\n\n        const specifiers = path.node.specifiers;\n\n        if (specifiers) {\n          specifiers.forEach((s) => {\n            // $FlowFixMe Flow error uncovered by typing Babel more strictly\n            const local = s.local;\n            const remote = s.exported;\n\n            if (remote.type === \"StringLiteral\") {\n              // https://babeljs.io/docs/en/babel-plugin-syntax-module-string-names\n              throw path.buildCodeFrameError(\n                \"Module string names are not supported\"\n              );\n            }\n\n            if (path.node.source) {\n              // $FlowFixMe[incompatible-use]\n              const temp = path.scope.generateUidIdentifier(local.name); // $FlowFixMe[incompatible-type]\n\n              if (local.name === \"default\") {\n                path.insertBefore(\n                  withLocation(\n                    importTemplate({\n                      IMPORT: t.cloneNode(state.importDefault),\n                      FILE: resolvePath(\n                        t.cloneNode(nullthrows(path.node.source)),\n                        state.opts.resolve\n                      ),\n                      LOCAL: temp,\n                    }),\n                    loc\n                  )\n                );\n                state.exportNamed.push({\n                  local: temp.name,\n                  remote: remote.name,\n                  loc,\n                });\n              } else if (remote.name === \"default\") {\n                path.insertBefore(\n                  withLocation(\n                    importNamedTemplate({\n                      FILE: resolvePath(\n                        t.cloneNode(nullthrows(path.node.source)),\n                        state.opts.resolve\n                      ),\n                      LOCAL: temp,\n                      REMOTE: local,\n                    }),\n                    loc\n                  )\n                );\n                state.exportDefault.push({\n                  local: temp.name,\n                  loc,\n                });\n              } else {\n                path.insertBefore(\n                  withLocation(\n                    importNamedTemplate({\n                      FILE: resolvePath(\n                        t.cloneNode(nullthrows(path.node.source)),\n                        state.opts.resolve\n                      ),\n                      LOCAL: temp,\n                      REMOTE: local,\n                    }),\n                    loc\n                  )\n                );\n                state.exportNamed.push({\n                  local: temp.name,\n                  remote: remote.name,\n                  loc,\n                });\n              }\n            } else {\n              if (remote.name === \"default\") {\n                // $FlowFixMe[incompatible-use]\n                state.exportDefault.push({\n                  local: local.name,\n                  loc,\n                });\n              } else {\n                state.exportNamed.push({\n                  // $FlowFixMe[incompatible-use]\n                  local: local.name,\n                  remote: remote.name,\n                  loc,\n                });\n              }\n            }\n          });\n        }\n\n        path.remove();\n      },\n\n      ImportDeclaration(path, state) {\n        if (path.node.importKind && path.node.importKind !== \"value\") {\n          return;\n        }\n\n        const file = path.node.source;\n        const specifiers = path.node.specifiers;\n        const loc = path.node.loc;\n\n        if (!specifiers.length) {\n          state.imports.push({\n            node: withLocation(\n              importSideEffectTemplate({\n                FILE: resolvePath(t.cloneNode(file), state.opts.resolve),\n              }),\n              loc\n            ),\n          });\n        } else {\n          let sharedModuleImport;\n          let sharedModuleVariableDeclaration = null;\n\n          if (\n            specifiers.filter(\n              (s) =>\n                s.type === \"ImportSpecifier\" &&\n                (s.imported.type === \"StringLiteral\" ||\n                  s.imported.name !== \"default\")\n            ).length > 1\n          ) {\n            sharedModuleImport =\n              path.scope.generateUidIdentifierBasedOnNode(file);\n            sharedModuleVariableDeclaration = withLocation(\n              t.variableDeclaration(\"var\", [\n                t.variableDeclarator(\n                  t.cloneNode(sharedModuleImport),\n                  t.callExpression(t.identifier(\"require\"), [\n                    resolvePath(t.cloneNode(file), state.opts.resolve),\n                  ])\n                ),\n              ]),\n              loc\n            );\n            state.imports.push({\n              node: sharedModuleVariableDeclaration,\n            });\n          }\n\n          specifiers.forEach((s) => {\n            // $FlowFixMe Flow error uncovered by typing Babel more strictly\n            const imported = s.imported;\n            const local = s.local;\n\n            switch (s.type) {\n              case \"ImportNamespaceSpecifier\":\n                state.imports.push({\n                  node: withLocation(\n                    importTemplate({\n                      IMPORT: t.cloneNode(state.importAll),\n                      FILE: resolvePath(t.cloneNode(file), state.opts.resolve),\n                      LOCAL: t.cloneNode(local),\n                    }),\n                    loc\n                  ),\n                });\n                break;\n\n              case \"ImportDefaultSpecifier\":\n                state.imports.push({\n                  node: withLocation(\n                    importTemplate({\n                      IMPORT: t.cloneNode(state.importDefault),\n                      FILE: resolvePath(t.cloneNode(file), state.opts.resolve),\n                      LOCAL: t.cloneNode(local),\n                    }),\n                    loc\n                  ),\n                });\n                break;\n\n              case \"ImportSpecifier\":\n                // $FlowFixMe[incompatible-type]\n                if (imported.name === \"default\") {\n                  state.imports.push({\n                    node: withLocation(\n                      importTemplate({\n                        IMPORT: t.cloneNode(state.importDefault),\n                        FILE: resolvePath(\n                          t.cloneNode(file),\n                          state.opts.resolve\n                        ),\n                        LOCAL: t.cloneNode(local),\n                      }),\n                      loc\n                    ),\n                  });\n                } else if (sharedModuleVariableDeclaration != null) {\n                  sharedModuleVariableDeclaration.declarations.push(\n                    withLocation(\n                      t.variableDeclarator(\n                        t.cloneNode(local),\n                        t.memberExpression(\n                          t.cloneNode(sharedModuleImport), // $FlowFixMe[incompatible-call]\n                          t.cloneNode(imported)\n                        )\n                      ),\n                      loc\n                    )\n                  );\n                } else {\n                  state.imports.push({\n                    node: withLocation(\n                      importNamedTemplate({\n                        FILE: resolvePath(\n                          t.cloneNode(file),\n                          state.opts.resolve\n                        ),\n                        LOCAL: t.cloneNode(local),\n                        REMOTE: t.cloneNode(imported),\n                      }),\n                      loc\n                    ),\n                  });\n                }\n\n                break;\n\n              default:\n                throw new TypeError(\"Unknown import type: \" + s.type);\n            }\n          });\n        }\n\n        path.remove();\n      },\n\n      Program: {\n        enter(path, state) {\n          state.exportAll = [];\n          state.exportDefault = [];\n          state.exportNamed = [];\n          state.imports = [];\n          state.importAll = t.identifier(state.opts.importAll);\n          state.importDefault = t.identifier(state.opts.importDefault);\n        },\n\n        exit(path, state) {\n          const body = path.node.body; // state.imports = [node1, node2, node3, ...nodeN]\n\n          state.imports.reverse().forEach((e) => {\n            // import nodes are added to the top of the program body\n            body.unshift(e.node);\n          });\n          state.exportDefault.forEach((e) => {\n            body.push(\n              withLocation(\n                exportTemplate({\n                  LOCAL: t.identifier(e.local),\n                  REMOTE: t.identifier(\"default\"),\n                }),\n                e.loc\n              )\n            );\n          });\n          state.exportAll.forEach((e) => {\n            body.push(\n              ...withLocation(\n                exportAllTemplate({\n                  FILE: resolvePath(\n                    t.stringLiteral(e.file),\n                    state.opts.resolve\n                  ),\n                  REQUIRED: path.scope.generateUidIdentifier(e.file),\n                  KEY: path.scope.generateUidIdentifier(\"key\"),\n                }),\n                e.loc\n              )\n            );\n          });\n          state.exportNamed.forEach((e) => {\n            body.push(\n              withLocation(\n                exportTemplate({\n                  LOCAL: t.identifier(e.local),\n                  REMOTE: t.identifier(e.remote),\n                }),\n                e.loc\n              )\n            );\n          });\n\n          if (\n            state.exportDefault.length ||\n            state.exportAll.length ||\n            state.exportNamed.length\n          ) {\n            body.unshift(esModuleExportTemplate());\n\n            if (state.opts.out) {\n              state.opts.out.isESModule = true;\n            }\n          } else if (state.opts.out) {\n            state.opts.out.isESModule = false;\n          }\n        },\n      },\n    },\n  };\n}\n\nmodule.exports = importExportPlugin;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}