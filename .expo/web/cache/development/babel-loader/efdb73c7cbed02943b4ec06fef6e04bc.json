{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"@babel/runtime/regenerator\");\n\nfunction _createForOfIteratorHelperLoose(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (it) return (it = it.call(o)).next.bind(it); if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nfunction _child_process() {\n  var data = require(\"child_process\");\n\n  _child_process = function _child_process() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _os() {\n  var data = _interopRequireDefault(require(\"os\"));\n\n  _os = function _os() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _path() {\n  var data = _interopRequireDefault(require(\"path\"));\n\n  _path = function _path() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _cliTools() {\n  var data = require(\"@react-native-community/cli-tools\");\n\n  _cliTools = function _cliTools() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction findAvailableDevice(devices) {\n  for (var _i = 0, _Object$keys = Object.keys(devices); _i < _Object$keys.length; _i++) {\n    var key = _Object$keys[_i];\n\n    for (var _iterator = _createForOfIteratorHelperLoose(devices[key]), _step; !(_step = _iterator()).done;) {\n      var device = _step.value;\n\n      if (device.availability === '(available)' && device.state === 'Booted') {\n        return device;\n      }\n    }\n  }\n\n  return null;\n}\n\nfunction logIOS() {\n  var rawDevices, _JSON$parse, devices, device;\n\n  return _regeneratorRuntime.async(function logIOS$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          rawDevices = (0, _child_process().execFileSync)('xcrun', ['simctl', 'list', 'devices', '--json'], {\n            encoding: 'utf8'\n          });\n          _JSON$parse = JSON.parse(rawDevices), devices = _JSON$parse.devices;\n          device = findAvailableDevice(devices);\n\n          if (!(device === null)) {\n            _context.next = 6;\n            break;\n          }\n\n          _cliTools().logger.error('No active iOS device found');\n\n          return _context.abrupt(\"return\");\n\n        case 6:\n          tailDeviceLogs(device.udid);\n\n        case 7:\n        case \"end\":\n          return _context.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\n\nfunction tailDeviceLogs(udid) {\n  var logDir = _path().default.join(_os().default.homedir(), 'Library', 'Logs', 'CoreSimulator', udid, 'asl');\n\n  var log = (0, _child_process().spawnSync)('syslog', ['-w', '-F', 'std', '-d', logDir], {\n    stdio: 'inherit'\n  });\n\n  if (log.error !== null) {\n    throw log.error;\n  }\n}\n\nvar _default = {\n  name: 'log-ios',\n  description: 'starts iOS device syslog tail',\n  func: logIOS\n};\nexports.default = _default;","map":{"version":3,"sources":["../../../src/commands/logIOS/index.ts"],"names":["key","Object","devices","device","rawDevices","encoding","JSON","findAvailableDevice","logger","tailDeviceLogs","logDir","path","os","log","stdio","name","description","func","logIOS"],"mappings":";;;;;;;;;;;;;;;AAQA,SAAA,cAAA,GAAA;EAAA,IAAA,IAAA,GAAA,OAAA,CAAA,eAAA,CAAA;;EAAA,cAAA,GAAA,0BAAA;IAAA,OAAA,IAAA;EAAA,CAAA;;EAAA,OAAA,IAAA;AAAA;;AACA,SAAA,GAAA,GAAA;EAAA,IAAA,IAAA,GAAA,sBAAA,CAAA,OAAA,CAAA,IAAA,CAAA,CAAA;;EAAA,GAAA,GAAA,eAAA;IAAA,OAAA,IAAA;EAAA,CAAA;;EAAA,OAAA,IAAA;AAAA;;AACA,SAAA,KAAA,GAAA;EAAA,IAAA,IAAA,GAAA,sBAAA,CAAA,OAAA,CAAA,MAAA,CAAA,CAAA;;EAAA,KAAA,GAAA,iBAAA;IAAA,OAAA,IAAA;EAAA,CAAA;;EAAA,OAAA,IAAA;AAAA;;AACA,SAAA,SAAA,GAAA;EAAA,IAAA,IAAA,GAAA,OAAA,CAAA,mCAAA,CAAA;;EAAA,SAAA,GAAA,qBAAA;IAAA,OAAA,IAAA;EAAA,CAAA;;EAAA,OAAA,IAAA;AAAA;;;;;;;;AAGA,SAAA,mBAAA,CAAA,OAAA,EAAwE;EACtE,gCAAkBC,MAAM,CAANA,IAAAA,CAAlB,OAAkBA,CAAlB,kCAAwC;IAAnC,IAAMD,GAAX,mBAAK;;IACH,qDAAqBE,OAAO,CAA5B,GAA4B,CAA5B,wCAAmC;MAAA,IAAnC,MAAmC;;MACjC,IAAIC,MAAM,CAANA,YAAAA,KAAAA,aAAAA,IAAyCA,MAAM,CAANA,KAAAA,KAA7C,QAAA,EAAwE;QACtE,OAAA,MAAA;MACD;IACF;EACF;;EACD,OAAA,IAAA;AACD;;AAKD,SAAA,MAAA;EAAA;;EAAA;IAAA;MAAA;QAAA;UACQC,UADR,GACqB,CAAA,GAAA,cAAA,GAAA,YAAA,EAAA,OAAA,EAEjB,CAAA,QAAA,EAAA,MAAA,EAAA,SAAA,EAFiB,QAEjB,CAFiB,EAGjB;YAACC,QAAQ,EAAE;UAAX,CAHiB,CADrB;UAAA,cAOoBC,IAAI,CAAJA,KAAAA,CAAlB,UAAkBA,CAPpB,EAOSJ,OAPT,eAOSA,OAPT;UAWQC,MAXR,GAWiBI,mBAAmB,CAAlC,OAAkC,CAXpC;;UAAA,MAYMJ,MAAM,KAAV,IAZF;YAAA;YAAA;UAAA;;UAaIK,SAAAA,GAAAA,MAAAA,CAAAA,KAAAA,CAAAA,4BAAAA;;UAbJ;;QAAA;UAiBEC,cAAc,CAACN,MAAM,CAArBM,IAAc,CAAdA;;QAjBF;QAAA;UAAA;MAAA;IAAA;EAAA;AAAA;;AAoBA,SAAA,cAAA,CAAA,IAAA,EAAsC;EACpC,IAAMC,MAAM,GAAGC,KAAAA,GAAAA,OAAAA,CAAAA,IAAAA,CACbC,GAAAA,GAAAA,OAAAA,CADaD,OACbC,EADaD,EAAAA,SAAAA,EAAAA,MAAAA,EAAAA,eAAAA,EAAAA,IAAAA,EAAf,KAAeA,CAAf;;EASA,IAAME,GAAG,GAAG,CAAA,GAAA,cAAA,GAAA,SAAA,EAAA,QAAA,EAAoB,CAAA,IAAA,EAAA,IAAA,EAAA,KAAA,EAAA,IAAA,EAApB,MAAoB,CAApB,EAAuD;IACjEC,KAAK,EAAE;EAD0D,CAAvD,CAAZ;;EAIA,IAAID,GAAG,CAAHA,KAAAA,KAAJ,IAAA,EAAwB;IACtB,MAAMA,GAAG,CAAT,KAAA;EACD;AACF;;eAEc;EACbE,IAAI,EADS,SAAA;EAEbC,WAAW,EAFE,+BAAA;EAGbC,IAAI,EAAEC;AAHO,C","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport {execFileSync, spawnSync} from 'child_process';\nimport os from 'os';\nimport path from 'path';\nimport {logger} from '@react-native-community/cli-tools';\nimport {Device} from '../../types';\n\nfunction findAvailableDevice(devices: {[index: string]: Array<Device>}) {\n  for (const key of Object.keys(devices)) {\n    for (const device of devices[key]) {\n      if (device.availability === '(available)' && device.state === 'Booted') {\n        return device;\n      }\n    }\n  }\n  return null;\n}\n\n/**\n * Starts iOS device syslog tail\n */\nasync function logIOS() {\n  const rawDevices = execFileSync(\n    'xcrun',\n    ['simctl', 'list', 'devices', '--json'],\n    {encoding: 'utf8'},\n  );\n\n  const {devices} = JSON.parse(rawDevices) as {\n    devices: {[index: string]: Array<Device>};\n  };\n\n  const device = findAvailableDevice(devices);\n  if (device === null) {\n    logger.error('No active iOS device found');\n    return;\n  }\n\n  tailDeviceLogs(device.udid);\n}\n\nfunction tailDeviceLogs(udid: string) {\n  const logDir = path.join(\n    os.homedir(),\n    'Library',\n    'Logs',\n    'CoreSimulator',\n    udid,\n    'asl',\n  );\n\n  const log = spawnSync('syslog', ['-w', '-F', 'std', '-d', logDir], {\n    stdio: 'inherit',\n  });\n\n  if (log.error !== null) {\n    throw log.error;\n  }\n}\n\nexport default {\n  name: 'log-ios',\n  description: 'starts iOS device syslog tail',\n  func: logIOS,\n};\n"]},"metadata":{},"sourceType":"script"}