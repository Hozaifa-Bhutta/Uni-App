{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"@babel/runtime/regenerator\");\n\nvar _require = require(\"./BundleBuilder\"),\n    BundleBuilder = _require.BundleBuilder,\n    createIndexMap = _require.createIndexMap;\n\nvar composeSourceMaps = require(\"./composeSourceMaps\");\n\nvar Consumer = require(\"./Consumer\");\n\nvar normalizeSourcePath = require(\"./Consumer/normalizeSourcePath\");\n\nvar _require2 = require(\"./generateFunctionMap\"),\n    generateFunctionMap = _require2.generateFunctionMap;\n\nvar Generator = require(\"./Generator\");\n\nvar SourceMap = require(\"source-map\");\n\nfunction fromRawMappingsImpl(isBlocking, onDone, modules, offsetLines) {\n  var modulesToProcess = modules.slice();\n  var generator = new Generator();\n  var carryOver = offsetLines;\n\n  function processNextModule() {\n    if (modulesToProcess.length === 0) {\n      return true;\n    }\n\n    var mod = modulesToProcess.shift();\n    var code = mod.code,\n        map = mod.map;\n\n    if (Array.isArray(map)) {\n      addMappingsForFile(generator, map, mod, carryOver);\n    } else if (map != null) {\n      throw new Error(\"Unexpected module with full source map found: \" + mod.path);\n    }\n\n    carryOver = carryOver + countLines(code);\n    return false;\n  }\n\n  function workLoop() {\n    var time = process.hrtime();\n\n    while (true) {\n      var isDone = processNextModule();\n\n      if (isDone) {\n        onDone(generator);\n        break;\n      }\n\n      if (!isBlocking) {\n        var diff = process.hrtime(time);\n        var NS_IN_MS = 1000000;\n\n        if (diff[1] > 50 * NS_IN_MS) {\n          setImmediate(workLoop);\n          break;\n        }\n      }\n    }\n  }\n\n  workLoop();\n}\n\nfunction fromRawMappings(modules) {\n  var offsetLines = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  var generator;\n  fromRawMappingsImpl(true, function (g) {\n    generator = g;\n  }, modules, offsetLines);\n\n  if (generator == null) {\n    throw new Error(\"Expected fromRawMappingsImpl() to finish synchronously.\");\n  }\n\n  return generator;\n}\n\nfunction fromRawMappingsNonBlocking(modules) {\n  var offsetLines,\n      _args = arguments;\n  return _regeneratorRuntime.async(function fromRawMappingsNonBlocking$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          offsetLines = _args.length > 1 && _args[1] !== undefined ? _args[1] : 0;\n          return _context.abrupt(\"return\", new Promise(function (resolve) {\n            fromRawMappingsImpl(false, resolve, modules, offsetLines);\n          }));\n\n        case 2:\n        case \"end\":\n          return _context.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\n\nfunction toBabelSegments(sourceMap) {\n  var rawMappings = [];\n  new SourceMap.SourceMapConsumer(sourceMap).eachMapping(function (map) {\n    rawMappings.push({\n      generated: {\n        line: map.generatedLine,\n        column: map.generatedColumn\n      },\n      original: {\n        line: map.originalLine,\n        column: map.originalColumn\n      },\n      source: map.source,\n      name: map.name\n    });\n  });\n  return rawMappings;\n}\n\nfunction toSegmentTuple(mapping) {\n  var _mapping$generated = mapping.generated,\n      column = _mapping$generated.column,\n      line = _mapping$generated.line;\n  var name = mapping.name,\n      original = mapping.original;\n\n  if (original == null) {\n    return [line, column];\n  }\n\n  if (typeof name !== \"string\") {\n    return [line, column, original.line, original.column];\n  }\n\n  return [line, column, original.line, original.column, name];\n}\n\nfunction addMappingsForFile(generator, mappings, module, carryOver) {\n  generator.startFile(module.path, module.source, module.functionMap);\n\n  for (var i = 0, n = mappings.length; i < n; ++i) {\n    addMapping(generator, mappings[i], carryOver);\n  }\n\n  generator.endFile();\n}\n\nfunction addMapping(generator, mapping, carryOver) {\n  var n = mapping.length;\n  var line = mapping[0] + carryOver;\n  var column = mapping[1];\n\n  if (n === 2) {\n    generator.addSimpleMapping(line, column);\n  } else if (n === 4) {\n    var sourceMap = mapping;\n    generator.addSourceMapping(line, column, sourceMap[2], sourceMap[3]);\n  } else if (n === 5) {\n    var _sourceMap = mapping;\n    generator.addNamedSourceMapping(line, column, _sourceMap[2], _sourceMap[3], _sourceMap[4]);\n  } else {\n    throw new Error(\"Invalid mapping: [\" + mapping.join(\", \") + \"]\");\n  }\n}\n\nvar newline = /\\r\\n?|\\n|\\u2028|\\u2029/g;\n\nvar countLines = function countLines(string) {\n  return (string.match(newline) || []).length + 1;\n};\n\nmodule.exports = {\n  BundleBuilder: BundleBuilder,\n  composeSourceMaps: composeSourceMaps,\n  Consumer: Consumer,\n  createIndexMap: createIndexMap,\n  generateFunctionMap: generateFunctionMap,\n  fromRawMappings: fromRawMappings,\n  fromRawMappingsNonBlocking: fromRawMappingsNonBlocking,\n  normalizeSourcePath: normalizeSourcePath,\n  toBabelSegments: toBabelSegments,\n  toSegmentTuple: toSegmentTuple\n};","map":{"version":3,"names":["require","BundleBuilder","createIndexMap","composeSourceMaps","Consumer","normalizeSourcePath","generateFunctionMap","Generator","SourceMap","fromRawMappingsImpl","isBlocking","onDone","modules","offsetLines","modulesToProcess","slice","generator","carryOver","processNextModule","length","mod","shift","code","map","Array","isArray","addMappingsForFile","Error","path","countLines","workLoop","time","process","hrtime","isDone","diff","NS_IN_MS","setImmediate","fromRawMappings","g","fromRawMappingsNonBlocking","Promise","resolve","toBabelSegments","sourceMap","rawMappings","SourceMapConsumer","eachMapping","push","generated","line","generatedLine","column","generatedColumn","original","originalLine","originalColumn","source","name","toSegmentTuple","mapping","mappings","module","startFile","functionMap","i","n","addMapping","endFile","addSimpleMapping","addSourceMapping","addNamedSourceMapping","join","newline","string","match","exports"],"sources":["/Users/hozaifa/Documents/Uni App Github/node_modules/@react-native-community/cli-plugin-metro/node_modules/metro-source-map/src/source-map.js"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *\n * @format\n */\n\"use strict\";\n\nconst { BundleBuilder, createIndexMap } = require(\"./BundleBuilder\");\n\nconst composeSourceMaps = require(\"./composeSourceMaps\");\n\nconst Consumer = require(\"./Consumer\"); // We need to export this for `metro-symbolicate`\n\nconst normalizeSourcePath = require(\"./Consumer/normalizeSourcePath\");\n\nconst { generateFunctionMap } = require(\"./generateFunctionMap\");\n\nconst Generator = require(\"./Generator\");\n\nconst SourceMap = require(\"source-map\");\n\nfunction fromRawMappingsImpl(isBlocking, onDone, modules, offsetLines) {\n  const modulesToProcess = modules.slice();\n  const generator = new Generator();\n  let carryOver = offsetLines;\n\n  function processNextModule() {\n    if (modulesToProcess.length === 0) {\n      return true;\n    }\n\n    const mod = modulesToProcess.shift();\n    const { code, map } = mod;\n\n    if (Array.isArray(map)) {\n      addMappingsForFile(generator, map, mod, carryOver);\n    } else if (map != null) {\n      throw new Error(\n        `Unexpected module with full source map found: ${mod.path}`\n      );\n    }\n\n    carryOver = carryOver + countLines(code);\n    return false;\n  }\n\n  function workLoop() {\n    const time = process.hrtime();\n\n    while (true) {\n      const isDone = processNextModule();\n\n      if (isDone) {\n        onDone(generator);\n        break;\n      }\n\n      if (!isBlocking) {\n        // Keep the loop running but try to avoid blocking\n        // for too long because this is not in a worker yet.\n        const diff = process.hrtime(time);\n        const NS_IN_MS = 1000000;\n\n        if (diff[1] > 50 * NS_IN_MS) {\n          // We've blocked for more than 50ms.\n          // This code currently runs on the main thread,\n          // so let's give Metro an opportunity to handle requests.\n          setImmediate(workLoop);\n          break;\n        }\n      }\n    }\n  }\n\n  workLoop();\n}\n/**\n * Creates a source map from modules with \"raw mappings\", i.e. an array of\n * tuples with either 2, 4, or 5 elements:\n * generated line, generated column, source line, source line, symbol name.\n * Accepts an `offsetLines` argument in case modules' code is to be offset in\n * the resulting bundle, e.g. by some prefix code.\n */\n\nfunction fromRawMappings(modules, offsetLines = 0) {\n  let generator;\n  fromRawMappingsImpl(\n    true,\n    (g) => {\n      generator = g;\n    },\n    modules,\n    offsetLines\n  );\n\n  if (generator == null) {\n    throw new Error(\"Expected fromRawMappingsImpl() to finish synchronously.\");\n  }\n\n  return generator;\n}\n\nasync function fromRawMappingsNonBlocking(modules, offsetLines = 0) {\n  return new Promise((resolve) => {\n    fromRawMappingsImpl(false, resolve, modules, offsetLines);\n  });\n}\n/**\n * Transforms a standard source map object into a Raw Mappings object, to be\n * used across the bundler.\n */\n\nfunction toBabelSegments(sourceMap) {\n  const rawMappings = [];\n  new SourceMap.SourceMapConsumer(sourceMap).eachMapping((map) => {\n    rawMappings.push({\n      generated: {\n        line: map.generatedLine,\n        column: map.generatedColumn,\n      },\n      original: {\n        line: map.originalLine,\n        column: map.originalColumn,\n      },\n      source: map.source,\n      name: map.name,\n    });\n  });\n  return rawMappings;\n}\n\nfunction toSegmentTuple(mapping) {\n  const { column, line } = mapping.generated;\n  const { name, original } = mapping;\n\n  if (original == null) {\n    return [line, column];\n  }\n\n  if (typeof name !== \"string\") {\n    return [line, column, original.line, original.column];\n  }\n\n  return [line, column, original.line, original.column, name];\n}\n\nfunction addMappingsForFile(generator, mappings, module, carryOver) {\n  generator.startFile(module.path, module.source, module.functionMap);\n\n  for (let i = 0, n = mappings.length; i < n; ++i) {\n    addMapping(generator, mappings[i], carryOver);\n  }\n\n  generator.endFile();\n}\n\nfunction addMapping(generator, mapping, carryOver) {\n  const n = mapping.length;\n  const line = mapping[0] + carryOver; // lines start at 1, columns start at 0\n\n  const column = mapping[1];\n\n  if (n === 2) {\n    generator.addSimpleMapping(line, column);\n  } else if (n === 4) {\n    const sourceMap = mapping;\n    generator.addSourceMapping(line, column, sourceMap[2], sourceMap[3]);\n  } else if (n === 5) {\n    const sourceMap = mapping;\n    generator.addNamedSourceMapping(\n      line,\n      column,\n      sourceMap[2],\n      sourceMap[3],\n      sourceMap[4]\n    );\n  } else {\n    throw new Error(`Invalid mapping: [${mapping.join(\", \")}]`);\n  }\n}\n\nconst newline = /\\r\\n?|\\n|\\u2028|\\u2029/g;\n\nconst countLines = (string) => (string.match(newline) || []).length + 1;\n\nmodule.exports = {\n  BundleBuilder,\n  composeSourceMaps,\n  Consumer,\n  createIndexMap,\n  generateFunctionMap,\n  fromRawMappings,\n  fromRawMappingsNonBlocking,\n  normalizeSourcePath,\n  toBabelSegments,\n  toSegmentTuple,\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}