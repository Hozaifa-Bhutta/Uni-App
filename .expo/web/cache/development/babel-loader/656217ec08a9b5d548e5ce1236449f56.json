{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"@babel/runtime/regenerator\");\n\nvar _classCallCheck = require(\"@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"@babel/runtime/helpers/createClass\");\n\nvar _get = require(\"@babel/runtime/helpers/get\");\n\nvar _inherits = require(\"@babel/runtime/helpers/inherits\");\n\nvar _possibleConstructorReturn = require(\"@babel/runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"@babel/runtime/helpers/getPrototypeOf\");\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nvar HttpStore = require(\"./HttpStore\");\n\nvar _require = require(\"metro-core\"),\n    Logger = _require.Logger;\n\nvar HttpGetStore = function (_HttpStore) {\n  _inherits(HttpGetStore, _HttpStore);\n\n  var _super = _createSuper(HttpGetStore);\n\n  function HttpGetStore(options) {\n    var _this;\n\n    _classCallCheck(this, HttpGetStore);\n\n    _this = _super.call(this, options);\n    _this._warned = false;\n    return _this;\n  }\n\n  _createClass(HttpGetStore, [{\n    key: \"get\",\n    value: function get(key) {\n      return _regeneratorRuntime.async(function get$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              _context.prev = 0;\n              _context.next = 3;\n              return _regeneratorRuntime.awrap(_get(_getPrototypeOf(HttpGetStore.prototype), \"get\", this).call(this, key));\n\n            case 3:\n              return _context.abrupt(\"return\", _context.sent);\n\n            case 6:\n              _context.prev = 6;\n              _context.t0 = _context[\"catch\"](0);\n\n              if (!(!(_context.t0 instanceof HttpStore.HttpError) && !(_context.t0 instanceof HttpStore.NetworkError))) {\n                _context.next = 10;\n                break;\n              }\n\n              throw _context.t0;\n\n            case 10:\n              this._warn(_context.t0);\n\n              return _context.abrupt(\"return\", null);\n\n            case 12:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, null, this, [[0, 6]], Promise);\n    }\n  }, {\n    key: \"set\",\n    value: function set() {\n      return Promise.resolve(undefined);\n    }\n  }, {\n    key: \"_warn\",\n    value: function _warn(err) {\n      if (!this._warned) {\n        process.emitWarning([\"Could not connect to the HTTP cache.\", \"Original error: \" + err.message].join(\" \"));\n        Logger.createEntry(\"CACHE_ERROR: \" + err.message + \" (\" + err.code + \")\");\n        this._warned = true;\n      }\n    }\n  }]);\n\n  return HttpGetStore;\n}(HttpStore);\n\nmodule.exports = HttpGetStore;","map":{"version":3,"names":["HttpStore","require","Logger","HttpGetStore","options","_warned","key","HttpError","NetworkError","_warn","Promise","resolve","undefined","err","process","emitWarning","message","join","createEntry","code","module","exports"],"sources":["/Users/hozaifa/Documents/Uni App Github/node_modules/@react-native-community/cli-plugin-metro/node_modules/metro-cache/src/stores/HttpGetStore.js"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @format\n *\n */\n\"use strict\";\n\nconst HttpStore = require(\"./HttpStore\");\n\nconst { Logger } = require(\"metro-core\");\n\nclass HttpGetStore extends HttpStore {\n  constructor(options) {\n    super(options);\n    this._warned = false;\n  }\n\n  async get(key) {\n    try {\n      return await super.get(key);\n    } catch (err) {\n      if (\n        !(err instanceof HttpStore.HttpError) &&\n        !(err instanceof HttpStore.NetworkError)\n      ) {\n        throw err;\n      }\n\n      this._warn(err);\n\n      return null;\n    }\n  }\n\n  set() {\n    return Promise.resolve(undefined);\n  }\n\n  _warn(err) {\n    if (!this._warned) {\n      process.emitWarning(\n        [\n          \"Could not connect to the HTTP cache.\",\n          \"Original error: \" + err.message,\n        ].join(\" \")\n      );\n      Logger.createEntry(`CACHE_ERROR: ${err.message} (${err.code})`);\n      this._warned = true;\n    }\n  }\n}\n\nmodule.exports = HttpGetStore;\n"],"mappings":"AASA;;;;;;;;;;;;;;;;;;;;AAEA,IAAMA,SAAS,GAAGC,OAAO,eAAzB;;AAEA,eAAmBA,OAAO,CAAC,YAAD,CAA1B;AAAA,IAAQC,MAAR,YAAQA,MAAR;;IAEMC,Y;;;;;EACJ,sBAAYC,OAAZ,EAAqB;IAAA;;IAAA;;IACnB,0BAAMA,OAAN;IACA,MAAKC,OAAL,GAAe,KAAf;IAFmB;EAGpB;;;;WAED,aAAUC,GAAV;MAAA;QAAA;UAAA;YAAA;cAAA;cAAA;cAAA,uGAE2BA,GAF3B;;YAAA;cAAA;;YAAA;cAAA;cAAA;;cAAA,MAKM,EAAE,uBAAeN,SAAS,CAACO,SAA3B,KACA,EAAE,uBAAeP,SAAS,CAACQ,YAA3B,CANN;gBAAA;gBAAA;cAAA;;cAAA;;YAAA;cAWI,KAAKC,KAAL;;cAXJ,iCAaW,IAbX;;YAAA;YAAA;cAAA;UAAA;QAAA;MAAA;IAAA;;;WAiBA,eAAM;MACJ,OAAOC,OAAO,CAACC,OAAR,CAAgBC,SAAhB,CAAP;IACD;;;WAED,eAAMC,GAAN,EAAW;MACT,IAAI,CAAC,KAAKR,OAAV,EAAmB;QACjBS,OAAO,CAACC,WAAR,CACE,CACE,sCADF,EAEE,qBAAqBF,GAAG,CAACG,OAF3B,EAGEC,IAHF,CAGO,GAHP,CADF;QAMAf,MAAM,CAACgB,WAAP,mBAAmCL,GAAG,CAACG,OAAvC,UAAmDH,GAAG,CAACM,IAAvD;QACA,KAAKd,OAAL,GAAe,IAAf;MACD;IACF;;;;EAtCwBL,S;;AAyC3BoB,MAAM,CAACC,OAAP,GAAiBlB,YAAjB"},"metadata":{},"sourceType":"script"}