{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"@babel/runtime/regenerator\");\n\nvar _defineProperty = require(\"@babel/runtime/helpers/defineProperty\");\n\nfunction _createForOfIteratorHelperLoose(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (it) return (it = it.call(o)).next.bind(it); if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = _default;\nexports.AUTOMATIC_FIX_LEVELS = void 0;\n\nfunction _chalk() {\n  var data = _interopRequireDefault(require(\"chalk\"));\n\n  _chalk = function _chalk() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _ora() {\n  var data = _interopRequireDefault(require(\"ora\"));\n\n  _ora = function _ora() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _cliTools() {\n  var data = require(\"@react-native-community/cli-tools\");\n\n  _cliTools = function _cliTools() {\n    return data;\n  };\n\n  return data;\n}\n\nvar _healthchecks = require(\"./healthchecks\");\n\nvar _common = require(\"./healthchecks/common\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nvar AUTOMATIC_FIX_LEVELS;\nexports.AUTOMATIC_FIX_LEVELS = AUTOMATIC_FIX_LEVELS;\n\n(function (AUTOMATIC_FIX_LEVELS) {\n  AUTOMATIC_FIX_LEVELS[\"ALL_ISSUES\"] = \"ALL_ISSUES\";\n  AUTOMATIC_FIX_LEVELS[\"ERRORS\"] = \"ERRORS\";\n  AUTOMATIC_FIX_LEVELS[\"WARNINGS\"] = \"WARNINGS\";\n})(AUTOMATIC_FIX_LEVELS || (exports.AUTOMATIC_FIX_LEVELS = AUTOMATIC_FIX_LEVELS = {}));\n\nfunction _default(_ref) {\n  var _totalIssuesBasedOnFi;\n\n  var healthchecks, automaticFixLevel, stats, environmentInfo, totalIssuesBasedOnFixLevel, issuesCount, _iterator, _step, category, healthchecksToRun, _iterator2, _step2, healthcheckToRun, spinner;\n\n  return _regeneratorRuntime.async(function _default$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          healthchecks = _ref.healthchecks, automaticFixLevel = _ref.automaticFixLevel, stats = _ref.stats, environmentInfo = _ref.environmentInfo;\n\n          if (process.stdout.isTTY) {\n            process.stdout.moveCursor(0, -6);\n            process.stdout.clearScreenDown();\n          }\n\n          totalIssuesBasedOnFixLevel = (_totalIssuesBasedOnFi = {}, _defineProperty(_totalIssuesBasedOnFi, AUTOMATIC_FIX_LEVELS.ALL_ISSUES, stats.errors + stats.warnings), _defineProperty(_totalIssuesBasedOnFi, AUTOMATIC_FIX_LEVELS.ERRORS, stats.errors), _defineProperty(_totalIssuesBasedOnFi, AUTOMATIC_FIX_LEVELS.WARNINGS, stats.warnings), _totalIssuesBasedOnFi);\n          issuesCount = totalIssuesBasedOnFixLevel[automaticFixLevel];\n\n          _cliTools().logger.log(\"\\nAttempting to fix \" + _chalk().default.bold(issuesCount.toString()) + \" issue\" + (issuesCount > 1 ? 's' : '') + \"...\");\n\n          _iterator = _createForOfIteratorHelperLoose(healthchecks);\n\n        case 6:\n          if ((_step = _iterator()).done) {\n            _context.next = 27;\n            break;\n          }\n\n          category = _step.value;\n          healthchecksToRun = category.healthchecks.filter(function (healthcheck) {\n            if (automaticFixLevel === AUTOMATIC_FIX_LEVELS.ALL_ISSUES) {\n              return healthcheck.needsToBeFixed;\n            }\n\n            if (automaticFixLevel === AUTOMATIC_FIX_LEVELS.ERRORS) {\n              return healthcheck.needsToBeFixed && healthcheck.type === _healthchecks.HEALTHCHECK_TYPES.ERROR;\n            }\n\n            if (automaticFixLevel === AUTOMATIC_FIX_LEVELS.WARNINGS) {\n              return healthcheck.needsToBeFixed && healthcheck.type === _healthchecks.HEALTHCHECK_TYPES.WARNING;\n            }\n\n            return;\n          });\n\n          if (healthchecksToRun.length) {\n            _context.next = 11;\n            break;\n          }\n\n          return _context.abrupt(\"continue\", 25);\n\n        case 11:\n          _cliTools().logger.log(\"\\n\" + _chalk().default.dim(category.label));\n\n          _iterator2 = _createForOfIteratorHelperLoose(healthchecksToRun);\n\n        case 13:\n          if ((_step2 = _iterator2()).done) {\n            _context.next = 25;\n            break;\n          }\n\n          healthcheckToRun = _step2.value;\n          spinner = (0, _ora().default)({\n            prefixText: '',\n            text: healthcheckToRun.label\n          }).start();\n          _context.prev = 16;\n          _context.next = 19;\n          return _regeneratorRuntime.awrap(healthcheckToRun.runAutomaticFix({\n            loader: spinner,\n            logManualInstallation: _common.logManualInstallation,\n            environmentInfo: environmentInfo\n          }));\n\n        case 19:\n          _context.next = 23;\n          break;\n\n        case 21:\n          _context.prev = 21;\n          _context.t0 = _context[\"catch\"](16);\n\n        case 23:\n          _context.next = 13;\n          break;\n\n        case 25:\n          _context.next = 6;\n          break;\n\n        case 27:\n        case \"end\":\n          return _context.stop();\n      }\n    }\n  }, null, null, [[16, 21]], Promise);\n}","map":{"version":3,"sources":["../../src/tools/runAutomaticFix.ts"],"names":["AUTOMATIC_FIX_LEVELS","environmentInfo","process","totalIssuesBasedOnFixLevel","stats","warnings","issuesCount","logger","chalk","healthchecksToRun","healthcheck","automaticFixLevel","HEALTHCHECK_TYPES","category","spinner","prefixText","text","healthcheckToRun","label","loader","logManualInstallation"],"mappings":"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","sourcesContent":["import chalk from 'chalk';\nimport ora from 'ora';\nimport {logger} from '@react-native-community/cli-tools';\nimport {EnvironmentInfo, HealthCheckCategoryResult, Loader} from '../types';\nimport {HEALTHCHECK_TYPES} from './healthchecks';\nimport {logManualInstallation} from './healthchecks/common';\n\nexport enum AUTOMATIC_FIX_LEVELS {\n  ALL_ISSUES = 'ALL_ISSUES',\n  ERRORS = 'ERRORS',\n  WARNINGS = 'WARNINGS',\n}\n\ninterface RunAutomaticFixArgs {\n  healthchecks: HealthCheckCategoryResult[];\n  automaticFixLevel: AUTOMATIC_FIX_LEVELS;\n  stats: {\n    errors: number;\n    warnings: number;\n  };\n  loader: Loader;\n  environmentInfo: EnvironmentInfo;\n}\n\nexport default async function ({\n  healthchecks,\n  automaticFixLevel,\n  stats,\n  environmentInfo,\n}: RunAutomaticFixArgs) {\n  // Remove the fix options from screen\n  if (process.stdout.isTTY) {\n    // @ts-ignore\n    process.stdout.moveCursor(0, -6);\n    // @ts-ignore\n    process.stdout.clearScreenDown();\n  }\n\n  const totalIssuesBasedOnFixLevel: {[x in AUTOMATIC_FIX_LEVELS]: number} = {\n    [AUTOMATIC_FIX_LEVELS.ALL_ISSUES]: stats.errors + stats.warnings,\n    [AUTOMATIC_FIX_LEVELS.ERRORS]: stats.errors,\n    [AUTOMATIC_FIX_LEVELS.WARNINGS]: stats.warnings,\n  };\n  const issuesCount = totalIssuesBasedOnFixLevel[automaticFixLevel];\n\n  logger.log(\n    `\\nAttempting to fix ${chalk.bold(issuesCount.toString())} issue${\n      issuesCount > 1 ? 's' : ''\n    }...`,\n  );\n\n  for (const category of healthchecks) {\n    const healthchecksToRun = category.healthchecks.filter((healthcheck) => {\n      if (automaticFixLevel === AUTOMATIC_FIX_LEVELS.ALL_ISSUES) {\n        return healthcheck.needsToBeFixed;\n      }\n\n      if (automaticFixLevel === AUTOMATIC_FIX_LEVELS.ERRORS) {\n        return (\n          healthcheck.needsToBeFixed &&\n          healthcheck.type === HEALTHCHECK_TYPES.ERROR\n        );\n      }\n\n      if (automaticFixLevel === AUTOMATIC_FIX_LEVELS.WARNINGS) {\n        return (\n          healthcheck.needsToBeFixed &&\n          healthcheck.type === HEALTHCHECK_TYPES.WARNING\n        );\n      }\n\n      return;\n    });\n\n    if (!healthchecksToRun.length) {\n      continue;\n    }\n\n    logger.log(`\\n${chalk.dim(category.label)}`);\n\n    for (const healthcheckToRun of healthchecksToRun) {\n      // @todo replace this with `getLoader` from `tools`\n      const spinner = ora({\n        prefixText: '',\n        text: healthcheckToRun.label,\n      }).start();\n\n      try {\n        await healthcheckToRun.runAutomaticFix({\n          loader: spinner,\n          logManualInstallation,\n          environmentInfo,\n        });\n      } catch (error) {\n        // TODO: log the error in a meaningful way\n      }\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"script"}