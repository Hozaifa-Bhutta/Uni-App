{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"@babel/runtime/helpers/createClass\");\n\nvar EMPTY_MAP = {\n  version: 3,\n  sources: [],\n  names: [],\n  mappings: \"A\"\n};\n\nvar BundleBuilder = function () {\n  function BundleBuilder(file) {\n    _classCallCheck(this, BundleBuilder);\n\n    this._file = file;\n    this._sections = [];\n    this._line = 0;\n    this._column = 0;\n    this._code = \"\";\n    this._afterMappedContent = false;\n  }\n\n  _createClass(BundleBuilder, [{\n    key: \"_pushMapSection\",\n    value: function _pushMapSection(map) {\n      this._sections.push({\n        map: map,\n        offset: {\n          column: this._column,\n          line: this._line\n        }\n      });\n    }\n  }, {\n    key: \"_endMappedContent\",\n    value: function _endMappedContent() {\n      if (this._afterMappedContent) {\n        this._pushMapSection(EMPTY_MAP);\n\n        this._afterMappedContent = false;\n      }\n    }\n  }, {\n    key: \"append\",\n    value: function append(code, map) {\n      if (!code.length) {\n        return this;\n      }\n\n      var _measureString = measureString(code),\n          lineBreaks = _measureString.lineBreaks,\n          lastLineColumns = _measureString.lastLineColumns;\n\n      if (map) {\n        this._pushMapSection(map);\n\n        this._afterMappedContent = true;\n      } else {\n        this._endMappedContent();\n      }\n\n      this._afterMappedContent = !!map;\n      this._line = this._line + lineBreaks;\n\n      if (lineBreaks > 0) {\n        this._column = lastLineColumns;\n      } else {\n        this._column = this._column + lastLineColumns;\n      }\n\n      this._code = this._code + code;\n      return this;\n    }\n  }, {\n    key: \"getMap\",\n    value: function getMap() {\n      this._endMappedContent();\n\n      return createIndexMap(this._file, this._sections);\n    }\n  }, {\n    key: \"getCode\",\n    value: function getCode() {\n      return this._code;\n    }\n  }]);\n\n  return BundleBuilder;\n}();\n\nvar reLineBreak = /\\r\\n|\\r|\\n/g;\n\nfunction measureString(str) {\n  var lineBreaks = 0;\n  var match;\n  var lastLineStart = 0;\n\n  while (match = reLineBreak.exec(str)) {\n    ++lineBreaks;\n    lastLineStart = match.index + match[0].length;\n  }\n\n  var lastLineColumns = str.length - lastLineStart;\n  return {\n    lineBreaks: lineBreaks,\n    lastLineColumns: lastLineColumns\n  };\n}\n\nfunction createIndexMap(file, sections) {\n  return {\n    version: 3,\n    file: file,\n    sections: sections\n  };\n}\n\nmodule.exports = {\n  BundleBuilder: BundleBuilder,\n  createIndexMap: createIndexMap\n};","map":{"version":3,"names":["EMPTY_MAP","version","sources","names","mappings","BundleBuilder","file","_file","_sections","_line","_column","_code","_afterMappedContent","map","push","offset","column","line","_pushMapSection","code","length","measureString","lineBreaks","lastLineColumns","_endMappedContent","createIndexMap","reLineBreak","str","match","lastLineStart","exec","index","sections","module","exports"],"sources":["/Users/hozaifa/Documents/Uni App Github/node_modules/@react-native-community/cli-plugin-metro/node_modules/metro-source-map/src/BundleBuilder.js"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *\n * @format\n */\n\"use strict\";\n\nconst EMPTY_MAP = {\n  version: 3,\n  sources: [],\n  names: [],\n  mappings: \"A\",\n};\n/**\n * Builds a source-mapped bundle by concatenating strings and their\n * corresponding source maps (if any).\n *\n * Usage:\n *\n * const builder = new BundleBuilder('bundle.js');\n * builder\n *   .append('foo\\n', fooMap)\n *   .append('bar\\n')\n *   // ...\n * const code = builder.getCode();\n * const map = builder.getMap();\n */\n\nclass BundleBuilder {\n  constructor(file) {\n    this._file = file;\n    this._sections = [];\n    this._line = 0;\n    this._column = 0;\n    this._code = \"\";\n    this._afterMappedContent = false;\n  }\n\n  _pushMapSection(map) {\n    this._sections.push({\n      map,\n      offset: {\n        column: this._column,\n        line: this._line,\n      },\n    });\n  }\n\n  _endMappedContent() {\n    if (this._afterMappedContent) {\n      this._pushMapSection(EMPTY_MAP);\n\n      this._afterMappedContent = false;\n    }\n  }\n\n  append(code, map) {\n    if (!code.length) {\n      return this;\n    }\n\n    const { lineBreaks, lastLineColumns } = measureString(code);\n\n    if (map) {\n      this._pushMapSection(map);\n\n      this._afterMappedContent = true;\n    } else {\n      this._endMappedContent();\n    }\n\n    this._afterMappedContent = !!map;\n    this._line = this._line + lineBreaks;\n\n    if (lineBreaks > 0) {\n      this._column = lastLineColumns;\n    } else {\n      this._column = this._column + lastLineColumns;\n    }\n\n    this._code = this._code + code;\n    return this;\n  }\n\n  getMap() {\n    this._endMappedContent();\n\n    return createIndexMap(this._file, this._sections);\n  }\n\n  getCode() {\n    return this._code;\n  }\n}\n\nconst reLineBreak = /\\r\\n|\\r|\\n/g;\n\nfunction measureString(str) {\n  let lineBreaks = 0;\n  let match;\n  let lastLineStart = 0;\n\n  while ((match = reLineBreak.exec(str))) {\n    ++lineBreaks;\n    lastLineStart = match.index + match[0].length;\n  }\n\n  const lastLineColumns = str.length - lastLineStart;\n  return {\n    lineBreaks,\n    lastLineColumns,\n  };\n}\n\nfunction createIndexMap(file, sections) {\n  return {\n    version: 3,\n    file,\n    sections,\n  };\n}\n\nmodule.exports = {\n  BundleBuilder,\n  createIndexMap,\n};\n"],"mappings":"AASA;;;;;;AAEA,IAAMA,SAAS,GAAG;EAChBC,OAAO,EAAE,CADO;EAEhBC,OAAO,EAAE,EAFO;EAGhBC,KAAK,EAAE,EAHS;EAIhBC,QAAQ,EAAE;AAJM,CAAlB;;IAqBMC,a;EACJ,uBAAYC,IAAZ,EAAkB;IAAA;;IAChB,KAAKC,KAAL,GAAaD,IAAb;IACA,KAAKE,SAAL,GAAiB,EAAjB;IACA,KAAKC,KAAL,GAAa,CAAb;IACA,KAAKC,OAAL,GAAe,CAAf;IACA,KAAKC,KAAL,GAAa,EAAb;IACA,KAAKC,mBAAL,GAA2B,KAA3B;EACD;;;;WAED,yBAAgBC,GAAhB,EAAqB;MACnB,KAAKL,SAAL,CAAeM,IAAf,CAAoB;QAClBD,GAAG,EAAHA,GADkB;QAElBE,MAAM,EAAE;UACNC,MAAM,EAAE,KAAKN,OADP;UAENO,IAAI,EAAE,KAAKR;QAFL;MAFU,CAApB;IAOD;;;WAED,6BAAoB;MAClB,IAAI,KAAKG,mBAAT,EAA8B;QAC5B,KAAKM,eAAL,CAAqBlB,SAArB;;QAEA,KAAKY,mBAAL,GAA2B,KAA3B;MACD;IACF;;;WAED,gBAAOO,IAAP,EAAaN,GAAb,EAAkB;MAChB,IAAI,CAACM,IAAI,CAACC,MAAV,EAAkB;QAChB,OAAO,IAAP;MACD;;MAED,qBAAwCC,aAAa,CAACF,IAAD,CAArD;MAAA,IAAQG,UAAR,kBAAQA,UAAR;MAAA,IAAoBC,eAApB,kBAAoBA,eAApB;;MAEA,IAAIV,GAAJ,EAAS;QACP,KAAKK,eAAL,CAAqBL,GAArB;;QAEA,KAAKD,mBAAL,GAA2B,IAA3B;MACD,CAJD,MAIO;QACL,KAAKY,iBAAL;MACD;;MAED,KAAKZ,mBAAL,GAA2B,CAAC,CAACC,GAA7B;MACA,KAAKJ,KAAL,GAAa,KAAKA,KAAL,GAAaa,UAA1B;;MAEA,IAAIA,UAAU,GAAG,CAAjB,EAAoB;QAClB,KAAKZ,OAAL,GAAea,eAAf;MACD,CAFD,MAEO;QACL,KAAKb,OAAL,GAAe,KAAKA,OAAL,GAAea,eAA9B;MACD;;MAED,KAAKZ,KAAL,GAAa,KAAKA,KAAL,GAAaQ,IAA1B;MACA,OAAO,IAAP;IACD;;;WAED,kBAAS;MACP,KAAKK,iBAAL;;MAEA,OAAOC,cAAc,CAAC,KAAKlB,KAAN,EAAa,KAAKC,SAAlB,CAArB;IACD;;;WAED,mBAAU;MACR,OAAO,KAAKG,KAAZ;IACD;;;;;;AAGH,IAAMe,WAAW,GAAG,aAApB;;AAEA,SAASL,aAAT,CAAuBM,GAAvB,EAA4B;EAC1B,IAAIL,UAAU,GAAG,CAAjB;EACA,IAAIM,KAAJ;EACA,IAAIC,aAAa,GAAG,CAApB;;EAEA,OAAQD,KAAK,GAAGF,WAAW,CAACI,IAAZ,CAAiBH,GAAjB,CAAhB,EAAwC;IACtC,EAAEL,UAAF;IACAO,aAAa,GAAGD,KAAK,CAACG,KAAN,GAAcH,KAAK,CAAC,CAAD,CAAL,CAASR,MAAvC;EACD;;EAED,IAAMG,eAAe,GAAGI,GAAG,CAACP,MAAJ,GAAaS,aAArC;EACA,OAAO;IACLP,UAAU,EAAVA,UADK;IAELC,eAAe,EAAfA;EAFK,CAAP;AAID;;AAED,SAASE,cAAT,CAAwBnB,IAAxB,EAA8B0B,QAA9B,EAAwC;EACtC,OAAO;IACL/B,OAAO,EAAE,CADJ;IAELK,IAAI,EAAJA,IAFK;IAGL0B,QAAQ,EAARA;EAHK,CAAP;AAKD;;AAEDC,MAAM,CAACC,OAAP,GAAiB;EACf7B,aAAa,EAAbA,aADe;EAEfoB,cAAc,EAAdA;AAFe,CAAjB"},"metadata":{},"sourceType":"script"}