{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"@babel/runtime/regenerator\");\n\nvar _classCallCheck = require(\"@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"@babel/runtime/helpers/createClass\");\n\nvar _require = require(\"metro-core\"),\n    Logger = _require.Logger;\n\nvar Cache = function () {\n  function Cache(stores) {\n    _classCallCheck(this, Cache);\n\n    this._hits = new WeakMap();\n    this._stores = stores;\n  }\n\n  _createClass(Cache, [{\n    key: \"get\",\n    value: function get(key) {\n      var stores, length, i, store, name, value, logStart, valueOrPromise;\n      return _regeneratorRuntime.async(function get$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              stores = this._stores;\n              length = stores.length;\n              i = 0;\n\n            case 3:\n              if (!(i < length)) {\n                _context.next = 27;\n                break;\n              }\n\n              store = stores[i];\n              name = store.constructor.name + \"::\" + key.toString(\"hex\");\n              value = null;\n              logStart = Logger.log(Logger.createActionStartEntry({\n                action_name: \"Cache get\",\n                log_entry_label: name\n              }));\n              _context.prev = 8;\n              valueOrPromise = store.get(key);\n\n              if (!(valueOrPromise && typeof valueOrPromise.then === \"function\")) {\n                _context.next = 16;\n                break;\n              }\n\n              _context.next = 13;\n              return _regeneratorRuntime.awrap(valueOrPromise);\n\n            case 13:\n              value = _context.sent;\n              _context.next = 17;\n              break;\n\n            case 16:\n              value = valueOrPromise;\n\n            case 17:\n              _context.prev = 17;\n              Logger.log(Logger.createActionEndEntry(logStart));\n              Logger.log(Logger.createEntry({\n                action_name: \"Cache \" + (value == null ? \"miss\" : \"hit\"),\n                log_entry_label: name\n              }));\n\n              if (!(value != null)) {\n                _context.next = 23;\n                break;\n              }\n\n              this._hits.set(key, store);\n\n              return _context.abrupt(\"return\", value);\n\n            case 23:\n              return _context.finish(17);\n\n            case 24:\n              i++;\n              _context.next = 3;\n              break;\n\n            case 27:\n              return _context.abrupt(\"return\", null);\n\n            case 28:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, null, this, [[8,, 17, 24]], Promise);\n    }\n  }, {\n    key: \"set\",\n    value: function set(key, value) {\n      var stores = this._stores;\n\n      var stop = this._hits.get(key);\n\n      var length = stores.length;\n      var promises = [];\n\n      for (var i = 0; i < length && stores[i] !== stop; i++) {\n        var store = stores[i];\n        var name = store.constructor.name + \"::\" + key.toString(\"hex\");\n        Logger.log(Logger.createEntry({\n          action_name: \"Cache set\",\n          log_entry_label: name\n        }));\n        promises.push(stores[i].set(key, value));\n      }\n\n      Promise.all(promises).catch(function (err) {\n        process.nextTick(function () {\n          throw err;\n        });\n      });\n    }\n  }, {\n    key: \"isDisabled\",\n    get: function get() {\n      return this._stores.length === 0;\n    }\n  }]);\n\n  return Cache;\n}();\n\nmodule.exports = Cache;","map":{"version":3,"names":["require","Logger","Cache","stores","_hits","WeakMap","_stores","key","length","i","store","name","constructor","toString","value","logStart","log","createActionStartEntry","action_name","log_entry_label","valueOrPromise","get","then","createActionEndEntry","createEntry","set","stop","promises","push","Promise","all","catch","err","process","nextTick","module","exports"],"sources":["/Users/hozaifa/Documents/Uni App Github/node_modules/@react-native-community/cli-plugin-metro/node_modules/metro-cache/src/Cache.js"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *\n * @format\n */\n\"use strict\";\n\nconst { Logger } = require(\"metro-core\");\n/**\n * Main cache class. Receives an array of cache instances, and sequentially\n * traverses them to return a previously stored value. It also ensures setting\n * the value in all instances.\n *\n * All get/set operations are logged via Metro's logger.\n */\n\nclass Cache {\n  constructor(stores) {\n    this._hits = new WeakMap();\n    this._stores = stores;\n  }\n\n  async get(key) {\n    const stores = this._stores;\n    const length = stores.length;\n\n    for (let i = 0; i < length; i++) {\n      const store = stores[i];\n      const name = store.constructor.name + \"::\" + key.toString(\"hex\");\n      let value = null;\n      const logStart = Logger.log(\n        Logger.createActionStartEntry({\n          action_name: \"Cache get\",\n          log_entry_label: name,\n        })\n      );\n\n      try {\n        const valueOrPromise = store.get(key); // $FlowFixMe[method-unbinding] added when improving typing for this parameters\n\n        if (valueOrPromise && typeof valueOrPromise.then === \"function\") {\n          value = await valueOrPromise;\n        } else {\n          value = valueOrPromise;\n        }\n      } finally {\n        Logger.log(Logger.createActionEndEntry(logStart));\n        Logger.log(\n          Logger.createEntry({\n            action_name: \"Cache \" + (value == null ? \"miss\" : \"hit\"),\n            log_entry_label: name,\n          })\n        );\n\n        if (value != null) {\n          this._hits.set(key, store);\n\n          return value;\n        }\n      }\n    }\n\n    return null;\n  }\n\n  set(key, value) {\n    const stores = this._stores;\n\n    const stop = this._hits.get(key);\n\n    const length = stores.length;\n    const promises = [];\n\n    for (let i = 0; i < length && stores[i] !== stop; i++) {\n      const store = stores[i];\n      const name = store.constructor.name + \"::\" + key.toString(\"hex\");\n      Logger.log(\n        Logger.createEntry({\n          action_name: \"Cache set\",\n          log_entry_label: name,\n        })\n      );\n      promises.push(stores[i].set(key, value));\n    }\n\n    Promise.all(promises).catch((err) => {\n      process.nextTick(() => {\n        throw err;\n      });\n    });\n  } // Returns true if the current configuration disables the cache, such that\n  // writing to the cache is a no-op and reading from the cache will always\n  // return null.\n\n  get isDisabled() {\n    return this._stores.length === 0;\n  }\n}\n\nmodule.exports = Cache;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}