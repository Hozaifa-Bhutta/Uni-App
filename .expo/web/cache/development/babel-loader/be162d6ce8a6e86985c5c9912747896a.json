{"ast":null,"code":"\"use strict\";\n\nvar _assertThisInitialized = require(\"@babel/runtime/helpers/assertThisInitialized\");\n\nvar _inherits = require(\"@babel/runtime/helpers/inherits\");\n\nvar _possibleConstructorReturn = require(\"@babel/runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"@babel/runtime/helpers/getPrototypeOf\");\n\nvar _wrapNativeSuper = require(\"@babel/runtime/helpers/wrapNativeSuper\");\n\nvar _extends = require(\"@babel/runtime/helpers/extends\");\n\nvar _defineProperty = require(\"@babel/runtime/helpers/defineProperty\");\n\nvar _regeneratorRuntime = require(\"@babel/runtime/regenerator\");\n\nvar _classCallCheck = require(\"@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"@babel/runtime/helpers/createClass\");\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nvar _require = require(\"jest-worker\"),\n    JestWorker = _require.Worker;\n\nvar _require2 = require(\"metro-core\"),\n    Logger = _require2.Logger;\n\nvar WorkerFarm = function () {\n  function WorkerFarm(config, transformerConfig) {\n    var _this = this;\n\n    _classCallCheck(this, WorkerFarm);\n\n    this._config = config;\n    this._transformerConfig = transformerConfig;\n\n    if (this._config.maxWorkers > 1) {\n      var worker = this._makeFarm(this._config.transformer.workerPath, [\"transform\"], this._config.maxWorkers);\n\n      worker.getStdout().on(\"data\", function (chunk) {\n        _this._config.reporter.update({\n          type: \"worker_stdout_chunk\",\n          chunk: chunk.toString(\"utf8\")\n        });\n      });\n      worker.getStderr().on(\"data\", function (chunk) {\n        _this._config.reporter.update({\n          type: \"worker_stderr_chunk\",\n          chunk: chunk.toString(\"utf8\")\n        });\n      });\n      this._worker = worker;\n    } else {\n      this._worker = require.call(null, this._config.transformer.workerPath);\n    }\n  }\n\n  _createClass(WorkerFarm, [{\n    key: \"kill\",\n    value: function kill() {\n      return _regeneratorRuntime.async(function kill$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              if (!(this._worker && typeof this._worker.end === \"function\")) {\n                _context.next = 3;\n                break;\n              }\n\n              _context.next = 3;\n              return _regeneratorRuntime.awrap(this._worker.end());\n\n            case 3:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, null, this, null, Promise);\n    }\n  }, {\n    key: \"transform\",\n    value: function transform(filename, options) {\n      var data;\n      return _regeneratorRuntime.async(function transform$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              _context2.prev = 0;\n              _context2.next = 3;\n              return _regeneratorRuntime.awrap(this._worker.transform(filename, options, this._config.projectRoot, this._transformerConfig));\n\n            case 3:\n              data = _context2.sent;\n              Logger.log(data.transformFileStartLogEntry);\n              Logger.log(data.transformFileEndLogEntry);\n              return _context2.abrupt(\"return\", {\n                result: data.result,\n                sha1: data.sha1\n              });\n\n            case 9:\n              _context2.prev = 9;\n              _context2.t0 = _context2[\"catch\"](0);\n\n              if (!_context2.t0.loc) {\n                _context2.next = 15;\n                break;\n              }\n\n              throw this._formatBabelError(_context2.t0, filename);\n\n            case 15:\n              throw this._formatGenericError(_context2.t0, filename);\n\n            case 16:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, null, this, [[0, 9]], Promise);\n    }\n  }, {\n    key: \"_makeFarm\",\n    value: function _makeFarm(workerPath, exposedMethods, numWorkers) {\n      var env = _objectSpread(_objectSpread({}, process.env), {}, {\n        FORCE_COLOR: 1\n      });\n\n      return new JestWorker(workerPath, {\n        computeWorkerKey: this._config.stickyWorkers ? this._computeWorkerKey : undefined,\n        exposedMethods: exposedMethods,\n        forkOptions: {\n          env: env\n        },\n        numWorkers: numWorkers\n      });\n    }\n  }, {\n    key: \"_computeWorkerKey\",\n    value: function _computeWorkerKey(method, filename) {\n      if (method === \"transform\") {\n        return filename;\n      }\n\n      return null;\n    }\n  }, {\n    key: \"_formatGenericError\",\n    value: function _formatGenericError(err, filename) {\n      var error = new TransformError(filename + \": \" + err.message);\n      return _extends(error, {\n        stack: (err.stack || \"\").split(\"\\n\").slice(0, -1).join(\"\\n\"),\n        lineNumber: 0\n      });\n    }\n  }, {\n    key: \"_formatBabelError\",\n    value: function _formatBabelError(err, filename) {\n      var error = new TransformError(\"\" + (err.type || \"Error\") + (err.message.includes(filename) ? \"\" : \" in \" + filename) + \": \" + err.message);\n      return _extends(error, {\n        stack: err.stack,\n        snippet: err.codeFrame,\n        lineNumber: err.loc.line,\n        column: err.loc.column,\n        filename: filename\n      });\n    }\n  }]);\n\n  return WorkerFarm;\n}();\n\nvar TransformError = function (_SyntaxError) {\n  _inherits(TransformError, _SyntaxError);\n\n  var _super = _createSuper(TransformError);\n\n  function TransformError(message) {\n    var _this2;\n\n    _classCallCheck(this, TransformError);\n\n    _this2 = _super.call(this, message);\n    _this2.type = \"TransformError\";\n    Error.captureStackTrace && Error.captureStackTrace(_assertThisInitialized(_this2), TransformError);\n    return _this2;\n  }\n\n  return _createClass(TransformError);\n}(_wrapNativeSuper(SyntaxError));\n\nmodule.exports = WorkerFarm;","map":{"version":3,"names":["require","JestWorker","Worker","Logger","WorkerFarm","config","transformerConfig","_config","_transformerConfig","maxWorkers","worker","_makeFarm","transformer","workerPath","getStdout","on","chunk","reporter","update","type","toString","getStderr","_worker","call","end","filename","options","transform","projectRoot","data","log","transformFileStartLogEntry","transformFileEndLogEntry","result","sha1","loc","_formatBabelError","_formatGenericError","exposedMethods","numWorkers","env","process","FORCE_COLOR","computeWorkerKey","stickyWorkers","_computeWorkerKey","undefined","forkOptions","method","err","error","TransformError","message","stack","split","slice","join","lineNumber","includes","snippet","codeFrame","line","column","Error","captureStackTrace","SyntaxError","module","exports"],"sources":["/Users/hozaifa/Documents/Uni App Github/node_modules/@react-native-community/cli-plugin-metro/node_modules/metro/src/DeltaBundler/WorkerFarm.js"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *\n * @format\n */\n\"use strict\";\n\nconst { Worker: JestWorker } = require(\"jest-worker\");\n\nconst { Logger } = require(\"metro-core\");\n\nclass WorkerFarm {\n  constructor(config, transformerConfig) {\n    this._config = config;\n    this._transformerConfig = transformerConfig;\n\n    if (this._config.maxWorkers > 1) {\n      const worker = this._makeFarm(\n        this._config.transformer.workerPath,\n        [\"transform\"],\n        this._config.maxWorkers\n      );\n\n      worker.getStdout().on(\"data\", (chunk) => {\n        this._config.reporter.update({\n          type: \"worker_stdout_chunk\",\n          chunk: chunk.toString(\"utf8\"),\n        });\n      });\n      worker.getStderr().on(\"data\", (chunk) => {\n        this._config.reporter.update({\n          type: \"worker_stderr_chunk\",\n          chunk: chunk.toString(\"utf8\"),\n        });\n      });\n      this._worker = worker;\n    } else {\n      // eslint-disable-next-line no-useless-call\n      this._worker = require.call(null, this._config.transformer.workerPath);\n    }\n  }\n\n  async kill() {\n    if (this._worker && typeof this._worker.end === \"function\") {\n      await this._worker.end();\n    }\n  }\n\n  async transform(filename, options) {\n    try {\n      const data = await this._worker.transform(\n        filename,\n        options,\n        this._config.projectRoot,\n        this._transformerConfig\n      );\n      Logger.log(data.transformFileStartLogEntry);\n      Logger.log(data.transformFileEndLogEntry);\n      return {\n        result: data.result,\n        sha1: data.sha1,\n      };\n    } catch (err) {\n      if (err.loc) {\n        throw this._formatBabelError(err, filename);\n      } else {\n        throw this._formatGenericError(err, filename);\n      }\n    }\n  }\n\n  _makeFarm(workerPath, exposedMethods, numWorkers) {\n    const env = {\n      ...process.env,\n      // Force color to print syntax highlighted code frames.\n      FORCE_COLOR: 1,\n    };\n    return new JestWorker(workerPath, {\n      computeWorkerKey: this._config.stickyWorkers // $FlowFixMe[method-unbinding] added when improving typing for this parameters\n        ? this._computeWorkerKey\n        : undefined,\n      exposedMethods,\n      forkOptions: {\n        env,\n      },\n      numWorkers,\n    });\n  }\n\n  _computeWorkerKey(method, filename) {\n    // Only when transforming a file we want to stick to the same worker; and\n    // we'll shard by file path. If not; we return null, which tells the worker\n    // to pick the first available one.\n    if (method === \"transform\") {\n      return filename;\n    }\n\n    return null;\n  }\n\n  _formatGenericError(err, filename) {\n    const error = new TransformError(`${filename}: ${err.message}`);\n    return Object.assign(error, {\n      stack: (err.stack || \"\").split(\"\\n\").slice(0, -1).join(\"\\n\"),\n      lineNumber: 0,\n    });\n  }\n\n  _formatBabelError(err, filename) {\n    const error = new TransformError(\n      `${err.type || \"Error\"}${\n        err.message.includes(filename) ? \"\" : \" in \" + filename\n      }: ${err.message}`\n    ); // $FlowExpectedError: TODO(t67543470): Change this to properly extend the error.\n\n    return Object.assign(error, {\n      stack: err.stack,\n      snippet: err.codeFrame,\n      lineNumber: err.loc.line,\n      column: err.loc.column,\n      filename,\n    });\n  }\n}\n\nclass TransformError extends SyntaxError {\n  type = \"TransformError\";\n\n  constructor(message) {\n    super(message);\n    Error.captureStackTrace && Error.captureStackTrace(this, TransformError);\n  }\n}\n\nmodule.exports = WorkerFarm;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}