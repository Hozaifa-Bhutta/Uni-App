{"ast":null,"code":"\"use strict\";\n\nvar _toConsumableArray = require(\"@babel/runtime/helpers/toConsumableArray\");\n\nvar _defineProperty = require(\"@babel/runtime/helpers/defineProperty\");\n\nvar _objectWithoutProperties = require(\"@babel/runtime/helpers/objectWithoutProperties\");\n\nvar _regeneratorRuntime = require(\"@babel/runtime/regenerator\");\n\nvar _classCallCheck = require(\"@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"@babel/runtime/helpers/createClass\");\n\nvar _excluded = [\"dev\", \"minify\", \"runModule\", \"bundleEntry\"];\n\nfunction _createForOfIteratorHelperLoose(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (it) return (it = it.call(o)).next.bind(it); if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nvar hmrJSBundle = require(\"./DeltaBundler/Serializers/hmrJSBundle\");\n\nvar IncrementalBundler = require(\"./IncrementalBundler\");\n\nvar GraphNotFoundError = require(\"./IncrementalBundler/GraphNotFoundError\");\n\nvar RevisionNotFoundError = require(\"./IncrementalBundler/RevisionNotFoundError\");\n\nvar debounceAsyncQueue = require(\"./lib/debounceAsyncQueue\");\n\nvar formatBundlingError = require(\"./lib/formatBundlingError\");\n\nvar getGraphId = require(\"./lib/getGraphId\");\n\nvar parseOptionsFromUrl = require(\"./lib/parseOptionsFromUrl\");\n\nvar splitBundleOptions = require(\"./lib/splitBundleOptions\");\n\nvar transformHelpers = require(\"./lib/transformHelpers\");\n\nvar _require = require(\"metro-core\"),\n    _require$Logger = _require.Logger,\n    createActionStartEntry = _require$Logger.createActionStartEntry,\n    createActionEndEntry = _require$Logger.createActionEndEntry,\n    log = _require$Logger.log;\n\nvar _require2 = require(\"metro-hermes-compiler\"),\n    BYTECODE_VERSION = _require2.VERSION;\n\nvar nullthrows = require(\"nullthrows\");\n\nvar url = require(\"url\");\n\nfunction send(sendFns, message) {\n  var strMessage = JSON.stringify(message);\n  sendFns.forEach(function (sendFn) {\n    return sendFn(strMessage);\n  });\n}\n\nvar HmrServer = function () {\n  function HmrServer(bundler, createModuleId, config) {\n    var _this = this;\n\n    _classCallCheck(this, HmrServer);\n\n    this.onClientConnect = function _callee(requestUrl, sendFn) {\n      return _regeneratorRuntime.async(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              return _context.abrupt(\"return\", {\n                sendFn: sendFn,\n                revisionIds: [],\n                optedIntoHMR: false\n              });\n\n            case 1:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, null, null, null, Promise);\n    };\n\n    this.onClientMessage = function _callee2(client, message, sendFn) {\n      var data;\n      return _regeneratorRuntime.async(function _callee2$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              _context2.prev = 0;\n              data = JSON.parse(message);\n              _context2.next = 8;\n              break;\n\n            case 4:\n              _context2.prev = 4;\n              _context2.t0 = _context2[\"catch\"](0);\n              send([sendFn], {\n                type: \"error\",\n                body: formatBundlingError(_context2.t0)\n              });\n              return _context2.abrupt(\"return\", Promise.resolve());\n\n            case 8:\n              if (!(data && data.type)) {\n                _context2.next = 18;\n                break;\n              }\n\n              _context2.t1 = data.type;\n              _context2.next = _context2.t1 === \"register-entrypoints\" ? 12 : _context2.t1 === \"log\" ? 13 : _context2.t1 === \"log-opt-in\" ? 15 : 17;\n              break;\n\n            case 12:\n              return _context2.abrupt(\"return\", Promise.all(data.entryPoints.map(function (entryPoint) {\n                return _this._registerEntryPoint(client, entryPoint, sendFn);\n              })));\n\n            case 13:\n              _this._config.reporter.update({\n                type: \"client_log\",\n                level: data.level,\n                data: data.data,\n                mode: data.mode\n              });\n\n              return _context2.abrupt(\"break\", 18);\n\n            case 15:\n              client.optedIntoHMR = true;\n              return _context2.abrupt(\"break\", 18);\n\n            case 17:\n              return _context2.abrupt(\"break\", 18);\n\n            case 18:\n              return _context2.abrupt(\"return\", Promise.resolve());\n\n            case 19:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, null, null, [[0, 4]], Promise);\n    };\n\n    this.onClientError = function (client, e) {\n      _this._config.reporter.update({\n        type: \"hmr_client_error\",\n        error: e.error\n      });\n\n      _this.onClientDisconnect(client);\n    };\n\n    this.onClientDisconnect = function (client) {\n      client.revisionIds.forEach(function (revisionId) {\n        var group = _this._clientGroups.get(revisionId);\n\n        if (group != null) {\n          if (group.clients.size === 1) {\n            _this._clientGroups.delete(revisionId);\n\n            group.unlisten();\n          } else {\n            group.clients.delete(client);\n          }\n        }\n      });\n    };\n\n    this._config = config;\n    this._bundler = bundler;\n    this._createModuleId = createModuleId;\n    this._clientGroups = new Map();\n  }\n\n  _createClass(HmrServer, [{\n    key: \"_registerEntryPoint\",\n    value: function _registerEntryPoint(client, requestUrl, sendFn) {\n      var _this$_config$server$, clientUrl, options, _splitBundleOptions, entryFile, transformOptions, graphOptions, resolutionFn, resolvedEntryFilePath, graphId, revPromise, _await$revPromise, graph, id, clientGroup, _ref, dev, minify, runModule, _bundleEntry, query, _unlisten;\n\n      return _regeneratorRuntime.async(function _registerEntryPoint$(_context3) {\n        while (1) {\n          switch (_context3.prev = _context3.next) {\n            case 0:\n              requestUrl = this._config.server.rewriteRequestUrl(requestUrl);\n              clientUrl = nullthrows(url.parse(requestUrl, true));\n              options = parseOptionsFromUrl(requestUrl, new Set(this._config.resolver.platforms), BYTECODE_VERSION);\n              _splitBundleOptions = splitBundleOptions(options), entryFile = _splitBundleOptions.entryFile, transformOptions = _splitBundleOptions.transformOptions, graphOptions = _splitBundleOptions.graphOptions;\n              _context3.next = 6;\n              return _regeneratorRuntime.awrap(transformHelpers.getResolveDependencyFn(this._bundler.getBundler(), transformOptions.platform));\n\n            case 6:\n              resolutionFn = _context3.sent;\n              resolvedEntryFilePath = resolutionFn(((_this$_config$server$ = this._config.server.unstable_serverRoot) !== null && _this$_config$server$ !== void 0 ? _this$_config$server$ : this._config.projectRoot) + \"/.\", entryFile);\n              graphId = getGraphId(resolvedEntryFilePath, transformOptions, {\n                shallow: graphOptions.shallow,\n                experimentalImportBundleSupport: this._config.transformer.experimentalImportBundleSupport\n              });\n              revPromise = this._bundler.getRevisionByGraphId(graphId);\n\n              if (revPromise) {\n                _context3.next = 13;\n                break;\n              }\n\n              send([sendFn], {\n                type: \"error\",\n                body: formatBundlingError(new GraphNotFoundError(graphId))\n              });\n              return _context3.abrupt(\"return\");\n\n            case 13:\n              _context3.next = 15;\n              return _regeneratorRuntime.awrap(revPromise);\n\n            case 15:\n              _await$revPromise = _context3.sent;\n              graph = _await$revPromise.graph;\n              id = _await$revPromise.id;\n              client.revisionIds.push(id);\n              clientGroup = this._clientGroups.get(id);\n\n              if (clientGroup != null) {\n                clientGroup.clients.add(client);\n              } else {\n                clientUrl.protocol = \"http\";\n                _ref = clientUrl.query || {}, dev = _ref.dev, minify = _ref.minify, runModule = _ref.runModule, _bundleEntry = _ref.bundleEntry, query = _objectWithoutProperties(_ref, _excluded);\n                clientUrl.query = _objectSpread(_objectSpread({}, query), {}, {\n                  dev: dev || \"true\",\n                  minify: minify || \"false\",\n                  modulesOnly: \"true\",\n                  runModule: runModule || \"false\",\n                  shallow: \"true\"\n                });\n                clientUrl.search = \"\";\n                clientGroup = {\n                  clients: new Set([client]),\n                  clientUrl: clientUrl,\n                  revisionId: id,\n                  unlisten: function unlisten() {\n                    return _unlisten();\n                  }\n                };\n\n                this._clientGroups.set(id, clientGroup);\n\n                _unlisten = this._bundler.getDeltaBundler().listen(graph, debounceAsyncQueue(this._handleFileChange.bind(this, clientGroup, {\n                  isInitialUpdate: false\n                }), 50));\n              }\n\n              _context3.next = 23;\n              return _regeneratorRuntime.awrap(this._handleFileChange(clientGroup, {\n                isInitialUpdate: true\n              }));\n\n            case 23:\n              send([sendFn], {\n                type: \"bundle-registered\"\n              });\n\n            case 24:\n            case \"end\":\n              return _context3.stop();\n          }\n        }\n      }, null, this, null, Promise);\n    }\n  }, {\n    key: \"_handleFileChange\",\n    value: function _handleFileChange(group, options) {\n      var optedIntoHMR, processingHmrChange, sendFns, message;\n      return _regeneratorRuntime.async(function _handleFileChange$(_context4) {\n        while (1) {\n          switch (_context4.prev = _context4.next) {\n            case 0:\n              optedIntoHMR = _toConsumableArray(group.clients).some(function (client) {\n                return client.optedIntoHMR;\n              });\n              processingHmrChange = log(createActionStartEntry({\n                action_name: optedIntoHMR ? \"Processing HMR change\" : \"Processing HMR change (no client opt-in)\"\n              }));\n              sendFns = _toConsumableArray(group.clients).map(function (client) {\n                return client.sendFn;\n              });\n              send(sendFns, {\n                type: \"update-start\",\n                body: options\n              });\n              _context4.next = 6;\n              return _regeneratorRuntime.awrap(this._prepareMessage(group, options));\n\n            case 6:\n              message = _context4.sent;\n              send(sendFns, message);\n              send(sendFns, {\n                type: \"update-done\"\n              });\n              log(_objectSpread(_objectSpread({}, createActionEndEntry(processingHmrChange)), {}, {\n                outdated_modules: message.type === \"update\" ? message.body.added.length + message.body.modified.length : undefined\n              }));\n\n            case 10:\n            case \"end\":\n              return _context4.stop();\n          }\n        }\n      }, null, this, null, Promise);\n    }\n  }, {\n    key: \"_prepareMessage\",\n    value: function _prepareMessage(group, options) {\n      var _this$_config$server$2, revPromise, _await$this$_bundler$, revision, delta, _iterator, _step, client, hmrUpdate, formattedError;\n\n      return _regeneratorRuntime.async(function _prepareMessage$(_context5) {\n        while (1) {\n          switch (_context5.prev = _context5.next) {\n            case 0:\n              _context5.prev = 0;\n              revPromise = this._bundler.getRevision(group.revisionId);\n\n              if (revPromise) {\n                _context5.next = 4;\n                break;\n              }\n\n              return _context5.abrupt(\"return\", {\n                type: \"error\",\n                body: formatBundlingError(new RevisionNotFoundError(group.revisionId))\n              });\n\n            case 4:\n              _context5.t0 = _regeneratorRuntime;\n              _context5.t1 = this._bundler;\n              _context5.next = 8;\n              return _regeneratorRuntime.awrap(revPromise);\n\n            case 8:\n              _context5.t2 = _context5.sent;\n              _context5.t3 = _context5.t1.updateGraph.call(_context5.t1, _context5.t2, false);\n              _context5.next = 12;\n              return _context5.t0.awrap.call(_context5.t0, _context5.t3);\n\n            case 12:\n              _await$this$_bundler$ = _context5.sent;\n              revision = _await$this$_bundler$.revision;\n              delta = _await$this$_bundler$.delta;\n\n              this._clientGroups.delete(group.revisionId);\n\n              group.revisionId = revision.id;\n\n              for (_iterator = _createForOfIteratorHelperLoose(group.clients); !(_step = _iterator()).done;) {\n                client = _step.value;\n                client.revisionIds = client.revisionIds.filter(function (revisionId) {\n                  return revisionId !== group.revisionId;\n                });\n                client.revisionIds.push(revision.id);\n              }\n\n              this._clientGroups.set(group.revisionId, group);\n\n              hmrUpdate = hmrJSBundle(delta, revision.graph, {\n                createModuleId: this._createModuleId,\n                projectRoot: (_this$_config$server$2 = this._config.server.unstable_serverRoot) !== null && _this$_config$server$2 !== void 0 ? _this$_config$server$2 : this._config.projectRoot,\n                clientUrl: group.clientUrl\n              });\n              return _context5.abrupt(\"return\", {\n                type: \"update\",\n                body: _objectSpread({\n                  revisionId: revision.id,\n                  isInitialUpdate: options.isInitialUpdate\n                }, hmrUpdate)\n              });\n\n            case 23:\n              _context5.prev = 23;\n              _context5.t4 = _context5[\"catch\"](0);\n              formattedError = formatBundlingError(_context5.t4);\n\n              this._config.reporter.update({\n                type: \"bundling_error\",\n                error: _context5.t4\n              });\n\n              return _context5.abrupt(\"return\", {\n                type: \"error\",\n                body: formattedError\n              });\n\n            case 28:\n            case \"end\":\n              return _context5.stop();\n          }\n        }\n      }, null, this, [[0, 23]], Promise);\n    }\n  }]);\n\n  return HmrServer;\n}();\n\nmodule.exports = HmrServer;","map":{"version":3,"names":["hmrJSBundle","require","IncrementalBundler","GraphNotFoundError","RevisionNotFoundError","debounceAsyncQueue","formatBundlingError","getGraphId","parseOptionsFromUrl","splitBundleOptions","transformHelpers","Logger","createActionStartEntry","createActionEndEntry","log","BYTECODE_VERSION","VERSION","nullthrows","url","send","sendFns","message","strMessage","JSON","stringify","forEach","sendFn","HmrServer","bundler","createModuleId","config","onClientConnect","requestUrl","revisionIds","optedIntoHMR","onClientMessage","client","data","parse","type","body","Promise","resolve","all","entryPoints","map","entryPoint","_registerEntryPoint","_config","reporter","update","level","mode","onClientError","e","error","onClientDisconnect","revisionId","group","_clientGroups","get","clients","size","delete","unlisten","_bundler","_createModuleId","Map","server","rewriteRequestUrl","clientUrl","options","Set","resolver","platforms","entryFile","transformOptions","graphOptions","getResolveDependencyFn","getBundler","platform","resolutionFn","resolvedEntryFilePath","_this$_config$server$","unstable_serverRoot","projectRoot","graphId","shallow","experimentalImportBundleSupport","transformer","revPromise","getRevisionByGraphId","graph","id","push","clientGroup","add","protocol","query","dev","minify","runModule","_bundleEntry","bundleEntry","modulesOnly","search","set","getDeltaBundler","listen","_handleFileChange","bind","isInitialUpdate","some","processingHmrChange","action_name","_prepareMessage","outdated_modules","added","length","modified","undefined","getRevision","updateGraph","revision","delta","filter","hmrUpdate","_this$_config$server$2","formattedError","module","exports"],"sources":["/Users/hozaifa/Documents/Uni App Github/node_modules/@react-native-community/cli-plugin-metro/node_modules/metro/src/HmrServer.js"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @format\n *\n */\n\"use strict\";\n\nconst hmrJSBundle = require(\"./DeltaBundler/Serializers/hmrJSBundle\");\n\nconst IncrementalBundler = require(\"./IncrementalBundler\");\n\nconst GraphNotFoundError = require(\"./IncrementalBundler/GraphNotFoundError\");\n\nconst RevisionNotFoundError = require(\"./IncrementalBundler/RevisionNotFoundError\");\n\nconst debounceAsyncQueue = require(\"./lib/debounceAsyncQueue\");\n\nconst formatBundlingError = require(\"./lib/formatBundlingError\");\n\nconst getGraphId = require(\"./lib/getGraphId\");\n\nconst parseOptionsFromUrl = require(\"./lib/parseOptionsFromUrl\");\n\nconst splitBundleOptions = require(\"./lib/splitBundleOptions\");\n\nconst transformHelpers = require(\"./lib/transformHelpers\");\n\nconst {\n  Logger: { createActionStartEntry, createActionEndEntry, log },\n} = require(\"metro-core\");\n\nconst { VERSION: BYTECODE_VERSION } = require(\"metro-hermes-compiler\");\n\nconst nullthrows = require(\"nullthrows\");\n\nconst url = require(\"url\");\n\nfunction send(sendFns, message) {\n  const strMessage = JSON.stringify(message);\n  sendFns.forEach((sendFn) => sendFn(strMessage));\n}\n/**\n * The HmrServer (Hot Module Reloading) implements a lightweight interface\n * to communicate easily to the logic in the React Native repository (which\n * is the one that handles the Web Socket connections).\n *\n * This interface allows the HmrServer to hook its own logic to WS clients\n * getting connected, disconnected or having errors (through the\n * `onClientConnect`, `onClientDisconnect` and `onClientError` methods).\n */\n\nclass HmrServer {\n  constructor(bundler, createModuleId, config) {\n    this._config = config;\n    this._bundler = bundler;\n    this._createModuleId = createModuleId;\n    this._clientGroups = new Map();\n  }\n\n  onClientConnect = async (requestUrl, sendFn) => {\n    return {\n      sendFn,\n      revisionIds: [],\n      optedIntoHMR: false,\n    };\n  };\n\n  async _registerEntryPoint(client, requestUrl, sendFn) {\n    var _this$_config$server$;\n\n    requestUrl = this._config.server.rewriteRequestUrl(requestUrl);\n    const clientUrl = nullthrows(url.parse(requestUrl, true));\n    const options = parseOptionsFromUrl(\n      requestUrl,\n      new Set(this._config.resolver.platforms),\n      BYTECODE_VERSION\n    );\n    const { entryFile, transformOptions, graphOptions } =\n      splitBundleOptions(options);\n    /**\n     * `entryFile` is relative to projectRoot, we need to use resolution function\n     * to find the appropriate file with supported extensions.\n     */\n\n    const resolutionFn = await transformHelpers.getResolveDependencyFn(\n      this._bundler.getBundler(),\n      transformOptions.platform\n    );\n    const resolvedEntryFilePath = resolutionFn(\n      ((_this$_config$server$ = this._config.server.unstable_serverRoot) !==\n        null && _this$_config$server$ !== void 0\n        ? _this$_config$server$\n        : this._config.projectRoot) + \"/.\",\n      entryFile\n    );\n    const graphId = getGraphId(resolvedEntryFilePath, transformOptions, {\n      shallow: graphOptions.shallow,\n      experimentalImportBundleSupport:\n        this._config.transformer.experimentalImportBundleSupport,\n    });\n\n    const revPromise = this._bundler.getRevisionByGraphId(graphId);\n\n    if (!revPromise) {\n      send([sendFn], {\n        type: \"error\",\n        body: formatBundlingError(new GraphNotFoundError(graphId)),\n      });\n      return;\n    }\n\n    const { graph, id } = await revPromise;\n    client.revisionIds.push(id);\n\n    let clientGroup = this._clientGroups.get(id);\n\n    if (clientGroup != null) {\n      clientGroup.clients.add(client);\n    } else {\n      // Prepare the clientUrl to be used as sourceUrl in HMR updates.\n      clientUrl.protocol = \"http\";\n      const {\n        dev,\n        minify,\n        runModule,\n        bundleEntry: _bundleEntry,\n        ...query\n      } = clientUrl.query || {};\n      clientUrl.query = {\n        ...query,\n        dev: dev || \"true\",\n        minify: minify || \"false\",\n        modulesOnly: \"true\",\n        runModule: runModule || \"false\",\n        shallow: \"true\",\n      };\n      clientUrl.search = \"\";\n      clientGroup = {\n        clients: new Set([client]),\n        clientUrl,\n        revisionId: id,\n        unlisten: () => unlisten(),\n      };\n\n      this._clientGroups.set(id, clientGroup);\n\n      const unlisten = this._bundler.getDeltaBundler().listen(\n        graph,\n        debounceAsyncQueue(\n          // $FlowFixMe[method-unbinding] added when improving typing for this parameters\n          this._handleFileChange.bind(this, clientGroup, {\n            isInitialUpdate: false,\n          }),\n          50\n        )\n      );\n    }\n\n    await this._handleFileChange(clientGroup, {\n      isInitialUpdate: true,\n    });\n    send([sendFn], {\n      type: \"bundle-registered\",\n    });\n  }\n\n  onClientMessage = async (client, message, sendFn) => {\n    let data;\n\n    try {\n      data = JSON.parse(message);\n    } catch (error) {\n      send([sendFn], {\n        type: \"error\",\n        body: formatBundlingError(error),\n      });\n      return Promise.resolve();\n    }\n\n    if (data && data.type) {\n      switch (data.type) {\n        case \"register-entrypoints\":\n          return Promise.all(\n            data.entryPoints.map((entryPoint) =>\n              this._registerEntryPoint(client, entryPoint, sendFn)\n            )\n          );\n\n        case \"log\":\n          this._config.reporter.update({\n            type: \"client_log\",\n            level: data.level,\n            data: data.data,\n            mode: data.mode,\n          });\n\n          break;\n\n        case \"log-opt-in\":\n          client.optedIntoHMR = true;\n          break;\n\n        default:\n          break;\n      }\n    }\n\n    return Promise.resolve();\n  };\n  onClientError = (client, e) => {\n    this._config.reporter.update({\n      type: \"hmr_client_error\",\n      error: e.error,\n    });\n\n    this.onClientDisconnect(client);\n  };\n  onClientDisconnect = (client) => {\n    client.revisionIds.forEach((revisionId) => {\n      const group = this._clientGroups.get(revisionId);\n\n      if (group != null) {\n        if (group.clients.size === 1) {\n          this._clientGroups.delete(revisionId);\n\n          group.unlisten();\n        } else {\n          group.clients.delete(client);\n        }\n      }\n    });\n  };\n\n  async _handleFileChange(group, options) {\n    const optedIntoHMR = [...group.clients].some(\n      (client) => client.optedIntoHMR\n    );\n    const processingHmrChange = log(\n      createActionStartEntry({\n        // Even when HMR is disabled on the client, this function still\n        // runs so we can stash updates while it's off and apply them later.\n        // However, this would mess up our internal analytics because we track\n        // HMR as being used even for people who have it disabled.\n        // As a workaround, we use a different event name for clients\n        // that didn't explicitly opt into HMR.\n        action_name: optedIntoHMR\n          ? \"Processing HMR change\"\n          : \"Processing HMR change (no client opt-in)\",\n      })\n    );\n    const sendFns = [...group.clients].map((client) => client.sendFn);\n    send(sendFns, {\n      type: \"update-start\",\n      body: options,\n    });\n    const message = await this._prepareMessage(group, options);\n    send(sendFns, message);\n    send(sendFns, {\n      type: \"update-done\",\n    });\n    log({\n      ...createActionEndEntry(processingHmrChange),\n      outdated_modules:\n        message.type === \"update\"\n          ? message.body.added.length + message.body.modified.length\n          : undefined,\n    });\n  }\n\n  async _prepareMessage(group, options) {\n    try {\n      var _this$_config$server$2;\n\n      const revPromise = this._bundler.getRevision(group.revisionId);\n\n      if (!revPromise) {\n        return {\n          type: \"error\",\n          body: formatBundlingError(\n            new RevisionNotFoundError(group.revisionId)\n          ),\n        };\n      }\n\n      const { revision, delta } = await this._bundler.updateGraph(\n        await revPromise,\n        false\n      );\n\n      this._clientGroups.delete(group.revisionId);\n\n      group.revisionId = revision.id;\n\n      for (const client of group.clients) {\n        client.revisionIds = client.revisionIds.filter(\n          (revisionId) => revisionId !== group.revisionId\n        );\n        client.revisionIds.push(revision.id);\n      }\n\n      this._clientGroups.set(group.revisionId, group);\n\n      const hmrUpdate = hmrJSBundle(delta, revision.graph, {\n        createModuleId: this._createModuleId,\n        projectRoot:\n          (_this$_config$server$2 = this._config.server.unstable_serverRoot) !==\n            null && _this$_config$server$2 !== void 0\n            ? _this$_config$server$2\n            : this._config.projectRoot,\n        clientUrl: group.clientUrl,\n      });\n      return {\n        type: \"update\",\n        body: {\n          revisionId: revision.id,\n          isInitialUpdate: options.isInitialUpdate,\n          ...hmrUpdate,\n        },\n      };\n    } catch (error) {\n      const formattedError = formatBundlingError(error);\n\n      this._config.reporter.update({\n        type: \"bundling_error\",\n        error,\n      });\n\n      return {\n        type: \"error\",\n        body: formattedError,\n      };\n    }\n  }\n}\n\nmodule.exports = HmrServer;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}