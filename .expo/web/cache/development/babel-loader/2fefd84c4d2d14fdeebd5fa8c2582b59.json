{"ast":null,"code":"\"use strict\";\n\nvar _objectWithoutProperties = require(\"@babel/runtime/helpers/objectWithoutProperties\");\n\nvar _classCallCheck = require(\"@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"@babel/runtime/helpers/createClass\");\n\nvar _inherits = require(\"@babel/runtime/helpers/inherits\");\n\nvar _possibleConstructorReturn = require(\"@babel/runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"@babel/runtime/helpers/getPrototypeOf\");\n\nvar _excluded = [\"comments\"];\n\nfunction _createForOfIteratorHelperLoose(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (it) return (it = it.call(o)).next.bind(it); if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _HermesASTAdapter = _interopRequireDefault(require(\"./HermesASTAdapter\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nvar HermesToBabelAdapter = function (_HermesASTAdapter$def) {\n  _inherits(HermesToBabelAdapter, _HermesASTAdapter$def);\n\n  var _super = _createSuper(HermesToBabelAdapter);\n\n  function HermesToBabelAdapter() {\n    _classCallCheck(this, HermesToBabelAdapter);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(HermesToBabelAdapter, [{\n    key: \"fixSourceLocation\",\n    value: function fixSourceLocation(node) {\n      var _this$sourceFilename;\n\n      var loc = node.loc;\n\n      if (loc == null) {\n        return;\n      }\n\n      node.loc = {\n        source: (_this$sourceFilename = this.sourceFilename) != null ? _this$sourceFilename : null,\n        start: loc.start,\n        end: loc.end\n      };\n      node.start = loc.rangeStart;\n      node.end = loc.rangeEnd;\n    }\n  }, {\n    key: \"mapNode\",\n    value: function mapNode(node) {\n      this.fixSourceLocation(node);\n\n      switch (node.type) {\n        case 'Program':\n          return this.mapProgram(node);\n\n        case 'BlockStatement':\n          return this.mapNodeWithDirectives(node);\n\n        case 'Empty':\n          return this.mapEmpty(node);\n\n        case 'Identifier':\n          return this.mapIdentifier(node);\n\n        case 'TemplateElement':\n          return this.mapTemplateElement(node);\n\n        case 'GenericTypeAnnotation':\n          return this.mapGenericTypeAnnotation(node);\n\n        case 'SymbolTypeAnnotation':\n          return this.mapSymbolTypeAnnotation(node);\n\n        case 'Property':\n          return this.mapProperty(node);\n\n        case 'MethodDefinition':\n          return this.mapMethodDefinition(node);\n\n        case 'ImportDeclaration':\n          return this.mapImportDeclaration(node);\n\n        case 'ImportSpecifier':\n          return this.mapImportSpecifier(node);\n\n        case 'ExportDefaultDeclaration':\n          return this.mapExportDefaultDeclaration(node);\n\n        case 'ExportNamedDeclaration':\n          return this.mapExportNamedDeclaration(node);\n\n        case 'ExportAllDeclaration':\n          return this.mapExportAllDeclaration(node);\n\n        case 'RestElement':\n          return this.mapRestElement(node);\n\n        case 'ImportExpression':\n          return this.mapImportExpression(node);\n\n        case 'JSXStringLiteral':\n          return this.mapJSXStringLiteral(node);\n\n        case 'PrivateName':\n        case 'ClassPrivateProperty':\n          return this.mapPrivateProperty(node);\n\n        case 'FunctionDeclaration':\n        case 'FunctionExpression':\n          return this.mapFunction(node);\n\n        case 'IndexedAccessType':\n        case 'OptionalIndexedAccessType':\n          return this.mapUnsupportedTypeAnnotation(node);\n\n        default:\n          return this.mapNodeDefault(node);\n      }\n    }\n  }, {\n    key: \"mapProgram\",\n    value: function mapProgram(node) {\n      var _this$mapNodeWithDire = this.mapNodeWithDirectives(node),\n          comments = _this$mapNodeWithDire.comments,\n          program = _objectWithoutProperties(_this$mapNodeWithDire, _excluded);\n\n      program.sourceType = this.getSourceType();\n      program.loc.start = {\n        line: 1,\n        column: 0\n      };\n      program.start = 0;\n\n      if (comments.length > 0) {\n        var lastComment = comments[comments.length - 1];\n\n        if (lastComment.end > program.end) {\n          program.loc.end = lastComment.loc.end;\n          program.end = lastComment.end;\n        }\n      }\n\n      return {\n        type: 'File',\n        loc: program.loc,\n        start: program.start,\n        end: program.end,\n        program: program,\n        comments: comments\n      };\n    }\n  }, {\n    key: \"mapNodeWithDirectives\",\n    value: function mapNodeWithDirectives(node) {\n      var directives = [];\n\n      for (var _iterator = _createForOfIteratorHelperLoose(node.body), _step; !(_step = _iterator()).done;) {\n        var child = _step.value;\n\n        if (child.type === 'ExpressionStatement' && child.directive != null) {\n          var directiveChild = this.mapNode(child);\n          directiveChild.expression.type = 'DirectiveLiteral';\n          directives.push({\n            type: 'Directive',\n            loc: directiveChild.loc,\n            start: directiveChild.start,\n            end: directiveChild.end,\n            value: directiveChild.expression\n          });\n        } else {\n          break;\n        }\n      }\n\n      node.directives = directives;\n\n      if (directives.length !== 0) {\n        node.body = node.body.slice(directives.length);\n      }\n\n      var body = node.body;\n\n      for (var i = 0; i < body.length; i++) {\n        var _child = body[i];\n\n        if (_child != null) {\n          body[i] = this.mapNode(_child);\n        }\n      }\n\n      return node;\n    }\n  }, {\n    key: \"mapIdentifier\",\n    value: function mapIdentifier(node) {\n      node.loc.identifierName = node.name;\n      return this.mapNodeDefault(node);\n    }\n  }, {\n    key: \"mapTemplateElement\",\n    value: function mapTemplateElement(node) {\n      var startCharsToExclude = 1;\n      var endCharsToExclude = node.tail ? 1 : 2;\n      return {\n        type: 'TemplateElement',\n        loc: {\n          start: {\n            line: node.loc.start.line,\n            column: node.loc.start.column + startCharsToExclude\n          },\n          end: {\n            line: node.loc.end.line,\n            column: node.loc.end.column - endCharsToExclude\n          }\n        },\n        start: node.start + startCharsToExclude,\n        end: node.end - endCharsToExclude,\n        tail: node.tail,\n        value: {\n          cooked: node.cooked,\n          raw: node.raw\n        }\n      };\n    }\n  }, {\n    key: \"mapGenericTypeAnnotation\",\n    value: function mapGenericTypeAnnotation(node) {\n      if (node.typeParameters == null && node.id.type === 'Identifier' && node.id.name === 'this') {\n        return {\n          type: 'ThisTypeAnnotation',\n          loc: node.loc,\n          start: node.start,\n          end: node.end\n        };\n      }\n\n      return this.mapNodeDefault(node);\n    }\n  }, {\n    key: \"mapSymbolTypeAnnotation\",\n    value: function mapSymbolTypeAnnotation(node) {\n      return {\n        type: 'GenericTypeAnnotation',\n        loc: node.loc,\n        start: node.start,\n        end: node.end,\n        id: {\n          type: 'Identifier',\n          loc: node.loc,\n          start: node.start,\n          end: node.end,\n          name: 'symbol'\n        },\n        typeParameters: null\n      };\n    }\n  }, {\n    key: \"mapProperty\",\n    value: function mapProperty(node) {\n      var key = this.mapNode(node.key);\n      var value = this.mapNode(node.value);\n\n      if (node.method || node.kind !== 'init') {\n        var id = value.id,\n            params = value.params,\n            body = value.body,\n            async = value.async,\n            generator = value.generator,\n            returnType = value.returnType,\n            typeParameters = value.typeParameters,\n            predicate = value.predicate;\n        return {\n          type: 'ObjectMethod',\n          loc: node.loc,\n          start: node.start,\n          end: node.end,\n          kind: node.kind === 'init' ? 'method' : node.kind,\n          computed: node.computed,\n          key: key,\n          id: id,\n          params: params,\n          body: body,\n          async: async,\n          generator: generator,\n          returnType: returnType,\n          typeParameters: typeParameters,\n          predicate: predicate\n        };\n      } else {\n        node.type = 'ObjectProperty';\n        return node;\n      }\n    }\n  }, {\n    key: \"mapMethodDefinition\",\n    value: function mapMethodDefinition(node) {\n      var key = this.mapNode(node.key);\n      var value = this.mapNode(node.value);\n      var id = value.id,\n          params = value.params,\n          body = value.body,\n          async = value.async,\n          generator = value.generator,\n          returnType = value.returnType,\n          typeParameters = value.typeParameters,\n          predicate = value.predicate;\n      return {\n        type: 'ClassMethod',\n        loc: node.loc,\n        start: node.start,\n        end: node.end,\n        kind: node.kind,\n        computed: node.computed,\n        static: node.static,\n        key: key,\n        id: id,\n        params: params,\n        body: body,\n        async: async,\n        generator: generator,\n        returnType: returnType,\n        typeParameters: typeParameters,\n        predicate: predicate\n      };\n    }\n  }, {\n    key: \"mapRestElement\",\n    value: function mapRestElement(node) {\n      var restElement = this.mapNodeDefault(node);\n      var annotation = restElement.argument.typeAnnotation;\n\n      if (annotation != null) {\n        restElement.typeAnnotation = annotation;\n        restElement.argument.typeAnnotation = null;\n      }\n\n      return restElement;\n    }\n  }, {\n    key: \"mapImportExpression\",\n    value: function mapImportExpression(node) {\n      return {\n        type: 'CallExpression',\n        loc: node.loc,\n        start: node.start,\n        end: node.end,\n        callee: {\n          type: 'Import',\n          loc: node.loc,\n          start: node.start,\n          end: node.end\n        },\n        arguments: [this.mapNode(node.source)]\n      };\n    }\n  }, {\n    key: \"mapJSXStringLiteral\",\n    value: function mapJSXStringLiteral(node) {\n      return {\n        type: 'StringLiteral',\n        loc: node.loc,\n        start: node.start,\n        end: node.end,\n        value: node.value\n      };\n    }\n  }, {\n    key: \"mapFunction\",\n    value: function mapFunction(node) {\n      if (node.params.length !== 0 && node.params[0].name === 'this') {\n        node.params.shift();\n      }\n\n      return this.mapNodeDefault(node);\n    }\n  }, {\n    key: \"mapUnsupportedTypeAnnotation\",\n    value: function mapUnsupportedTypeAnnotation(node) {\n      return {\n        type: 'AnyTypeAnnotation',\n        loc: node.loc,\n        start: node.start,\n        end: node.end\n      };\n    }\n  }]);\n\n  return HermesToBabelAdapter;\n}(_HermesASTAdapter.default);\n\nexports.default = HermesToBabelAdapter;","map":{"version":3,"names":["Object","defineProperty","exports","value","default","_HermesASTAdapter","_interopRequireDefault","require","obj","__esModule","HermesToBabelAdapter","node","_this$sourceFilename","loc","source","sourceFilename","start","end","rangeStart","rangeEnd","fixSourceLocation","type","mapProgram","mapNodeWithDirectives","mapEmpty","mapIdentifier","mapTemplateElement","mapGenericTypeAnnotation","mapSymbolTypeAnnotation","mapProperty","mapMethodDefinition","mapImportDeclaration","mapImportSpecifier","mapExportDefaultDeclaration","mapExportNamedDeclaration","mapExportAllDeclaration","mapRestElement","mapImportExpression","mapJSXStringLiteral","mapPrivateProperty","mapFunction","mapUnsupportedTypeAnnotation","mapNodeDefault","comments","program","sourceType","getSourceType","line","column","length","lastComment","directives","body","child","directive","directiveChild","mapNode","expression","push","slice","i","identifierName","name","startCharsToExclude","endCharsToExclude","tail","cooked","raw","typeParameters","id","key","method","kind","params","async","generator","returnType","predicate","computed","static","restElement","annotation","argument","typeAnnotation","callee","arguments","shift"],"sources":["/Users/hozaifa/Documents/Uni App Github/node_modules/@react-native-community/cli-plugin-metro/node_modules/hermes-parser/dist/HermesToBabelAdapter.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _HermesASTAdapter = _interopRequireDefault(require(\"./HermesASTAdapter\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n */\n\n/*\nThis class does some very \"javascripty\" things in the name of\nperformance which are ultimately impossible to soundly type.\n\nSo instead of adding strict types and a large number of suppression\ncomments, instead it is left untyped and subclasses are strictly\ntyped via a separate flow declaration file.\n*/\nclass HermesToBabelAdapter extends _HermesASTAdapter.default {\n  fixSourceLocation(node) {\n    var _this$sourceFilename;\n\n    const loc = node.loc;\n\n    if (loc == null) {\n      return;\n    }\n\n    node.loc = {\n      source: (_this$sourceFilename = this.sourceFilename) != null ? _this$sourceFilename : null,\n      start: loc.start,\n      end: loc.end\n    };\n    node.start = loc.rangeStart;\n    node.end = loc.rangeEnd;\n  }\n\n  mapNode(node) {\n    this.fixSourceLocation(node);\n\n    switch (node.type) {\n      case 'Program':\n        return this.mapProgram(node);\n\n      case 'BlockStatement':\n        return this.mapNodeWithDirectives(node);\n\n      case 'Empty':\n        return this.mapEmpty(node);\n\n      case 'Identifier':\n        return this.mapIdentifier(node);\n\n      case 'TemplateElement':\n        return this.mapTemplateElement(node);\n\n      case 'GenericTypeAnnotation':\n        return this.mapGenericTypeAnnotation(node);\n\n      case 'SymbolTypeAnnotation':\n        return this.mapSymbolTypeAnnotation(node);\n\n      case 'Property':\n        return this.mapProperty(node);\n\n      case 'MethodDefinition':\n        return this.mapMethodDefinition(node);\n\n      case 'ImportDeclaration':\n        return this.mapImportDeclaration(node);\n\n      case 'ImportSpecifier':\n        return this.mapImportSpecifier(node);\n\n      case 'ExportDefaultDeclaration':\n        return this.mapExportDefaultDeclaration(node);\n\n      case 'ExportNamedDeclaration':\n        return this.mapExportNamedDeclaration(node);\n\n      case 'ExportAllDeclaration':\n        return this.mapExportAllDeclaration(node);\n\n      case 'RestElement':\n        return this.mapRestElement(node);\n\n      case 'ImportExpression':\n        return this.mapImportExpression(node);\n\n      case 'JSXStringLiteral':\n        return this.mapJSXStringLiteral(node);\n\n      case 'PrivateName':\n      case 'ClassPrivateProperty':\n        return this.mapPrivateProperty(node);\n\n      case 'FunctionDeclaration':\n      case 'FunctionExpression':\n        return this.mapFunction(node);\n\n      case 'IndexedAccessType':\n      case 'OptionalIndexedAccessType':\n        return this.mapUnsupportedTypeAnnotation(node);\n\n      default:\n        return this.mapNodeDefault(node);\n    }\n  }\n\n  mapProgram(node) {\n    // Visit child nodes and convert to directives\n    const {\n      comments,\n      ...program\n    } = this.mapNodeWithDirectives(node);\n    program.sourceType = this.getSourceType(); // Adjust start loc to beginning of file\n\n    program.loc.start = {\n      line: 1,\n      column: 0\n    };\n    program.start = 0; // Adjust end loc to include last comment if program ends with a comment\n\n    if (comments.length > 0) {\n      const lastComment = comments[comments.length - 1];\n\n      if (lastComment.end > program.end) {\n        program.loc.end = lastComment.loc.end;\n        program.end = lastComment.end;\n      }\n    } // Rename root node to File node and move Program node under program property\n\n\n    return {\n      type: 'File',\n      loc: program.loc,\n      start: program.start,\n      end: program.end,\n      program,\n      comments\n    };\n  }\n\n  mapNodeWithDirectives(node) {\n    const directives = [];\n\n    for (const child of node.body) {\n      if (child.type === 'ExpressionStatement' && child.directive != null) {\n        // Visit directive children\n        const directiveChild = this.mapNode(child); // Modify string literal node to be DirectiveLiteral node\n\n        directiveChild.expression.type = 'DirectiveLiteral'; // Construct Directive node with DirectiveLiteral value\n\n        directives.push({\n          type: 'Directive',\n          loc: directiveChild.loc,\n          start: directiveChild.start,\n          end: directiveChild.end,\n          value: directiveChild.expression\n        });\n      } else {\n        // Once we have found the first non-directive node we know there cannot be any more directives\n        break;\n      }\n    } // Move directives from body to new directives array\n\n\n    node.directives = directives;\n\n    if (directives.length !== 0) {\n      node.body = node.body.slice(directives.length);\n    } // Visit expression statement children\n\n\n    const body = node.body;\n\n    for (let i = 0; i < body.length; i++) {\n      const child = body[i];\n\n      if (child != null) {\n        body[i] = this.mapNode(child);\n      }\n    }\n\n    return node;\n  }\n\n  mapIdentifier(node) {\n    node.loc.identifierName = node.name;\n    return this.mapNodeDefault(node);\n  }\n\n  mapTemplateElement(node) {\n    // Adjust start loc to exclude \"`\" at beginning of template literal if this is the first quasi,\n    // otherwise exclude \"}\" from previous expression.\n    const startCharsToExclude = 1; // Adjust end loc to exclude \"`\" at end of template literal if this is the last quasi,\n    // otherwise exclude \"${\" from next expression.\n\n    const endCharsToExclude = node.tail ? 1 : 2;\n    return {\n      type: 'TemplateElement',\n      loc: {\n        start: {\n          line: node.loc.start.line,\n          column: node.loc.start.column + startCharsToExclude\n        },\n        end: {\n          line: node.loc.end.line,\n          column: node.loc.end.column - endCharsToExclude\n        }\n      },\n      start: node.start + startCharsToExclude,\n      end: node.end - endCharsToExclude,\n      tail: node.tail,\n      value: {\n        cooked: node.cooked,\n        raw: node.raw\n      }\n    };\n  }\n\n  mapGenericTypeAnnotation(node) {\n    // Convert simple `this` generic type to ThisTypeAnnotation\n    if (node.typeParameters == null && node.id.type === 'Identifier' && node.id.name === 'this') {\n      return {\n        type: 'ThisTypeAnnotation',\n        loc: node.loc,\n        start: node.start,\n        end: node.end\n      };\n    }\n\n    return this.mapNodeDefault(node);\n  }\n\n  mapSymbolTypeAnnotation(node) {\n    return {\n      type: 'GenericTypeAnnotation',\n      loc: node.loc,\n      start: node.start,\n      end: node.end,\n      id: {\n        type: 'Identifier',\n        loc: node.loc,\n        start: node.start,\n        end: node.end,\n        name: 'symbol'\n      },\n      typeParameters: null\n    };\n  }\n\n  mapProperty(node) {\n    const key = this.mapNode(node.key);\n    const value = this.mapNode(node.value); // Convert methods, getters, and setters to ObjectMethod nodes\n\n    if (node.method || node.kind !== 'init') {\n      // Properties under the FunctionExpression value that should be moved\n      // to the ObjectMethod node itself.\n      const {\n        id,\n        params,\n        body,\n        async,\n        generator,\n        returnType,\n        typeParameters,\n        predicate\n      } = value;\n      return {\n        type: 'ObjectMethod',\n        loc: node.loc,\n        start: node.start,\n        end: node.end,\n        // Non getter or setter methods have `kind = method`\n        kind: node.kind === 'init' ? 'method' : node.kind,\n        computed: node.computed,\n        key,\n        id,\n        params,\n        body,\n        async,\n        generator,\n        returnType,\n        typeParameters,\n        predicate\n      };\n    } else {\n      // Non-method property nodes should be renamed to ObjectProperty\n      node.type = 'ObjectProperty';\n      return node;\n    }\n  }\n\n  mapMethodDefinition(node) {\n    const key = this.mapNode(node.key);\n    const value = this.mapNode(node.value); // Properties under the FunctionExpression value that should be moved\n    // to the ClassMethod node itself.\n\n    const {\n      id,\n      params,\n      body,\n      async,\n      generator,\n      returnType,\n      typeParameters,\n      predicate\n    } = value;\n    return {\n      type: 'ClassMethod',\n      loc: node.loc,\n      start: node.start,\n      end: node.end,\n      kind: node.kind,\n      computed: node.computed,\n      static: node.static,\n      key,\n      id,\n      params,\n      body,\n      async,\n      generator,\n      returnType,\n      typeParameters,\n      predicate\n    };\n  }\n\n  mapRestElement(node) {\n    const restElement = this.mapNodeDefault(node); // Hermes puts type annotations on rest elements on the argument node,\n    // but Babel expects type annotations on the rest element node itself.\n\n    const annotation = restElement.argument.typeAnnotation;\n\n    if (annotation != null) {\n      restElement.typeAnnotation = annotation;\n      restElement.argument.typeAnnotation = null;\n    }\n\n    return restElement;\n  }\n\n  mapImportExpression(node) {\n    // Babel expects ImportExpression to be structued as a regular\n    // CallExpression where the callee is an Import node.\n    return {\n      type: 'CallExpression',\n      loc: node.loc,\n      start: node.start,\n      end: node.end,\n      callee: {\n        type: 'Import',\n        loc: node.loc,\n        start: node.start,\n        end: node.end\n      },\n      arguments: [this.mapNode(node.source)]\n    };\n  }\n\n  mapJSXStringLiteral(node) {\n    // Babel expects StringLiterals in JSX,\n    // but Hermes uses JSXStringLiteral to attach the raw value without\n    // having to internally attach it to every single string literal.\n    return {\n      type: 'StringLiteral',\n      loc: node.loc,\n      start: node.start,\n      end: node.end,\n      value: node.value\n    };\n  }\n\n  mapFunction(node) {\n    // Remove the first parameter if it is a this-type annotation,\n    // which is not recognized by Babel.\n    if (node.params.length !== 0 && node.params[0].name === 'this') {\n      node.params.shift();\n    }\n\n    return this.mapNodeDefault(node);\n  }\n  /**\n   * If Babel (the version we target) does not support a type annotation we\n   * parse, we need to return some other valid type annotation in its place.\n   */\n\n\n  mapUnsupportedTypeAnnotation(node) {\n    return {\n      type: 'AnyTypeAnnotation',\n      loc: node.loc,\n      start: node.start,\n      end: node.end\n    };\n  }\n\n}\n\nexports.default = HermesToBabelAdapter;"],"mappings":"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"},"metadata":{},"sourceType":"script"}