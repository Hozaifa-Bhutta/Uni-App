{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"@babel/runtime/helpers/createClass\");\n\nvar _slicedToArray = require(\"@babel/runtime/helpers/slicedToArray\");\n\nvar _toConsumableArray = require(\"@babel/runtime/helpers/toConsumableArray\");\n\nvar _traverse = _interopRequireDefault(require(\"@babel/traverse\"));\n\nvar _types = require(\"@babel/types\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nvar B64Builder = require(\"./B64Builder\");\n\nvar t = require(\"@babel/types\");\n\nvar nullthrows = require(\"nullthrows\");\n\nvar fsPath = require(\"path\");\n\nfunction generateFunctionMap(ast, context) {\n  var encoder = new MappingEncoder();\n  forEachMapping(ast, context, function (mapping) {\n    return encoder.push(mapping);\n  });\n  return encoder.getResult();\n}\n\nfunction generateFunctionMappingsArray(ast, context) {\n  var mappings = [];\n  forEachMapping(ast, context, function (mapping) {\n    mappings.push(mapping);\n  });\n  return mappings;\n}\n\nfunction forEachMapping(ast, context, pushMapping) {\n  var nameStack = [];\n  var tailPos = {\n    line: 1,\n    column: 0\n  };\n  var tailName = null;\n\n  function advanceToPos(pos) {\n    if (tailPos && positionGreater(pos, tailPos)) {\n      var name = nameStack[0].name;\n\n      if (name !== tailName) {\n        pushMapping({\n          name: name,\n          start: {\n            line: tailPos.line,\n            column: tailPos.column\n          }\n        });\n        tailName = name;\n      }\n    }\n\n    tailPos = pos;\n  }\n\n  function pushFrame(name, loc) {\n    advanceToPos(loc.start);\n    nameStack.unshift({\n      name: name,\n      loc: loc\n    });\n  }\n\n  function popFrame() {\n    var top = nameStack[0];\n\n    if (top) {\n      var loc = top.loc;\n      advanceToPos(loc.end);\n      nameStack.shift();\n    }\n  }\n\n  if (!context) {\n    context = {};\n  }\n\n  var basename = context.filename ? fsPath.basename(context.filename).replace(/\\..+$/, \"\") : null;\n  var visitor = {\n    enter: function enter(path) {\n      var name = getNameForPath(path);\n\n      if (basename) {\n        name = removeNamePrefix(name, basename);\n      }\n\n      pushFrame(name, nullthrows(path.node.loc));\n    },\n    exit: function exit(path) {\n      popFrame();\n    }\n  };\n  (0, _traverse.default)(ast, {\n    Function: visitor,\n    Program: visitor,\n    Class: visitor\n  });\n}\n\nvar ANONYMOUS_NAME = \"<anonymous>\";\n\nfunction getNameForPath(path) {\n  var node = path.node,\n      parent = path.parent,\n      parentPath = path.parentPath;\n\n  if ((0, _types.isProgram)(node)) {\n    return \"<global>\";\n  }\n\n  var id = path.id;\n\n  if (node.id) {\n    return node.id.name;\n  }\n\n  var propertyPath;\n  var kind = \"\";\n\n  if ((0, _types.isObjectMethod)(node) || (0, _types.isClassMethod)(node)) {\n    id = node.key;\n\n    if (node.kind !== \"method\" && node.kind !== \"constructor\") {\n      kind = node.kind;\n    }\n\n    propertyPath = path;\n  } else if ((0, _types.isObjectProperty)(parent) || (0, _types.isClassProperty)(parent)) {\n    id = parent.key;\n    propertyPath = parentPath;\n  } else if ((0, _types.isVariableDeclarator)(parent)) {\n    id = parent.id;\n  } else if ((0, _types.isAssignmentExpression)(parent)) {\n    id = parent.left;\n  } else if ((0, _types.isJSXExpressionContainer)(parent)) {\n    var _parentPath$parentPat;\n\n    var grandParentNode = parentPath === null || parentPath === void 0 ? void 0 : (_parentPath$parentPat = parentPath.parentPath) === null || _parentPath$parentPat === void 0 ? void 0 : _parentPath$parentPat.node;\n\n    if ((0, _types.isJSXElement)(grandParentNode)) {\n      var openingElement = grandParentNode.openingElement;\n      id = t.jsxMemberExpression(t.jsxMemberExpression(openingElement.name, t.jsxIdentifier(\"props\")), t.jsxIdentifier(\"children\"));\n    } else if ((0, _types.isJSXAttribute)(grandParentNode)) {\n      var _parentPath$parentPat2, _parentPath$parentPat3;\n\n      var _openingElement = parentPath === null || parentPath === void 0 ? void 0 : (_parentPath$parentPat2 = parentPath.parentPath) === null || _parentPath$parentPat2 === void 0 ? void 0 : (_parentPath$parentPat3 = _parentPath$parentPat2.parentPath) === null || _parentPath$parentPat3 === void 0 ? void 0 : _parentPath$parentPat3.node;\n\n      var prop = grandParentNode;\n      id = t.jsxMemberExpression(t.jsxMemberExpression(_openingElement.name, t.jsxIdentifier(\"props\")), prop.name);\n    }\n  }\n\n  var name = getNameFromId(id);\n\n  if (name == null) {\n    if (isAnyCallExpression(parent)) {\n      var argIndex = parent.arguments.indexOf(node);\n\n      if (argIndex !== -1) {\n        var calleeName = getNameFromId(parent.callee);\n\n        if (argIndex === 0 && calleeName === \"Object.freeze\") {\n          return getNameForPath(nullthrows(parentPath));\n        }\n\n        if (argIndex === 0 && (calleeName === \"useCallback\" || calleeName === \"React.useCallback\")) {\n          return getNameForPath(nullthrows(parentPath));\n        }\n\n        if (calleeName) {\n          return calleeName + \"$argument_\" + argIndex;\n        }\n      }\n    }\n\n    if ((0, _types.isTypeCastExpression)(parent) && parent.expression === node) {\n      return getNameForPath(nullthrows(parentPath));\n    }\n\n    if ((0, _types.isExportDefaultDeclaration)(parent)) {\n      return \"default\";\n    }\n\n    return ANONYMOUS_NAME;\n  }\n\n  if (kind) {\n    name = kind + \"__\" + name;\n  }\n\n  if (propertyPath) {\n    if ((0, _types.isClassBody)(propertyPath.parent)) {\n      var className = getNameForPath(propertyPath.parentPath.parentPath);\n\n      if (className !== ANONYMOUS_NAME) {\n        var separator = propertyPath.node.static ? \".\" : \"#\";\n        name = className + separator + name;\n      }\n    } else if ((0, _types.isObjectExpression)(propertyPath.parent)) {\n      var objectName = getNameForPath(nullthrows(propertyPath.parentPath));\n\n      if (objectName !== ANONYMOUS_NAME) {\n        name = objectName + \".\" + name;\n      }\n    }\n  }\n\n  return name;\n}\n\nfunction isAnyCallExpression(node) {\n  return node.type === \"CallExpression\" || node.type === \"NewExpression\" || node.type === \"OptionalCallExpression\";\n}\n\nfunction isAnyMemberExpression(node) {\n  return node.type === \"MemberExpression\" || node.type === \"JSXMemberExpression\" || node.type === \"OptionalMemberExpression\";\n}\n\nfunction isAnyIdentifier(node) {\n  return (0, _types.isIdentifier)(node) || (0, _types.isJSXIdentifier)(node);\n}\n\nfunction getNameFromId(id) {\n  var parts = getNamePartsFromId(id);\n\n  if (!parts.length) {\n    return null;\n  }\n\n  if (parts.length > 5) {\n    return parts[0] + \".\" + parts[1] + \"...\" + parts[parts.length - 2] + \".\" + parts[parts.length - 1];\n  }\n\n  return parts.join(\".\");\n}\n\nfunction getNamePartsFromId(id) {\n  if (!id) {\n    return [];\n  }\n\n  if (isAnyCallExpression(id)) {\n    return getNamePartsFromId(id.callee);\n  }\n\n  if ((0, _types.isTypeCastExpression)(id)) {\n    return getNamePartsFromId(id.expression);\n  }\n\n  var name;\n\n  if (isAnyIdentifier(id)) {\n    name = id.name;\n  } else if ((0, _types.isNullLiteral)(id)) {\n    name = \"null\";\n  } else if ((0, _types.isRegExpLiteral)(id)) {\n    var _id$flags;\n\n    name = \"_\" + id.pattern + \"_\" + ((_id$flags = id.flags) !== null && _id$flags !== void 0 ? _id$flags : \"\");\n  } else if ((0, _types.isTemplateLiteral)(id)) {\n    name = id.quasis.map(function (quasi) {\n      return quasi.value.raw;\n    }).join(\"\");\n  } else if ((0, _types.isLiteral)(id) && id.value != null) {\n    name = String(id.value);\n  }\n\n  if (name != null) {\n    return [t.toBindingIdentifierName(name)];\n  }\n\n  if ((0, _types.isImport)(id)) {\n    name = \"import\";\n  }\n\n  if (name != null) {\n    return [name];\n  }\n\n  if (isAnyMemberExpression(id)) {\n    if (isAnyIdentifier(id.object) && id.object.name === \"Symbol\" && (isAnyIdentifier(id.property) || (0, _types.isLiteral)(id.property))) {\n      var propertyName = getNameFromId(id.property);\n\n      if (propertyName) {\n        name = \"@@\" + propertyName;\n      }\n    } else {\n      var _propertyName = getNamePartsFromId(id.property);\n\n      if (_propertyName.length) {\n        var objectName = getNamePartsFromId(id.object);\n\n        if (objectName.length) {\n          return [].concat(_toConsumableArray(objectName), _toConsumableArray(_propertyName));\n        } else {\n          return _propertyName;\n        }\n      }\n    }\n  }\n\n  return name ? [name] : [];\n}\n\nvar DELIMITER_START_RE = /^[^A-Za-z0-9_$@]+/;\n\nfunction removeNamePrefix(name, namePrefix) {\n  if (!namePrefix.length || !name.startsWith(namePrefix)) {\n    return name;\n  }\n\n  var shortenedName = name.substr(namePrefix.length);\n\n  var _ref = shortenedName.match(DELIMITER_START_RE) || [],\n      _ref2 = _slicedToArray(_ref, 1),\n      delimiterMatch = _ref2[0];\n\n  if (delimiterMatch) {\n    return shortenedName.substr(delimiterMatch.length) || name;\n  }\n\n  return name;\n}\n\nvar MappingEncoder = function () {\n  function MappingEncoder() {\n    _classCallCheck(this, MappingEncoder);\n\n    this._namesMap = new Map();\n    this._names = [];\n    this._line = new RelativeValue(1);\n    this._column = new RelativeValue(0);\n    this._nameIndex = new RelativeValue(0);\n    this._mappings = new B64Builder();\n  }\n\n  _createClass(MappingEncoder, [{\n    key: \"getResult\",\n    value: function getResult() {\n      return {\n        names: this._names,\n        mappings: this._mappings.toString()\n      };\n    }\n  }, {\n    key: \"push\",\n    value: function push(_ref3) {\n      var name = _ref3.name,\n          start = _ref3.start;\n\n      var nameIndex = this._namesMap.get(name);\n\n      if (typeof nameIndex !== \"number\") {\n        nameIndex = this._names.length;\n        this._names[nameIndex] = name;\n\n        this._namesMap.set(name, nameIndex);\n      }\n\n      var lineDelta = this._line.next(start.line);\n\n      var firstOfLine = this._mappings.pos === 0 || lineDelta > 0;\n\n      if (lineDelta > 0) {\n        this._mappings.markLines(1);\n\n        this._column.reset(0);\n      }\n\n      this._mappings.startSegment(this._column.next(start.column));\n\n      this._mappings.append(this._nameIndex.next(nameIndex));\n\n      if (firstOfLine) {\n        this._mappings.append(lineDelta);\n      }\n    }\n  }]);\n\n  return MappingEncoder;\n}();\n\nvar RelativeValue = function () {\n  function RelativeValue() {\n    var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n\n    _classCallCheck(this, RelativeValue);\n\n    this.reset(value);\n  }\n\n  _createClass(RelativeValue, [{\n    key: \"next\",\n    value: function next(absoluteValue) {\n      var delta = absoluteValue - this._value;\n      this._value = absoluteValue;\n      return delta;\n    }\n  }, {\n    key: \"reset\",\n    value: function reset() {\n      var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      this._value = value;\n    }\n  }]);\n\n  return RelativeValue;\n}();\n\nfunction positionGreater(x, y) {\n  return x.line > y.line || x.line === y.line && x.column > y.column;\n}\n\nmodule.exports = {\n  generateFunctionMap: generateFunctionMap,\n  generateFunctionMappingsArray: generateFunctionMappingsArray\n};","map":{"version":3,"names":["_traverse","_interopRequireDefault","require","_types","obj","__esModule","default","B64Builder","t","nullthrows","fsPath","generateFunctionMap","ast","context","encoder","MappingEncoder","forEachMapping","mapping","push","getResult","generateFunctionMappingsArray","mappings","pushMapping","nameStack","tailPos","line","column","tailName","advanceToPos","pos","positionGreater","name","start","pushFrame","loc","unshift","popFrame","top","end","shift","basename","filename","replace","visitor","enter","path","getNameForPath","removeNamePrefix","node","exit","Function","Program","Class","ANONYMOUS_NAME","parent","parentPath","isProgram","id","propertyPath","kind","isObjectMethod","isClassMethod","key","isObjectProperty","isClassProperty","isVariableDeclarator","isAssignmentExpression","left","isJSXExpressionContainer","_parentPath$parentPat","grandParentNode","isJSXElement","openingElement","jsxMemberExpression","jsxIdentifier","isJSXAttribute","_parentPath$parentPat2","_parentPath$parentPat3","prop","getNameFromId","isAnyCallExpression","argIndex","arguments","indexOf","calleeName","callee","isTypeCastExpression","expression","isExportDefaultDeclaration","isClassBody","className","separator","static","isObjectExpression","objectName","type","isAnyMemberExpression","isAnyIdentifier","isIdentifier","isJSXIdentifier","parts","getNamePartsFromId","length","join","isNullLiteral","isRegExpLiteral","_id$flags","pattern","flags","isTemplateLiteral","quasis","map","quasi","value","raw","isLiteral","String","toBindingIdentifierName","isImport","object","property","propertyName","DELIMITER_START_RE","namePrefix","startsWith","shortenedName","substr","match","delimiterMatch","_namesMap","Map","_names","_line","RelativeValue","_column","_nameIndex","_mappings","names","toString","nameIndex","get","set","lineDelta","next","firstOfLine","markLines","reset","startSegment","append","absoluteValue","delta","_value","x","y","module","exports"],"sources":["/Users/hozaifa/Documents/Uni App Github/node_modules/@react-native-community/cli-plugin-metro/node_modules/metro-source-map/src/generateFunctionMap.js"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *\n * @format\n */\n\"use strict\";\n\nvar _traverse = _interopRequireDefault(require(\"@babel/traverse\"));\n\nvar _types = require(\"@babel/types\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : { default: obj };\n}\n\nconst B64Builder = require(\"./B64Builder\");\n\nconst t = require(\"@babel/types\");\n\nconst nullthrows = require(\"nullthrows\");\n\nconst fsPath = require(\"path\");\n\n/**\n * Generate a map of source positions to function names. The names are meant to\n * describe the stack frame in an error trace and may contain more contextual\n * information than just the actual name of the function.\n *\n * The output is encoded for use in a source map. For details about the format,\n * see MappingEncoder below.\n */\nfunction generateFunctionMap(ast, context) {\n  const encoder = new MappingEncoder();\n  forEachMapping(ast, context, (mapping) => encoder.push(mapping));\n  return encoder.getResult();\n}\n/**\n * Same as generateFunctionMap, but returns the raw array of mappings instead\n * of encoding it for use in a source map.\n *\n * Lines are 1-based and columns are 0-based.\n */\n\nfunction generateFunctionMappingsArray(ast, context) {\n  const mappings = [];\n  forEachMapping(ast, context, (mapping) => {\n    mappings.push(mapping);\n  });\n  return mappings;\n}\n/**\n * Traverses a Babel AST and calls the supplied callback with function name\n * mappings, one at a time.\n */\n\nfunction forEachMapping(ast, context, pushMapping) {\n  const nameStack = [];\n  let tailPos = {\n    line: 1,\n    column: 0,\n  };\n  let tailName = null;\n\n  function advanceToPos(pos) {\n    if (tailPos && positionGreater(pos, tailPos)) {\n      const name = nameStack[0].name; // We always have at least Program\n\n      if (name !== tailName) {\n        pushMapping({\n          name,\n          start: {\n            line: tailPos.line,\n            column: tailPos.column,\n          },\n        });\n        tailName = name;\n      }\n    }\n\n    tailPos = pos;\n  }\n\n  function pushFrame(name, loc) {\n    advanceToPos(loc.start);\n    nameStack.unshift({\n      name,\n      loc,\n    });\n  }\n\n  function popFrame() {\n    const top = nameStack[0];\n\n    if (top) {\n      const { loc } = top;\n      advanceToPos(loc.end);\n      nameStack.shift();\n    }\n  }\n\n  if (!context) {\n    context = {};\n  }\n\n  const basename = context.filename\n    ? fsPath.basename(context.filename).replace(/\\..+$/, \"\")\n    : null;\n  const visitor = {\n    enter(path) {\n      let name = getNameForPath(path);\n\n      if (basename) {\n        name = removeNamePrefix(name, basename);\n      }\n\n      pushFrame(name, nullthrows(path.node.loc));\n    },\n\n    exit(path) {\n      popFrame();\n    },\n  };\n  (0, _traverse.default)(ast, {\n    Function: visitor,\n    Program: visitor,\n    Class: visitor,\n  });\n}\n\nconst ANONYMOUS_NAME = \"<anonymous>\";\n/**\n * Derive a contextual name for the given AST node (Function, Program, Class or\n * ObjectExpression).\n */\n\nfunction getNameForPath(path) {\n  const { node, parent, parentPath } = path;\n\n  if ((0, _types.isProgram)(node)) {\n    return \"<global>\";\n  }\n\n  let { id } = path; // has an `id` so we don't need to infer one\n\n  if (node.id) {\n    // $FlowFixMe Flow error uncovered by typing Babel more strictly\n    return node.id.name;\n  }\n\n  let propertyPath;\n  let kind = \"\"; // Find or construct an AST node that names the current node.\n\n  if ((0, _types.isObjectMethod)(node) || (0, _types.isClassMethod)(node)) {\n    // ({ foo() {} });\n    id = node.key;\n\n    if (node.kind !== \"method\" && node.kind !== \"constructor\") {\n      // Store the method's kind so we can add it to the final name.\n      kind = node.kind;\n    } // Also store the path to the property so we can find its context\n    // (object/class) later and add _its_ name to the result.\n\n    propertyPath = path;\n  } else if (\n    (0, _types.isObjectProperty)(parent) ||\n    (0, _types.isClassProperty)(parent)\n  ) {\n    // ({ foo: function() {} });\n    id = parent.key; // Also store the path to the property so we can find its context\n    // (object/class) later and add _its_ name to the result.\n\n    propertyPath = parentPath;\n  } else if ((0, _types.isVariableDeclarator)(parent)) {\n    // let foo = function () {};\n    id = parent.id;\n  } else if ((0, _types.isAssignmentExpression)(parent)) {\n    // foo = function () {};\n    id = parent.left;\n  } else if ((0, _types.isJSXExpressionContainer)(parent)) {\n    var _parentPath$parentPat;\n\n    const grandParentNode =\n      parentPath === null || parentPath === void 0\n        ? void 0\n        : (_parentPath$parentPat = parentPath.parentPath) === null ||\n          _parentPath$parentPat === void 0\n        ? void 0\n        : _parentPath$parentPat.node;\n\n    if ((0, _types.isJSXElement)(grandParentNode)) {\n      // <foo>{function () {}}</foo>\n      const openingElement = grandParentNode.openingElement;\n      id = t.jsxMemberExpression(\n        // $FlowFixMe Flow error uncovered by typing Babel more strictly\n        t.jsxMemberExpression(openingElement.name, t.jsxIdentifier(\"props\")),\n        t.jsxIdentifier(\"children\")\n      );\n    } else if ((0, _types.isJSXAttribute)(grandParentNode)) {\n      var _parentPath$parentPat2, _parentPath$parentPat3;\n\n      // <foo bar={function () {}} />\n      const openingElement =\n        parentPath === null || parentPath === void 0\n          ? void 0\n          : (_parentPath$parentPat2 = parentPath.parentPath) === null ||\n            _parentPath$parentPat2 === void 0\n          ? void 0\n          : (_parentPath$parentPat3 = _parentPath$parentPat2.parentPath) ===\n              null || _parentPath$parentPat3 === void 0\n          ? void 0\n          : _parentPath$parentPat3.node;\n      const prop = grandParentNode;\n      id = t.jsxMemberExpression(\n        // $FlowFixMe Flow error uncovered by typing Babel more strictly\n        t.jsxMemberExpression(openingElement.name, t.jsxIdentifier(\"props\")), // $FlowFixMe Flow error uncovered by typing Babel more strictly\n        prop.name\n      );\n    }\n  } // Collapse the name AST, if any, into a string.\n\n  let name = getNameFromId(id);\n\n  if (name == null) {\n    // We couldn't find a name directly. Try the parent in certain cases.\n    if (isAnyCallExpression(parent)) {\n      // foo(function () {})\n      const argIndex = parent.arguments.indexOf(node);\n\n      if (argIndex !== -1) {\n        const calleeName = getNameFromId(parent.callee); // var f = Object.freeze(function () {})\n\n        if (argIndex === 0 && calleeName === \"Object.freeze\") {\n          return getNameForPath(nullthrows(parentPath));\n        } // var f = useCallback(function () {})\n\n        if (\n          argIndex === 0 &&\n          (calleeName === \"useCallback\" || calleeName === \"React.useCallback\")\n        ) {\n          return getNameForPath(nullthrows(parentPath));\n        }\n\n        if (calleeName) {\n          return `${calleeName}$argument_${argIndex}`;\n        }\n      }\n    }\n\n    if (\n      (0, _types.isTypeCastExpression)(parent) &&\n      parent.expression === node\n    ) {\n      return getNameForPath(nullthrows(parentPath));\n    }\n\n    if ((0, _types.isExportDefaultDeclaration)(parent)) {\n      return \"default\";\n    } // We couldn't infer a name at all.\n\n    return ANONYMOUS_NAME;\n  } // Annotate getters and setters.\n\n  if (kind) {\n    name = kind + \"__\" + name;\n  } // Annotate members with the name of their containing object/class.\n\n  if (propertyPath) {\n    if ((0, _types.isClassBody)(propertyPath.parent)) {\n      // $FlowFixMe Disvoered when typing babel-traverse\n      const className = getNameForPath(propertyPath.parentPath.parentPath);\n\n      if (className !== ANONYMOUS_NAME) {\n        // $FlowFixMe Flow error uncovered by typing Babel more strictly\n        const separator = propertyPath.node.static ? \".\" : \"#\";\n        name = className + separator + name;\n      }\n    } else if ((0, _types.isObjectExpression)(propertyPath.parent)) {\n      const objectName = getNameForPath(nullthrows(propertyPath.parentPath));\n\n      if (objectName !== ANONYMOUS_NAME) {\n        name = objectName + \".\" + name;\n      }\n    }\n  }\n\n  return name;\n}\n\nfunction isAnyCallExpression(node) {\n  return (\n    node.type === \"CallExpression\" ||\n    node.type === \"NewExpression\" ||\n    node.type === \"OptionalCallExpression\"\n  );\n}\n\nfunction isAnyMemberExpression(node) {\n  return (\n    node.type === \"MemberExpression\" ||\n    node.type === \"JSXMemberExpression\" ||\n    node.type === \"OptionalMemberExpression\"\n  );\n}\n\nfunction isAnyIdentifier(node) {\n  return (0, _types.isIdentifier)(node) || (0, _types.isJSXIdentifier)(node);\n}\n\nfunction getNameFromId(id) {\n  const parts = getNamePartsFromId(id);\n\n  if (!parts.length) {\n    return null;\n  }\n\n  if (parts.length > 5) {\n    return (\n      parts[0] +\n      \".\" +\n      parts[1] +\n      \"...\" +\n      parts[parts.length - 2] +\n      \".\" +\n      parts[parts.length - 1]\n    );\n  }\n\n  return parts.join(\".\");\n}\n\nfunction getNamePartsFromId(id) {\n  if (!id) {\n    return [];\n  }\n\n  if (isAnyCallExpression(id)) {\n    return getNamePartsFromId(id.callee);\n  }\n\n  if ((0, _types.isTypeCastExpression)(id)) {\n    return getNamePartsFromId(id.expression);\n  }\n\n  let name;\n\n  if (isAnyIdentifier(id)) {\n    name = id.name;\n  } else if ((0, _types.isNullLiteral)(id)) {\n    name = \"null\";\n  } else if ((0, _types.isRegExpLiteral)(id)) {\n    var _id$flags;\n\n    name = `_${id.pattern}_${\n      (_id$flags = id.flags) !== null && _id$flags !== void 0 ? _id$flags : \"\"\n    }`;\n  } else if ((0, _types.isTemplateLiteral)(id)) {\n    name = id.quasis.map((quasi) => quasi.value.raw).join(\"\");\n  } else if ((0, _types.isLiteral)(id) && id.value != null) {\n    name = String(id.value);\n  }\n\n  if (name != null) {\n    return [t.toBindingIdentifierName(name)];\n  }\n\n  if ((0, _types.isImport)(id)) {\n    name = \"import\";\n  }\n\n  if (name != null) {\n    return [name];\n  }\n\n  if (isAnyMemberExpression(id)) {\n    if (\n      isAnyIdentifier(id.object) &&\n      id.object.name === \"Symbol\" &&\n      (isAnyIdentifier(id.property) || (0, _types.isLiteral)(id.property))\n    ) {\n      const propertyName = getNameFromId(id.property);\n\n      if (propertyName) {\n        name = \"@@\" + propertyName;\n      }\n    } else {\n      const propertyName = getNamePartsFromId(id.property);\n\n      if (propertyName.length) {\n        const objectName = getNamePartsFromId(id.object);\n\n        if (objectName.length) {\n          return [...objectName, ...propertyName];\n        } else {\n          return propertyName;\n        }\n      }\n    }\n  }\n\n  return name ? [name] : [];\n}\n\nconst DELIMITER_START_RE = /^[^A-Za-z0-9_$@]+/;\n/**\n * Strip the given prefix from `name`, if it occurs there, plus any delimiter\n * characters that follow (of which at least one is required). If an empty\n * string would be returned, return the original name instead.\n */\n\nfunction removeNamePrefix(name, namePrefix) {\n  if (!namePrefix.length || !name.startsWith(namePrefix)) {\n    return name;\n  }\n\n  const shortenedName = name.substr(namePrefix.length);\n  const [delimiterMatch] = shortenedName.match(DELIMITER_START_RE) || [];\n\n  if (delimiterMatch) {\n    return shortenedName.substr(delimiterMatch.length) || name;\n  }\n\n  return name;\n}\n/**\n * Encodes function name mappings as deltas in a Base64 VLQ format inspired by\n * the standard source map format.\n *\n * Mappings on different lines are separated with a single `;` (even if there\n * are multiple intervening lines).\n * Mappings on the same line are separated with `,`.\n *\n * The first mapping of a line has the fields:\n *  [column delta, name delta, line delta]\n *\n * where the column delta is relative to the beginning of the line, the name\n * delta is relative to the previously occurring name, and the line delta is\n * relative to the previously occurring line.\n *\n * The 2...nth other mappings of a line have the fields:\n *  [column delta, name delta]\n *\n * where both fields are relative to their previous running values. The line\n * delta is omitted since it is always 0 by definition.\n *\n * Lines and columns are both 0-based in the serialised format. In memory,\n * lines are 1-based while columns are 0-based.\n */\n\nclass MappingEncoder {\n  constructor() {\n    this._namesMap = new Map();\n    this._names = [];\n    this._line = new RelativeValue(1);\n    this._column = new RelativeValue(0);\n    this._nameIndex = new RelativeValue(0);\n    this._mappings = new B64Builder();\n  }\n\n  getResult() {\n    return {\n      names: this._names,\n      mappings: this._mappings.toString(),\n    };\n  }\n\n  push({ name, start }) {\n    let nameIndex = this._namesMap.get(name);\n\n    if (typeof nameIndex !== \"number\") {\n      nameIndex = this._names.length;\n      this._names[nameIndex] = name;\n\n      this._namesMap.set(name, nameIndex);\n    }\n\n    const lineDelta = this._line.next(start.line);\n\n    const firstOfLine = this._mappings.pos === 0 || lineDelta > 0;\n\n    if (lineDelta > 0) {\n      // The next entry will have the line offset, so emit just one semicolon.\n      this._mappings.markLines(1);\n\n      this._column.reset(0);\n    }\n\n    this._mappings.startSegment(this._column.next(start.column));\n\n    this._mappings.append(this._nameIndex.next(nameIndex));\n\n    if (firstOfLine) {\n      this._mappings.append(lineDelta);\n    }\n  }\n}\n\nclass RelativeValue {\n  constructor(value = 0) {\n    this.reset(value);\n  }\n\n  next(absoluteValue) {\n    const delta = absoluteValue - this._value;\n    this._value = absoluteValue;\n    return delta;\n  }\n\n  reset(value = 0) {\n    this._value = value;\n  }\n}\n\nfunction positionGreater(x, y) {\n  return x.line > y.line || (x.line === y.line && x.column > y.column);\n}\n\nmodule.exports = {\n  generateFunctionMap,\n  generateFunctionMappingsArray,\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}