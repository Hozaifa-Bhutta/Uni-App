{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"@babel/runtime/regenerator\");\n\nvar _toConsumableArray = require(\"@babel/runtime/helpers/toConsumableArray\");\n\nvar _marked = _regeneratorRuntime.mark(concat);\n\nfunction _createForOfIteratorHelperLoose(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (it) return (it = it.call(o)).next.bind(it); if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nvar relativizeSourceMapInline = require(\"../../../lib/relativizeSourceMap\");\n\nvar buildSourcemapWithMetadata = require(\"./buildSourcemapWithMetadata\");\n\nvar MAGIC_UNBUNDLE_FILE_HEADER = require(\"./magic-number\");\n\nvar _require = require(\"./util\"),\n    joinModules = _require.joinModules;\n\nvar writeSourceMap = require(\"./write-sourcemap\");\n\nvar fs = require(\"fs\");\n\nvar SIZEOF_UINT32 = 4;\n\nfunction saveAsIndexedFile(bundle, options, log) {\n  var bundleOutput = options.bundleOutput,\n      encoding = options.bundleEncoding,\n      sourcemapOutput = options.sourcemapOutput,\n      sourcemapSourcesRoot = options.sourcemapSourcesRoot;\n  log(\"start\");\n  var startupModules = bundle.startupModules,\n      lazyModules = bundle.lazyModules,\n      groups = bundle.groups;\n  log(\"finish\");\n  var moduleGroups = createModuleGroups(groups, lazyModules);\n  var startupCode = joinModules(startupModules);\n  log(\"Writing unbundle output to:\", bundleOutput);\n  var writeUnbundle = writeBuffers(fs.createWriteStream(bundleOutput), buildTableAndContents(startupCode, lazyModules, moduleGroups, encoding)).then(function () {\n    return log(\"Done writing unbundle output\");\n  });\n\n  if (sourcemapOutput) {\n    var sourceMap = buildSourcemapWithMetadata({\n      startupModules: startupModules.concat(),\n      lazyModules: lazyModules.concat(),\n      moduleGroups: moduleGroups,\n      fixWrapperOffset: true\n    });\n\n    if (sourcemapSourcesRoot !== undefined) {\n      relativizeSourceMapInline(sourceMap, sourcemapSourcesRoot);\n    }\n\n    var wroteSourceMap = writeSourceMap(sourcemapOutput, JSON.stringify(sourceMap), log);\n    return Promise.all([writeUnbundle, wroteSourceMap]);\n  } else {\n    return writeUnbundle;\n  }\n}\n\nvar fileHeader = Buffer.alloc(4);\nfileHeader.writeUInt32LE(MAGIC_UNBUNDLE_FILE_HEADER, 0);\nvar nullByteBuffer = Buffer.alloc(1).fill(0);\n\nfunction writeBuffers(stream, buffers) {\n  buffers.forEach(function (buffer) {\n    return stream.write(buffer);\n  });\n  return new Promise(function (resolve, reject) {\n    stream.on(\"error\", reject);\n    stream.on(\"finish\", function () {\n      return resolve();\n    });\n    stream.end();\n  });\n}\n\nfunction nullTerminatedBuffer(contents, encoding) {\n  return Buffer.concat([Buffer.from(contents, encoding), nullByteBuffer]);\n}\n\nfunction moduleToBuffer(id, code, encoding) {\n  return {\n    id: id,\n    buffer: nullTerminatedBuffer(code, encoding)\n  };\n}\n\nfunction entryOffset(n) {\n  return (2 + n * 2) * SIZEOF_UINT32;\n}\n\nfunction buildModuleTable(startupCode, moduleBuffers, moduleGroups) {\n  var moduleIds = _toConsumableArray(moduleGroups.modulesById.keys());\n\n  var maxId = moduleIds.reduce(function (max, id) {\n    return Math.max(max, id);\n  });\n  var numEntries = maxId + 1;\n  var table = Buffer.alloc(entryOffset(numEntries)).fill(0);\n  table.writeUInt32LE(numEntries, 0);\n  table.writeUInt32LE(startupCode.length, SIZEOF_UINT32);\n  var codeOffset = startupCode.length;\n  moduleBuffers.forEach(function (_ref) {\n    var id = _ref.id,\n        buffer = _ref.buffer;\n    var group = moduleGroups.groups.get(id);\n    var idsInGroup = group ? [id].concat(Array.from(group)) : [id];\n    idsInGroup.forEach(function (moduleId) {\n      var offset = entryOffset(moduleId);\n      table.writeUInt32LE(codeOffset, offset);\n      table.writeUInt32LE(buffer.length, offset + SIZEOF_UINT32);\n    });\n    codeOffset += buffer.length;\n  });\n  return table;\n}\n\nfunction groupCode(rootCode, moduleGroup, modulesById) {\n  if (!moduleGroup || !moduleGroup.size) {\n    return rootCode;\n  }\n\n  var code = [rootCode];\n\n  for (var _iterator = _createForOfIteratorHelperLoose(moduleGroup), _step; !(_step = _iterator()).done;) {\n    var id = _step.value;\n    code.push((modulesById.get(id) || {\n      code: \"\"\n    }).code);\n  }\n\n  return code.join(\"\\n\");\n}\n\nfunction buildModuleBuffers(modules, moduleGroups, encoding) {\n  return modules.filter(function (m) {\n    return !moduleGroups.modulesInGroups.has(m.id);\n  }).map(function (_ref2) {\n    var id = _ref2.id,\n        code = _ref2.code;\n    return moduleToBuffer(id, groupCode(code, moduleGroups.groups.get(id), moduleGroups.modulesById), encoding);\n  });\n}\n\nfunction buildTableAndContents(startupCode, modules, moduleGroups, encoding) {\n  var startupCodeBuffer = nullTerminatedBuffer(startupCode, encoding);\n  var moduleBuffers = buildModuleBuffers(modules, moduleGroups, encoding);\n  var table = buildModuleTable(startupCodeBuffer, moduleBuffers, moduleGroups);\n  return [fileHeader, table, startupCodeBuffer].concat(moduleBuffers.map(function (_ref3) {\n    var buffer = _ref3.buffer;\n    return buffer;\n  }));\n}\n\nfunction createModuleGroups(groups, modules) {\n  return {\n    groups: groups,\n    modulesById: new Map(modules.map(function (m) {\n      return [m.id, m];\n    })),\n    modulesInGroups: new Set(concat(groups.values()))\n  };\n}\n\nfunction concat(iterators) {\n  var _iterator2, _step2, it;\n\n  return _regeneratorRuntime.wrap(function concat$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          _iterator2 = _createForOfIteratorHelperLoose(iterators);\n\n        case 1:\n          if ((_step2 = _iterator2()).done) {\n            _context.next = 6;\n            break;\n          }\n\n          it = _step2.value;\n          return _context.delegateYield(it, \"t0\", 4);\n\n        case 4:\n          _context.next = 1;\n          break;\n\n        case 6:\n        case \"end\":\n          return _context.stop();\n      }\n    }\n  }, _marked);\n}\n\nexports.save = saveAsIndexedFile;\nexports.buildTableAndContents = buildTableAndContents;\nexports.createModuleGroups = createModuleGroups;","map":{"version":3,"names":["concat","relativizeSourceMapInline","require","buildSourcemapWithMetadata","MAGIC_UNBUNDLE_FILE_HEADER","joinModules","writeSourceMap","fs","SIZEOF_UINT32","saveAsIndexedFile","bundle","options","log","bundleOutput","encoding","bundleEncoding","sourcemapOutput","sourcemapSourcesRoot","startupModules","lazyModules","groups","moduleGroups","createModuleGroups","startupCode","writeUnbundle","writeBuffers","createWriteStream","buildTableAndContents","then","sourceMap","fixWrapperOffset","undefined","wroteSourceMap","JSON","stringify","Promise","all","fileHeader","Buffer","alloc","writeUInt32LE","nullByteBuffer","fill","stream","buffers","forEach","buffer","write","resolve","reject","on","end","nullTerminatedBuffer","contents","from","moduleToBuffer","id","code","entryOffset","n","buildModuleTable","moduleBuffers","moduleIds","modulesById","keys","maxId","reduce","max","Math","numEntries","table","length","codeOffset","group","get","idsInGroup","Array","moduleId","offset","groupCode","rootCode","moduleGroup","size","push","join","buildModuleBuffers","modules","filter","m","modulesInGroups","has","map","startupCodeBuffer","Map","Set","values","iterators","it","exports","save"],"sources":["/Users/hozaifa/Documents/Uni App Github/node_modules/@react-native-community/cli-plugin-metro/node_modules/metro/src/shared/output/RamBundle/as-indexed-file.js"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *\n * @format\n */\n\"use strict\";\n\nconst relativizeSourceMapInline = require(\"../../../lib/relativizeSourceMap\");\n\nconst buildSourcemapWithMetadata = require(\"./buildSourcemapWithMetadata\");\n\nconst MAGIC_UNBUNDLE_FILE_HEADER = require(\"./magic-number\");\n\nconst { joinModules } = require(\"./util\");\n\nconst writeSourceMap = require(\"./write-sourcemap\");\n\nconst fs = require(\"fs\");\n\nconst SIZEOF_UINT32 = 4;\n/**\n * Saves all JS modules of an app as a single file, separated with null bytes.\n * The file begins with an offset table that contains module ids and their\n * lengths/offsets.\n * The module id for the startup code (prelude, polyfills etc.) is the\n * empty string.\n */\n\nfunction saveAsIndexedFile(bundle, options, log) {\n  const {\n    bundleOutput,\n    bundleEncoding: encoding,\n    sourcemapOutput,\n    sourcemapSourcesRoot,\n  } = options;\n  log(\"start\");\n  const { startupModules, lazyModules, groups } = bundle;\n  log(\"finish\");\n  const moduleGroups = createModuleGroups(groups, lazyModules);\n  const startupCode = joinModules(startupModules);\n  log(\"Writing unbundle output to:\", bundleOutput);\n  const writeUnbundle = writeBuffers(\n    fs.createWriteStream(bundleOutput),\n    buildTableAndContents(startupCode, lazyModules, moduleGroups, encoding)\n  ).then(() => log(\"Done writing unbundle output\"));\n\n  if (sourcemapOutput) {\n    const sourceMap = buildSourcemapWithMetadata({\n      startupModules: startupModules.concat(),\n      lazyModules: lazyModules.concat(),\n      moduleGroups,\n      fixWrapperOffset: true,\n    });\n\n    if (sourcemapSourcesRoot !== undefined) {\n      relativizeSourceMapInline(sourceMap, sourcemapSourcesRoot);\n    }\n\n    const wroteSourceMap = writeSourceMap(\n      sourcemapOutput,\n      JSON.stringify(sourceMap),\n      log\n    );\n    return Promise.all([writeUnbundle, wroteSourceMap]);\n  } else {\n    return writeUnbundle;\n  }\n}\n\nconst fileHeader = Buffer.alloc(4);\nfileHeader.writeUInt32LE(MAGIC_UNBUNDLE_FILE_HEADER, 0);\nconst nullByteBuffer = Buffer.alloc(1).fill(0);\n\nfunction writeBuffers(stream, buffers) {\n  buffers.forEach((buffer) => stream.write(buffer));\n  return new Promise((resolve, reject) => {\n    stream.on(\"error\", reject);\n    stream.on(\"finish\", () => resolve());\n    stream.end();\n  });\n}\n\nfunction nullTerminatedBuffer(contents, encoding) {\n  return Buffer.concat([Buffer.from(contents, encoding), nullByteBuffer]);\n}\n\nfunction moduleToBuffer(id, code, encoding) {\n  return {\n    id,\n    buffer: nullTerminatedBuffer(code, encoding),\n  };\n}\n\nfunction entryOffset(n) {\n  // 2: num_entries + startup_code_len\n  // n * 2: each entry consists of two uint32s\n  return (2 + n * 2) * SIZEOF_UINT32;\n}\n\nfunction buildModuleTable(startupCode, moduleBuffers, moduleGroups) {\n  // table format:\n  // - num_entries:      uint_32  number of entries\n  // - startup_code_len: uint_32  length of the startup section\n  // - entries:          entry...\n  //\n  // entry:\n  //  - module_offset:   uint_32  offset into the modules blob\n  //  - module_length:   uint_32  length of the module code in bytes\n  const moduleIds = [...moduleGroups.modulesById.keys()];\n  const maxId = moduleIds.reduce((max, id) => Math.max(max, id));\n  const numEntries = maxId + 1;\n  const table = Buffer.alloc(entryOffset(numEntries)).fill(0); // num_entries\n\n  table.writeUInt32LE(numEntries, 0); // startup_code_len\n\n  table.writeUInt32LE(startupCode.length, SIZEOF_UINT32); // entries\n\n  let codeOffset = startupCode.length;\n  moduleBuffers.forEach(({ id, buffer }) => {\n    const group = moduleGroups.groups.get(id);\n    const idsInGroup = group ? [id].concat(Array.from(group)) : [id];\n    idsInGroup.forEach((moduleId) => {\n      const offset = entryOffset(moduleId); // module_offset\n\n      table.writeUInt32LE(codeOffset, offset); // module_length\n\n      table.writeUInt32LE(buffer.length, offset + SIZEOF_UINT32);\n    });\n    codeOffset += buffer.length;\n  });\n  return table;\n}\n\nfunction groupCode(rootCode, moduleGroup, modulesById) {\n  if (!moduleGroup || !moduleGroup.size) {\n    return rootCode;\n  }\n\n  const code = [rootCode];\n\n  for (const id of moduleGroup) {\n    code.push(\n      (\n        modulesById.get(id) || {\n          code: \"\",\n        }\n      ).code\n    );\n  }\n\n  return code.join(\"\\n\");\n}\n\nfunction buildModuleBuffers(modules, moduleGroups, encoding) {\n  return modules\n    .filter((m) => !moduleGroups.modulesInGroups.has(m.id))\n    .map(({ id, code }) =>\n      moduleToBuffer(\n        id,\n        groupCode(code, moduleGroups.groups.get(id), moduleGroups.modulesById),\n        encoding\n      )\n    );\n}\n\nfunction buildTableAndContents(startupCode, modules, moduleGroups, encoding) {\n  // file contents layout:\n  // - magic number      char[4]  0xE5 0xD1 0x0B 0xFB (0xFB0BD1E5 uint32 LE)\n  // - offset table      table    see `buildModuleTables`\n  // - code blob         char[]   null-terminated code strings, starting with\n  //                              the startup code\n  const startupCodeBuffer = nullTerminatedBuffer(startupCode, encoding);\n  const moduleBuffers = buildModuleBuffers(modules, moduleGroups, encoding);\n  const table = buildModuleTable(\n    startupCodeBuffer,\n    moduleBuffers,\n    moduleGroups\n  );\n  return [fileHeader, table, startupCodeBuffer].concat(\n    moduleBuffers.map(({ buffer }) => buffer)\n  );\n}\n\nfunction createModuleGroups(groups, modules) {\n  return {\n    groups,\n    modulesById: new Map(modules.map((m) => [m.id, m])),\n    modulesInGroups: new Set(concat(groups.values())),\n  };\n}\n\nfunction* concat(iterators) {\n  for (const it of iterators) {\n    yield* it;\n  }\n}\n\nexports.save = saveAsIndexedFile;\nexports.buildTableAndContents = buildTableAndContents;\nexports.createModuleGroups = createModuleGroups;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}