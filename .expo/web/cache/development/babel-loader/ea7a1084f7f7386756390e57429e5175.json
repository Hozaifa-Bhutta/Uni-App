{"ast":null,"code":"\"use strict\";\n\nvar _defineProperty = require(\"@babel/runtime/helpers/defineProperty\");\n\nvar _createClass = require(\"@babel/runtime/helpers/createClass\");\n\nvar _classCallCheck = require(\"@babel/runtime/helpers/classCallCheck\");\n\nvar _inherits = require(\"@babel/runtime/helpers/inherits\");\n\nvar _possibleConstructorReturn = require(\"@babel/runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"@babel/runtime/helpers/getPrototypeOf\");\n\nvar _wrapNativeSuper = require(\"@babel/runtime/helpers/wrapNativeSuper\");\n\nvar _objectWithoutProperties = require(\"@babel/runtime/helpers/objectWithoutProperties\");\n\nvar _toConsumableArray = require(\"@babel/runtime/helpers/toConsumableArray\");\n\nvar _excluded = [\"index\", \"name\"];\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _createForOfIteratorHelperLoose(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (it) return (it = it.call(o)).next.bind(it); if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nvar generate = require(\"@babel/generator\").default;\n\nvar template = require(\"@babel/template\").default;\n\nvar traverse = require(\"@babel/traverse\").default;\n\nvar types = require(\"@babel/types\");\n\nvar invariant = require(\"invariant\");\n\nvar nullthrows = require(\"nullthrows\");\n\nvar isImport = types.isImport;\n\nfunction collectDependencies(ast, options) {\n  var _options$dependencyRe, _options$dependencyTr;\n\n  var visited = new WeakSet();\n  var state = {\n    asyncRequireModulePathStringLiteral: null,\n    dependencyCalls: new Set(),\n    dependencyRegistry: (_options$dependencyRe = options.dependencyRegistry) !== null && _options$dependencyRe !== void 0 ? _options$dependencyRe : new DefaultModuleDependencyRegistry(),\n    dependencyTransformer: (_options$dependencyTr = options.dependencyTransformer) !== null && _options$dependencyTr !== void 0 ? _options$dependencyTr : DefaultDependencyTransformer,\n    dependencyMapIdentifier: null,\n    dynamicRequires: options.dynamicRequires,\n    keepRequireNames: options.keepRequireNames,\n    allowOptionalDependencies: options.allowOptionalDependencies\n  };\n  var visitor = {\n    CallExpression: function CallExpression(path, state) {\n      if (visited.has(path.node)) {\n        return;\n      }\n\n      var callee = path.node.callee;\n      var name = callee.type === \"Identifier\" ? callee.name : null;\n\n      if (isImport(callee)) {\n        processImportCall(path, state, {\n          asyncType: \"async\"\n        });\n        return;\n      }\n\n      if (name === \"__prefetchImport\" && !path.scope.getBinding(name)) {\n        processImportCall(path, state, {\n          asyncType: \"prefetch\"\n        });\n        return;\n      }\n\n      if (name === \"__jsResource\" && !path.scope.getBinding(name)) {\n        processImportCall(path, state, {\n          asyncType: \"async\",\n          jsResource: true\n        });\n        return;\n      }\n\n      if (name === \"__conditionallySplitJSResource\" && !path.scope.getBinding(name)) {\n        var args = path.get(\"arguments\");\n        invariant(Array.isArray(args), \"Expected arguments to be an array\");\n        processImportCall(path, state, {\n          asyncType: \"async\",\n          jsResource: true,\n          splitCondition: args[1]\n        });\n        return;\n      }\n\n      if (name != null && state.dependencyCalls.has(name) && !path.scope.getBinding(name)) {\n        processRequireCall(path, state);\n        visited.add(path.node);\n      }\n    },\n    ImportDeclaration: collectImports,\n    ExportNamedDeclaration: collectImports,\n    ExportAllDeclaration: collectImports,\n    Program: function Program(path, state) {\n      state.asyncRequireModulePathStringLiteral = types.stringLiteral(options.asyncRequireModulePath);\n\n      if (options.dependencyMapName != null) {\n        state.dependencyMapIdentifier = types.identifier(options.dependencyMapName);\n      } else {\n        state.dependencyMapIdentifier = path.scope.generateUidIdentifier(\"dependencyMap\");\n      }\n\n      state.dependencyCalls = new Set([\"require\"].concat(_toConsumableArray(options.inlineableCalls)));\n    }\n  };\n  traverse(ast, visitor, null, state);\n  var collectedDependencies = state.dependencyRegistry.getDependencies();\n  var dependencies = new Array(collectedDependencies.length);\n\n  for (var _iterator = _createForOfIteratorHelperLoose(collectedDependencies), _step; !(_step = _iterator()).done;) {\n    var _ref = _step.value;\n\n    var index = _ref.index,\n        name = _ref.name,\n        dependencyData = _objectWithoutProperties(_ref, _excluded);\n\n    dependencies[index] = {\n      name: name,\n      data: dependencyData\n    };\n  }\n\n  return {\n    ast: ast,\n    dependencies: dependencies,\n    dependencyMapName: nullthrows(state.dependencyMapIdentifier).name\n  };\n}\n\nfunction collectImports(path, state) {\n  if (path.node.source) {\n    registerDependency(state, {\n      name: path.node.source.value,\n      asyncType: null,\n      optional: false\n    }, path);\n  }\n}\n\nfunction processImportCall(path, state, options) {\n  var name = getModuleNameFromCallArgs(path);\n\n  if (name == null) {\n    throw new InvalidRequireCallError(path);\n  }\n\n  var dep = registerDependency(state, {\n    name: name,\n    asyncType: options.asyncType,\n    splitCondition: options.splitCondition,\n    optional: isOptionalDependency(name, path, state)\n  }, path);\n  var transformer = state.dependencyTransformer;\n\n  if (options.jsResource) {\n    transformer.transformJSResource(path, dep, state);\n  } else if (options.asyncType === \"async\") {\n    transformer.transformImportCall(path, dep, state);\n  } else {\n    transformer.transformPrefetch(path, dep, state);\n  }\n}\n\nfunction processRequireCall(path, state) {\n  var name = getModuleNameFromCallArgs(path);\n  var transformer = state.dependencyTransformer;\n\n  if (name == null) {\n    if (state.dynamicRequires === \"reject\") {\n      throw new InvalidRequireCallError(path);\n    }\n\n    transformer.transformIllegalDynamicRequire(path, state);\n    return;\n  }\n\n  var dep = registerDependency(state, {\n    name: name,\n    asyncType: null,\n    optional: isOptionalDependency(name, path, state)\n  }, path);\n  transformer.transformSyncRequire(path, dep, state);\n}\n\nfunction getNearestLocFromPath(path) {\n  var _current;\n\n  var current = path;\n\n  while (current && !current.node.loc) {\n    current = current.parentPath;\n  }\n\n  return (_current = current) === null || _current === void 0 ? void 0 : _current.node.loc;\n}\n\nfunction registerDependency(state, qualifier, path) {\n  var dependency = state.dependencyRegistry.registerDependency(qualifier);\n  var loc = getNearestLocFromPath(path);\n\n  if (loc != null) {\n    dependency.locs.push(loc);\n  }\n\n  return dependency;\n}\n\nfunction isOptionalDependency(name, path, state) {\n  var _state$asyncRequireMo;\n\n  var allowOptionalDependencies = state.allowOptionalDependencies;\n\n  if (name === ((_state$asyncRequireMo = state.asyncRequireModulePathStringLiteral) === null || _state$asyncRequireMo === void 0 ? void 0 : _state$asyncRequireMo.value)) {\n    return false;\n  }\n\n  var isExcluded = function isExcluded() {\n    return Array.isArray(allowOptionalDependencies.exclude) && allowOptionalDependencies.exclude.includes(name);\n  };\n\n  if (!allowOptionalDependencies || isExcluded()) {\n    return false;\n  }\n\n  var sCount = 0;\n  var p = path;\n\n  while (p && sCount < 3) {\n    if (p.isStatement()) {\n      if (p.node.type === \"BlockStatement\") {\n        return p.parentPath != null && p.parentPath.node.type === \"TryStatement\" && p.key === \"block\";\n      }\n\n      sCount += 1;\n    }\n\n    p = p.parentPath;\n  }\n\n  return false;\n}\n\nfunction getModuleNameFromCallArgs(path) {\n  var expectedCount = path.node.callee.name === \"__conditionallySplitJSResource\" ? 2 : 1;\n  var args = path.get(\"arguments\");\n\n  if (!Array.isArray(args) || args.length !== expectedCount) {\n    throw new InvalidRequireCallError(path);\n  }\n\n  var result = args[0].evaluate();\n\n  if (result.confident && typeof result.value === \"string\") {\n    return result.value;\n  }\n\n  return null;\n}\n\ncollectDependencies.getModuleNameFromCallArgs = getModuleNameFromCallArgs;\n\nvar InvalidRequireCallError = function (_Error) {\n  _inherits(InvalidRequireCallError, _Error);\n\n  var _super = _createSuper(InvalidRequireCallError);\n\n  function InvalidRequireCallError(_ref2) {\n    var node = _ref2.node;\n\n    _classCallCheck(this, InvalidRequireCallError);\n\n    var line = node.loc && node.loc.start && node.loc.start.line;\n    return _super.call(this, \"Invalid call at line \" + (line || \"<unknown>\") + \": \" + generate(node).code);\n  }\n\n  return _createClass(InvalidRequireCallError);\n}(_wrapNativeSuper(Error));\n\ncollectDependencies.InvalidRequireCallError = InvalidRequireCallError;\nvar dynamicRequireErrorTemplate = template.statement(\"\\n  (function(line) {\\n    throw new Error(\\n      'Dynamic require defined at line ' + line + '; not supported by Metro',\\n    );\\n  })(LINE)\\n\");\nvar makeAsyncRequireTemplate = template.statement(\"\\n  require(ASYNC_REQUIRE_MODULE_PATH)(MODULE_ID, MODULE_NAME)\\n\");\nvar makeAsyncPrefetchTemplate = template.statement(\"\\n  require(ASYNC_REQUIRE_MODULE_PATH).prefetch(MODULE_ID, MODULE_NAME)\\n\");\nvar makeJSResourceTemplate = template.statement(\"\\n  require(ASYNC_REQUIRE_MODULE_PATH).resource(MODULE_ID, MODULE_NAME)\\n\");\nvar DefaultDependencyTransformer = {\n  transformSyncRequire: function transformSyncRequire(path, dependency, state) {\n    var moduleIDExpression = createModuleIDExpression(dependency, state);\n    path.node.arguments = state.keepRequireNames ? [moduleIDExpression, types.stringLiteral(dependency.name)] : [moduleIDExpression];\n  },\n  transformImportCall: function transformImportCall(path, dependency, state) {\n    path.replaceWith(makeAsyncRequireTemplate({\n      ASYNC_REQUIRE_MODULE_PATH: nullthrows(state.asyncRequireModulePathStringLiteral),\n      MODULE_ID: createModuleIDExpression(dependency, state),\n      MODULE_NAME: createModuleNameLiteral(dependency)\n    }));\n  },\n  transformJSResource: function transformJSResource(path, dependency, state) {\n    path.replaceWith(makeJSResourceTemplate({\n      ASYNC_REQUIRE_MODULE_PATH: nullthrows(state.asyncRequireModulePathStringLiteral),\n      MODULE_ID: createModuleIDExpression(dependency, state),\n      MODULE_NAME: createModuleNameLiteral(dependency)\n    }));\n  },\n  transformPrefetch: function transformPrefetch(path, dependency, state) {\n    path.replaceWith(makeAsyncPrefetchTemplate({\n      ASYNC_REQUIRE_MODULE_PATH: nullthrows(state.asyncRequireModulePathStringLiteral),\n      MODULE_ID: createModuleIDExpression(dependency, state),\n      MODULE_NAME: createModuleNameLiteral(dependency)\n    }));\n  },\n  transformIllegalDynamicRequire: function transformIllegalDynamicRequire(path, state) {\n    var _path$node$loc$start$, _path$node$loc;\n\n    path.replaceWith(dynamicRequireErrorTemplate({\n      LINE: types.numericLiteral((_path$node$loc$start$ = (_path$node$loc = path.node.loc) === null || _path$node$loc === void 0 ? void 0 : _path$node$loc.start.line) !== null && _path$node$loc$start$ !== void 0 ? _path$node$loc$start$ : 0)\n    }));\n  }\n};\n\nfunction createModuleIDExpression(dependency, state) {\n  return types.memberExpression(nullthrows(state.dependencyMapIdentifier), types.numericLiteral(dependency.index), true);\n}\n\nfunction createModuleNameLiteral(dependency) {\n  return types.stringLiteral(dependency.name);\n}\n\nvar DefaultModuleDependencyRegistry = function () {\n  function DefaultModuleDependencyRegistry() {\n    _classCallCheck(this, DefaultModuleDependencyRegistry);\n\n    this._dependencies = new Map();\n  }\n\n  _createClass(DefaultModuleDependencyRegistry, [{\n    key: \"registerDependency\",\n    value: function registerDependency(qualifier) {\n      var dependency = this._dependencies.get(qualifier.name);\n\n      if (dependency == null) {\n        var newDependency = {\n          name: qualifier.name,\n          asyncType: qualifier.asyncType,\n          locs: [],\n          index: this._dependencies.size\n        };\n\n        if (qualifier.optional) {\n          newDependency.isOptional = true;\n        }\n\n        dependency = newDependency;\n\n        this._dependencies.set(qualifier.name, dependency);\n      } else {\n        var original = dependency;\n        dependency = collapseDependencies(original, qualifier);\n\n        if (original !== dependency) {\n          this._dependencies.set(qualifier.name, dependency);\n        }\n      }\n\n      return dependency;\n    }\n  }, {\n    key: \"getDependencies\",\n    value: function getDependencies() {\n      return Array.from(this._dependencies.values());\n    }\n  }]);\n\n  return DefaultModuleDependencyRegistry;\n}();\n\nfunction collapseDependencies(dependency, qualifier) {\n  var collapsed = dependency;\n\n  if (collapsed.isOptional && !qualifier.optional) {\n    collapsed = _objectSpread(_objectSpread({}, dependency), {}, {\n      isOptional: false\n    });\n  }\n\n  if (collapsed.asyncType != null && qualifier.asyncType == null) {\n    collapsed = _objectSpread(_objectSpread({}, dependency), {}, {\n      asyncType: null\n    });\n  }\n\n  if (collapsed.asyncType === \"prefetch\" && qualifier.asyncType === \"async\") {\n    collapsed = _objectSpread(_objectSpread({}, dependency), {}, {\n      asyncType: \"async\"\n    });\n  }\n\n  return collapsed;\n}\n\nmodule.exports = collectDependencies;","map":{"version":3,"names":["generate","require","default","template","traverse","types","invariant","nullthrows","isImport","collectDependencies","ast","options","_options$dependencyRe","_options$dependencyTr","visited","WeakSet","state","asyncRequireModulePathStringLiteral","dependencyCalls","Set","dependencyRegistry","DefaultModuleDependencyRegistry","dependencyTransformer","DefaultDependencyTransformer","dependencyMapIdentifier","dynamicRequires","keepRequireNames","allowOptionalDependencies","visitor","CallExpression","path","has","node","callee","name","type","processImportCall","asyncType","scope","getBinding","jsResource","args","get","Array","isArray","splitCondition","processRequireCall","add","ImportDeclaration","collectImports","ExportNamedDeclaration","ExportAllDeclaration","Program","stringLiteral","asyncRequireModulePath","dependencyMapName","identifier","generateUidIdentifier","inlineableCalls","collectedDependencies","getDependencies","dependencies","length","index","dependencyData","data","source","registerDependency","value","optional","getModuleNameFromCallArgs","InvalidRequireCallError","dep","isOptionalDependency","transformer","transformJSResource","transformImportCall","transformPrefetch","transformIllegalDynamicRequire","transformSyncRequire","getNearestLocFromPath","_current","current","loc","parentPath","qualifier","dependency","locs","push","_state$asyncRequireMo","isExcluded","exclude","includes","sCount","p","isStatement","key","expectedCount","result","evaluate","confident","line","start","code","Error","dynamicRequireErrorTemplate","statement","makeAsyncRequireTemplate","makeAsyncPrefetchTemplate","makeJSResourceTemplate","moduleIDExpression","createModuleIDExpression","arguments","replaceWith","ASYNC_REQUIRE_MODULE_PATH","MODULE_ID","MODULE_NAME","createModuleNameLiteral","_path$node$loc$start$","_path$node$loc","LINE","numericLiteral","memberExpression","_dependencies","Map","newDependency","size","isOptional","set","original","collapseDependencies","from","values","collapsed","module","exports"],"sources":["/Users/hozaifa/Documents/Uni App Github/node_modules/@react-native-community/cli-plugin-metro/node_modules/metro/src/ModuleGraph/worker/collectDependencies.js"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @format\n *\n */\n\"use strict\";\n\nconst generate = require(\"@babel/generator\").default;\n\nconst template = require(\"@babel/template\").default;\n\nconst traverse = require(\"@babel/traverse\").default;\n\nconst types = require(\"@babel/types\");\n\nconst invariant = require(\"invariant\");\n\nconst nullthrows = require(\"nullthrows\");\n\nconst { isImport } = types;\n\n/**\n * Transform all the calls to `require()` and `import()` in a file into ID-\n * independent code, and return the list of dependencies. For example, a call\n * like `require('Foo')` could be transformed to `require(_depMap[3], 'Foo')`\n * where `_depMap` is provided by the outer scope. As such, we don't need to\n * know the actual module ID.\n *\n * The second argument is only provided for debugging purposes.\n */\nfunction collectDependencies(ast, options) {\n  var _options$dependencyRe, _options$dependencyTr;\n\n  const visited = new WeakSet();\n  const state = {\n    asyncRequireModulePathStringLiteral: null,\n    dependencyCalls: new Set(),\n    dependencyRegistry:\n      (_options$dependencyRe = options.dependencyRegistry) !== null &&\n      _options$dependencyRe !== void 0\n        ? _options$dependencyRe\n        : new DefaultModuleDependencyRegistry(),\n    dependencyTransformer:\n      (_options$dependencyTr = options.dependencyTransformer) !== null &&\n      _options$dependencyTr !== void 0\n        ? _options$dependencyTr\n        : DefaultDependencyTransformer,\n    dependencyMapIdentifier: null,\n    dynamicRequires: options.dynamicRequires,\n    keepRequireNames: options.keepRequireNames,\n    allowOptionalDependencies: options.allowOptionalDependencies,\n  };\n  const visitor = {\n    CallExpression(path, state) {\n      if (visited.has(path.node)) {\n        return;\n      }\n\n      const callee = path.node.callee;\n      const name = callee.type === \"Identifier\" ? callee.name : null;\n\n      if (isImport(callee)) {\n        processImportCall(path, state, {\n          asyncType: \"async\",\n        });\n        return;\n      }\n\n      if (name === \"__prefetchImport\" && !path.scope.getBinding(name)) {\n        processImportCall(path, state, {\n          asyncType: \"prefetch\",\n        });\n        return;\n      }\n\n      if (name === \"__jsResource\" && !path.scope.getBinding(name)) {\n        processImportCall(path, state, {\n          asyncType: \"async\",\n          jsResource: true,\n        });\n        return;\n      }\n\n      if (\n        name === \"__conditionallySplitJSResource\" &&\n        !path.scope.getBinding(name)\n      ) {\n        const args = path.get(\"arguments\");\n        invariant(Array.isArray(args), \"Expected arguments to be an array\");\n        processImportCall(path, state, {\n          asyncType: \"async\",\n          jsResource: true,\n          splitCondition: args[1],\n        });\n        return;\n      }\n\n      if (\n        name != null &&\n        state.dependencyCalls.has(name) &&\n        !path.scope.getBinding(name)\n      ) {\n        processRequireCall(path, state);\n        visited.add(path.node);\n      }\n    },\n\n    ImportDeclaration: collectImports,\n    ExportNamedDeclaration: collectImports,\n    ExportAllDeclaration: collectImports,\n\n    Program(path, state) {\n      state.asyncRequireModulePathStringLiteral = types.stringLiteral(\n        options.asyncRequireModulePath\n      );\n\n      if (options.dependencyMapName != null) {\n        state.dependencyMapIdentifier = types.identifier(\n          options.dependencyMapName\n        );\n      } else {\n        state.dependencyMapIdentifier =\n          path.scope.generateUidIdentifier(\"dependencyMap\");\n      }\n\n      state.dependencyCalls = new Set([\"require\", ...options.inlineableCalls]);\n    },\n  };\n  traverse(ast, visitor, null, state);\n  const collectedDependencies = state.dependencyRegistry.getDependencies(); // Compute the list of dependencies.\n\n  const dependencies = new Array(collectedDependencies.length);\n\n  for (const { index, name, ...dependencyData } of collectedDependencies) {\n    dependencies[index] = {\n      name,\n      data: dependencyData,\n    };\n  }\n\n  return {\n    ast,\n    dependencies,\n    dependencyMapName: nullthrows(state.dependencyMapIdentifier).name,\n  };\n}\n\nfunction collectImports(path, state) {\n  if (path.node.source) {\n    registerDependency(\n      state,\n      {\n        name: path.node.source.value,\n        asyncType: null,\n        optional: false,\n      },\n      path\n    );\n  }\n}\n\nfunction processImportCall(path, state, options) {\n  const name = getModuleNameFromCallArgs(path);\n\n  if (name == null) {\n    throw new InvalidRequireCallError(path);\n  }\n\n  const dep = registerDependency(\n    state,\n    {\n      name,\n      asyncType: options.asyncType,\n      splitCondition: options.splitCondition,\n      optional: isOptionalDependency(name, path, state),\n    },\n    path\n  );\n  const transformer = state.dependencyTransformer;\n\n  if (options.jsResource) {\n    transformer.transformJSResource(path, dep, state);\n  } else if (options.asyncType === \"async\") {\n    transformer.transformImportCall(path, dep, state);\n  } else {\n    transformer.transformPrefetch(path, dep, state);\n  }\n}\n\nfunction processRequireCall(path, state) {\n  const name = getModuleNameFromCallArgs(path);\n  const transformer = state.dependencyTransformer;\n\n  if (name == null) {\n    if (state.dynamicRequires === \"reject\") {\n      throw new InvalidRequireCallError(path);\n    }\n\n    transformer.transformIllegalDynamicRequire(path, state);\n    return;\n  }\n\n  const dep = registerDependency(\n    state,\n    {\n      name,\n      asyncType: null,\n      optional: isOptionalDependency(name, path, state),\n    },\n    path\n  );\n  transformer.transformSyncRequire(path, dep, state);\n}\n\nfunction getNearestLocFromPath(path) {\n  var _current;\n\n  let current = path;\n\n  while (current && !current.node.loc) {\n    current = current.parentPath;\n  }\n\n  return (_current = current) === null || _current === void 0\n    ? void 0\n    : _current.node.loc;\n}\n\nfunction registerDependency(state, qualifier, path) {\n  const dependency = state.dependencyRegistry.registerDependency(qualifier);\n  const loc = getNearestLocFromPath(path);\n\n  if (loc != null) {\n    dependency.locs.push(loc);\n  }\n\n  return dependency;\n}\n\nfunction isOptionalDependency(name, path, state) {\n  var _state$asyncRequireMo;\n\n  const { allowOptionalDependencies } = state; // The async require module is a 'built-in'. Resolving should never fail -> treat it as non-optional.\n\n  if (\n    name ===\n    ((_state$asyncRequireMo = state.asyncRequireModulePathStringLiteral) ===\n      null || _state$asyncRequireMo === void 0\n      ? void 0\n      : _state$asyncRequireMo.value)\n  ) {\n    return false;\n  }\n\n  const isExcluded = () =>\n    Array.isArray(allowOptionalDependencies.exclude) &&\n    allowOptionalDependencies.exclude.includes(name);\n\n  if (!allowOptionalDependencies || isExcluded()) {\n    return false;\n  } // Valid statement stack for single-level try-block: expressionStatement -> blockStatement -> tryStatement\n\n  let sCount = 0;\n  let p = path;\n\n  while (p && sCount < 3) {\n    if (p.isStatement()) {\n      if (p.node.type === \"BlockStatement\") {\n        // A single-level should have the tryStatement immediately followed BlockStatement\n        // with the key 'block' to distinguish from the finally block, which has key = 'finalizer'\n        return (\n          p.parentPath != null &&\n          p.parentPath.node.type === \"TryStatement\" &&\n          p.key === \"block\"\n        );\n      }\n\n      sCount += 1;\n    }\n\n    p = p.parentPath;\n  }\n\n  return false;\n}\n\nfunction getModuleNameFromCallArgs(path) {\n  const expectedCount =\n    path.node.callee.name === \"__conditionallySplitJSResource\" ? 2 : 1;\n  const args = path.get(\"arguments\");\n\n  if (!Array.isArray(args) || args.length !== expectedCount) {\n    throw new InvalidRequireCallError(path);\n  }\n\n  const result = args[0].evaluate();\n\n  if (result.confident && typeof result.value === \"string\") {\n    return result.value;\n  }\n\n  return null;\n}\n\ncollectDependencies.getModuleNameFromCallArgs = getModuleNameFromCallArgs;\n\nclass InvalidRequireCallError extends Error {\n  constructor({ node }) {\n    const line = node.loc && node.loc.start && node.loc.start.line;\n    super(\n      `Invalid call at line ${line || \"<unknown>\"}: ${generate(node).code}`\n    );\n  }\n}\n\ncollectDependencies.InvalidRequireCallError = InvalidRequireCallError;\n/**\n * Produces a Babel template that will throw at runtime when the require call\n * is reached. This makes dynamic require errors catchable by libraries that\n * want to use them.\n */\n\nconst dynamicRequireErrorTemplate = template.statement(`\n  (function(line) {\n    throw new Error(\n      'Dynamic require defined at line ' + line + '; not supported by Metro',\n    );\n  })(LINE)\n`);\n/**\n * Produces a Babel template that transforms an \"import(...)\" call into a\n * \"require(...)\" call to the asyncRequire specified.\n */\n\nconst makeAsyncRequireTemplate = template.statement(`\n  require(ASYNC_REQUIRE_MODULE_PATH)(MODULE_ID, MODULE_NAME)\n`);\nconst makeAsyncPrefetchTemplate = template.statement(`\n  require(ASYNC_REQUIRE_MODULE_PATH).prefetch(MODULE_ID, MODULE_NAME)\n`);\nconst makeJSResourceTemplate = template.statement(`\n  require(ASYNC_REQUIRE_MODULE_PATH).resource(MODULE_ID, MODULE_NAME)\n`);\nconst DefaultDependencyTransformer = {\n  transformSyncRequire(path, dependency, state) {\n    const moduleIDExpression = createModuleIDExpression(dependency, state);\n    path.node.arguments = state.keepRequireNames\n      ? [moduleIDExpression, types.stringLiteral(dependency.name)]\n      : [moduleIDExpression];\n  },\n\n  transformImportCall(path, dependency, state) {\n    path.replaceWith(\n      makeAsyncRequireTemplate({\n        ASYNC_REQUIRE_MODULE_PATH: nullthrows(\n          state.asyncRequireModulePathStringLiteral\n        ),\n        MODULE_ID: createModuleIDExpression(dependency, state),\n        MODULE_NAME: createModuleNameLiteral(dependency),\n      })\n    );\n  },\n\n  transformJSResource(path, dependency, state) {\n    path.replaceWith(\n      makeJSResourceTemplate({\n        ASYNC_REQUIRE_MODULE_PATH: nullthrows(\n          state.asyncRequireModulePathStringLiteral\n        ),\n        MODULE_ID: createModuleIDExpression(dependency, state),\n        MODULE_NAME: createModuleNameLiteral(dependency),\n      })\n    );\n  },\n\n  transformPrefetch(path, dependency, state) {\n    path.replaceWith(\n      makeAsyncPrefetchTemplate({\n        ASYNC_REQUIRE_MODULE_PATH: nullthrows(\n          state.asyncRequireModulePathStringLiteral\n        ),\n        MODULE_ID: createModuleIDExpression(dependency, state),\n        MODULE_NAME: createModuleNameLiteral(dependency),\n      })\n    );\n  },\n\n  transformIllegalDynamicRequire(path, state) {\n    var _path$node$loc$start$, _path$node$loc;\n\n    path.replaceWith(\n      dynamicRequireErrorTemplate({\n        LINE: types.numericLiteral(\n          (_path$node$loc$start$ =\n            (_path$node$loc = path.node.loc) === null ||\n            _path$node$loc === void 0\n              ? void 0\n              : _path$node$loc.start.line) !== null &&\n            _path$node$loc$start$ !== void 0\n            ? _path$node$loc$start$\n            : 0\n        ),\n      })\n    );\n  },\n};\n\nfunction createModuleIDExpression(dependency, state) {\n  return types.memberExpression(\n    nullthrows(state.dependencyMapIdentifier),\n    types.numericLiteral(dependency.index),\n    true\n  );\n}\n\nfunction createModuleNameLiteral(dependency) {\n  return types.stringLiteral(dependency.name);\n}\n\nclass DefaultModuleDependencyRegistry {\n  _dependencies = new Map();\n\n  registerDependency(qualifier) {\n    let dependency = this._dependencies.get(qualifier.name);\n\n    if (dependency == null) {\n      const newDependency = {\n        name: qualifier.name,\n        asyncType: qualifier.asyncType,\n        locs: [],\n        index: this._dependencies.size,\n      };\n\n      if (qualifier.optional) {\n        newDependency.isOptional = true;\n      }\n\n      dependency = newDependency;\n\n      this._dependencies.set(qualifier.name, dependency);\n    } else {\n      const original = dependency;\n      dependency = collapseDependencies(original, qualifier);\n\n      if (original !== dependency) {\n        this._dependencies.set(qualifier.name, dependency);\n      }\n    }\n\n    return dependency;\n  }\n\n  getDependencies() {\n    return Array.from(this._dependencies.values());\n  }\n}\n\nfunction collapseDependencies(dependency, qualifier) {\n  let collapsed = dependency; // A previously optionally required dependency was required non-optionaly.\n  // Mark it non optional for the whole module\n\n  if (collapsed.isOptional && !qualifier.optional) {\n    collapsed = { ...dependency, isOptional: false };\n  } // A previously asynchronously (or prefetch) required module was required synchronously.\n  // Make the dependency sync.\n\n  if (collapsed.asyncType != null && qualifier.asyncType == null) {\n    collapsed = { ...dependency, asyncType: null };\n  } // A prefetched dependency was required async in the module. Mark it as async.\n\n  if (collapsed.asyncType === \"prefetch\" && qualifier.asyncType === \"async\") {\n    collapsed = { ...dependency, asyncType: \"async\" };\n  }\n\n  return collapsed;\n}\n\nmodule.exports = collectDependencies;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}