{"ast":null,"code":"\"use strict\";\n\nvar uncaughtExceptionHandlers = process.listeners(\"uncaughtException\");\n\nvar hermesc = require(\"./emhermesc.js\")({\n  noInitialRun: true,\n  noExitRuntime: true,\n  print: function print() {},\n  printErr: function printErr() {}\n});\n\nvar hermesUncaughtExceptionHandler = process.listeners(\"uncaughtException\").find(function (listener) {\n  return !uncaughtExceptionHandlers.includes(listener);\n});\n\nif (hermesUncaughtExceptionHandler != null) {\n  process.removeListener(\"uncaughtException\", hermesUncaughtExceptionHandler);\n}\n\nvar compileToBytecode = hermesc.cwrap(\"hermesCompileToBytecode\", \"number\", [\"number\", \"number\", \"string\", \"number\", \"number\"]);\nvar getError = hermesc.cwrap(\"hermesCompileResult_getError\", \"string\", [\"number\"]);\nvar getBytecodeAddr = hermesc.cwrap(\"hermesCompileResult_getBytecodeAddr\", \"number\", [\"number\"]);\nvar getBytecodeSize = hermesc.cwrap(\"hermesCompileResult_getBytecodeSize\", \"number\", [\"number\"]);\nvar free = hermesc.cwrap(\"hermesCompileResult_free\", \"void\", [\"number\"]);\nvar props = JSON.parse(hermesc.ccall(\"hermesGetProperties\", \"string\", [], []));\n\nfunction strdup(str) {\n  var copy = Buffer.from(str, \"utf8\");\n  var size = copy.length + 1;\n\n  var address = hermesc._malloc(size);\n\n  if (!address) {\n    throw new Error(\"hermesc string allocation error\");\n  }\n\n  hermesc.HEAP8.set(copy, address);\n  hermesc.HEAP8[address + copy.length] = 0;\n  return {\n    ptr: address,\n    size: size\n  };\n}\n\nvar align = function align(offset) {\n  return offset + props.BYTECODE_ALIGNMENT - 1 & ~(props.BYTECODE_ALIGNMENT - 1);\n};\n\nmodule.exports.align = align;\n\nmodule.exports.compile = function (source, _ref) {\n  var sourceURL = _ref.sourceURL,\n      sourceMap = _ref.sourceMap;\n  var buffer = typeof source === \"string\" ? Buffer.from(source, \"utf8\") : source;\n\n  var address = hermesc._malloc(buffer.length + 1);\n\n  if (!address) {\n    throw new Error(\"Hermesc is out of memory.\");\n  }\n\n  try {\n    hermesc.HEAP8.set(buffer, address);\n    hermesc.HEAP8[address + buffer.length] = 0;\n    var sourceMapNotNull = sourceMap !== null && sourceMap !== void 0 ? sourceMap : \"\";\n    var mapOnHeap = strdup(sourceMapNotNull);\n    var result;\n\n    try {\n      result = compileToBytecode(address, buffer.length + 1, sourceURL, mapOnHeap.ptr, mapOnHeap.size);\n    } finally {\n      hermesc._free(mapOnHeap.ptr);\n    }\n\n    try {\n      var error = getError(result);\n\n      if (error) {\n        throw new Error(error);\n      }\n\n      var bufferFromHBC = Buffer.from(hermesc.HEAP8.buffer, getBytecodeAddr(result), getBytecodeSize(result));\n      var bytecode = Buffer.alloc(align(bufferFromHBC.length));\n      bufferFromHBC.copy(bytecode, 0);\n      return {\n        bytecode: bytecode\n      };\n    } finally {\n      free(result);\n    }\n  } finally {\n    hermesc._free(address);\n  }\n};\n\nmodule.exports.validateBytecodeModule = function (bytecode, offset) {\n  if ((bytecode.byteOffset + offset) % props.BYTECODE_ALIGNMENT) {\n    throw new Error(\"Bytecode is not aligned to \" + props.BYTECODE_ALIGNMENT + \".\");\n  }\n\n  var fileLength = bytecode.readUInt32LE(offset + props.LENGTH_OFFSET);\n\n  if (bytecode.length - offset < props.HEADER_SIZE || bytecode.length - offset < fileLength) {\n    throw new Error(\"Bytecode buffer is too small.\");\n  }\n\n  if (bytecode.readUInt32LE(offset + 0) !== props.MAGIC[0] || bytecode.readUInt32LE(offset + 4) !== props.MAGIC[1]) {\n    throw new Error(\"Bytecode buffer is missing magic value.\");\n  }\n\n  var version = bytecode.readUInt32LE(offset + 8);\n\n  if (version !== props.VERSION) {\n    throw new Error(\"Bytecode version is \" + version + \" but \" + props.VERSION + \" is required.\");\n  }\n};\n\nmodule.exports.getFileLength = function (bytecode, offset) {\n  return bytecode.readUInt32LE(offset + props.LENGTH_OFFSET);\n};\n\nmodule.exports.VERSION = props.VERSION;","map":{"version":3,"names":["uncaughtExceptionHandlers","process","listeners","hermesc","require","noInitialRun","noExitRuntime","print","printErr","hermesUncaughtExceptionHandler","find","listener","includes","removeListener","compileToBytecode","cwrap","getError","getBytecodeAddr","getBytecodeSize","free","props","JSON","parse","ccall","strdup","str","copy","Buffer","from","size","length","address","_malloc","Error","HEAP8","set","ptr","align","offset","BYTECODE_ALIGNMENT","module","exports","compile","source","sourceURL","sourceMap","buffer","sourceMapNotNull","mapOnHeap","result","_free","error","bufferFromHBC","bytecode","alloc","validateBytecodeModule","byteOffset","fileLength","readUInt32LE","LENGTH_OFFSET","HEADER_SIZE","MAGIC","version","VERSION","getFileLength"],"sources":["/Users/hozaifa/Documents/Uni App Github/node_modules/@react-native-community/cli-plugin-metro/node_modules/metro-hermes-compiler/src/index.js"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *\n * @format\n */\n\"use strict\"; // Capture any uncaughtException listeners already set, see below.\n\nconst uncaughtExceptionHandlers = process.listeners(\"uncaughtException\");\n\nconst hermesc = require(\"./emhermesc.js\")({\n  noInitialRun: true,\n  noExitRuntime: true,\n  // Do not call console methods\n  print: () => {},\n  printErr: () => {},\n}); // Workaround: Emscripten adds an uncaught exception listener on startup, which\n// rethrows and causes node to exit with code 7 and print emhermesc.js (1.4MB)\n// to stdout. This removes any newly-set listeners.\n//\n// Remove when emhermesc.js is rebuilt with NODEJS_CATCH_EXIT=0 (D34790356)\n\nconst hermesUncaughtExceptionHandler = process\n  .listeners(\"uncaughtException\")\n  .find((listener) => !uncaughtExceptionHandlers.includes(listener));\n\nif (hermesUncaughtExceptionHandler != null) {\n  process.removeListener(\"uncaughtException\", hermesUncaughtExceptionHandler);\n}\n\nconst compileToBytecode = hermesc.cwrap(\"hermesCompileToBytecode\", \"number\", [\n  \"number\",\n  \"number\",\n  \"string\",\n  \"number\",\n  \"number\",\n]);\nconst getError = hermesc.cwrap(\"hermesCompileResult_getError\", \"string\", [\n  \"number\",\n]);\nconst getBytecodeAddr = hermesc.cwrap(\n  \"hermesCompileResult_getBytecodeAddr\",\n  \"number\",\n  [\"number\"]\n);\nconst getBytecodeSize = hermesc.cwrap(\n  \"hermesCompileResult_getBytecodeSize\",\n  \"number\",\n  [\"number\"]\n);\nconst free = hermesc.cwrap(\"hermesCompileResult_free\", \"void\", [\"number\"]);\nconst props = JSON.parse(\n  hermesc.ccall(\"hermesGetProperties\", \"string\", [], [])\n);\n\nfunction strdup(str) {\n  var copy = Buffer.from(str, \"utf8\");\n  var size = copy.length + 1;\n\n  var address = hermesc._malloc(size);\n\n  if (!address) {\n    throw new Error(\"hermesc string allocation error\");\n  }\n\n  hermesc.HEAP8.set(copy, address);\n  hermesc.HEAP8[address + copy.length] = 0;\n  return {\n    ptr: address,\n    size,\n  };\n}\n\nconst align = (offset) =>\n  /* eslint-disable-next-line no-bitwise */\n  (offset + props.BYTECODE_ALIGNMENT - 1) & ~(props.BYTECODE_ALIGNMENT - 1);\n\nmodule.exports.align = align;\n\nmodule.exports.compile = function (source, { sourceURL, sourceMap }) {\n  const buffer =\n    typeof source === \"string\" ? Buffer.from(source, \"utf8\") : source;\n\n  const address = hermesc._malloc(buffer.length + 1);\n\n  if (!address) {\n    throw new Error(\"Hermesc is out of memory.\");\n  }\n\n  try {\n    hermesc.HEAP8.set(buffer, address);\n    hermesc.HEAP8[address + buffer.length] = 0; // Strings are passed on the stack by default. Explicitly pass the source map\n    // on the heap to avoid problems with large ones.\n\n    const sourceMapNotNull =\n      sourceMap !== null && sourceMap !== void 0 ? sourceMap : \"\";\n    const mapOnHeap = strdup(sourceMapNotNull);\n    let result;\n\n    try {\n      result = compileToBytecode(\n        address,\n        buffer.length + 1,\n        sourceURL,\n        mapOnHeap.ptr,\n        mapOnHeap.size\n      );\n    } finally {\n      hermesc._free(mapOnHeap.ptr);\n    }\n\n    try {\n      const error = getError(result);\n\n      if (error) {\n        throw new Error(error);\n      }\n\n      const bufferFromHBC = Buffer.from(\n        hermesc.HEAP8.buffer,\n        getBytecodeAddr(result),\n        getBytecodeSize(result)\n      );\n      const bytecode = Buffer.alloc(align(bufferFromHBC.length));\n      bufferFromHBC.copy(bytecode, 0);\n      return {\n        bytecode,\n      };\n    } finally {\n      free(result);\n    }\n  } finally {\n    hermesc._free(address);\n  }\n};\n\nmodule.exports.validateBytecodeModule = function (bytecode, offset) {\n  if ((bytecode.byteOffset + offset) % props.BYTECODE_ALIGNMENT) {\n    throw new Error(\n      \"Bytecode is not aligned to \" + props.BYTECODE_ALIGNMENT + \".\"\n    );\n  }\n\n  const fileLength = bytecode.readUInt32LE(offset + props.LENGTH_OFFSET);\n\n  if (\n    bytecode.length - offset < props.HEADER_SIZE ||\n    bytecode.length - offset < fileLength\n  ) {\n    throw new Error(\"Bytecode buffer is too small.\");\n  }\n\n  if (\n    bytecode.readUInt32LE(offset + 0) !== props.MAGIC[0] ||\n    bytecode.readUInt32LE(offset + 4) !== props.MAGIC[1]\n  ) {\n    throw new Error(\"Bytecode buffer is missing magic value.\");\n  }\n\n  const version = bytecode.readUInt32LE(offset + 8);\n\n  if (version !== props.VERSION) {\n    throw new Error(\n      \"Bytecode version is \" +\n        version +\n        \" but \" +\n        props.VERSION +\n        \" is required.\"\n    );\n  }\n};\n\nmodule.exports.getFileLength = function (bytecode, offset) {\n  return bytecode.readUInt32LE(offset + props.LENGTH_OFFSET);\n};\n\nmodule.exports.VERSION = props.VERSION;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}