{"ast":null,"code":"\"use strict\";\n\nvar _inherits = require(\"@babel/runtime/helpers/inherits\");\n\nvar _possibleConstructorReturn = require(\"@babel/runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"@babel/runtime/helpers/getPrototypeOf\");\n\nvar _toConsumableArray = require(\"@babel/runtime/helpers/toConsumableArray\");\n\nvar _slicedToArray = require(\"@babel/runtime/helpers/slicedToArray\");\n\nvar _classCallCheck = require(\"@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"@babel/runtime/helpers/createClass\");\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _createForOfIteratorHelperLoose(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (it) return (it = it.call(o)).next.bind(it); if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nvar invariant = require(\"invariant\");\n\nvar CHILDREN_FIELD_TYPE = \"__CHILDREN__\";\n\nvar ChromeHeapSnapshotProcessor = function () {\n  function ChromeHeapSnapshotProcessor(snapshotData) {\n    _classCallCheck(this, ChromeHeapSnapshotProcessor);\n\n    this._snapshotData = snapshotData;\n    this._globalStringTable = new ChromeHeapSnapshotStringTable(this._snapshotData.strings);\n  }\n\n  _createClass(ChromeHeapSnapshotProcessor, [{\n    key: \"traceFunctionInfos\",\n    value: function traceFunctionInfos() {\n      return new ChromeHeapSnapshotRecordIterator(this._snapshotData.trace_function_infos, this._snapshotData.snapshot.meta.trace_function_info_fields, {\n        name: \"string\",\n        script_name: \"string\"\n      }, this._globalStringTable, undefined);\n    }\n  }, {\n    key: \"locations\",\n    value: function locations() {\n      return new ChromeHeapSnapshotRecordIterator(this._snapshotData.locations, this._snapshotData.snapshot.meta.location_fields, null, this._globalStringTable, undefined);\n    }\n  }, {\n    key: \"nodes\",\n    value: function nodes() {\n      return new ChromeHeapSnapshotRecordIterator(this._snapshotData.nodes, this._snapshotData.snapshot.meta.node_fields, this._snapshotData.snapshot.meta.node_types, this._globalStringTable, undefined);\n    }\n  }, {\n    key: \"edges\",\n    value: function edges() {\n      return new ChromeHeapSnapshotRecordIterator(this._snapshotData.edges, this._snapshotData.snapshot.meta.edge_fields, this._snapshotData.snapshot.meta.edge_types, this._globalStringTable, undefined);\n    }\n  }, {\n    key: \"traceTree\",\n    value: function traceTree() {\n      return new ChromeHeapSnapshotRecordIterator(this._snapshotData.trace_tree, this._snapshotData.snapshot.meta.trace_node_fields, {\n        children: CHILDREN_FIELD_TYPE\n      }, this._globalStringTable, undefined);\n    }\n  }]);\n\n  return ChromeHeapSnapshotProcessor;\n}();\n\nvar ChromeHeapSnapshotStringTable = function () {\n  function ChromeHeapSnapshotStringTable(strings) {\n    _classCallCheck(this, ChromeHeapSnapshotStringTable);\n\n    this._strings = strings;\n    this._indexCache = new Map();\n  }\n\n  _createClass(ChromeHeapSnapshotStringTable, [{\n    key: \"add\",\n    value: function add(value) {\n      this._syncIndexCache();\n\n      var index = this._indexCache.get(value);\n\n      if (index != null) {\n        return index;\n      }\n\n      index = this._strings.length;\n\n      this._strings.push(value);\n\n      this._indexCache.set(value, index);\n\n      return index;\n    }\n  }, {\n    key: \"get\",\n    value: function get(index) {\n      invariant(index >= 0 && index < this._strings.length, \"index out of string table range\");\n      return this._strings[index];\n    }\n  }, {\n    key: \"_syncIndexCache\",\n    value: function _syncIndexCache() {\n      if (this._strings.length > this._indexCache.size) {\n        for (var i = this._indexCache.size; i < this._strings.length; ++i) {\n          this._indexCache.set(this._strings[i], i);\n        }\n      }\n    }\n  }]);\n\n  return ChromeHeapSnapshotStringTable;\n}();\n\nvar ChromeHeapSnapshotRecordAccessor = function () {\n  function ChromeHeapSnapshotRecordAccessor(buffer, recordFields, recordTypes, globalStringTable, position, parent) {\n    _classCallCheck(this, ChromeHeapSnapshotRecordAccessor);\n\n    if (parent) {\n      this._recordSize = parent._recordSize;\n      this._fieldToOffset = parent._fieldToOffset;\n      this._fieldToType = parent._fieldToType;\n    } else {\n      this._recordSize = recordFields.length;\n      this._fieldToOffset = new Map(Object.entries(recordFields).map(function (_ref) {\n        var _ref2 = _slicedToArray(_ref, 2),\n            offsetStr = _ref2[0],\n            name = _ref2[1];\n\n        return [String(name), Number(offsetStr)];\n      }));\n\n      if (Array.isArray(recordTypes)) {\n        this._fieldToType = new Map(Object.entries(recordTypes).map(function (_ref3) {\n          var _ref4 = _slicedToArray(_ref3, 2),\n              offsetStr = _ref4[0],\n              type = _ref4[1];\n\n          return [recordFields[Number(offsetStr)], type];\n        }));\n      } else {\n        this._fieldToType = new Map(Object.entries(recordTypes || {}));\n      }\n    }\n\n    this._buffer = buffer;\n    this._position = position;\n    invariant(this._position % this._recordSize === 0, \"Record accessor constructed at invalid offset\");\n    invariant(this._buffer.length % this._recordSize === 0, \"Record accessor constructed with wrong size buffer\");\n    this._globalStringTable = globalStringTable;\n  }\n\n  _createClass(ChromeHeapSnapshotRecordAccessor, [{\n    key: \"getString\",\n    value: function getString(field) {\n      var dynamicValue = this._getScalar(field);\n\n      if (typeof dynamicValue === \"string\") {\n        return dynamicValue;\n      }\n\n      throw new Error(\"Not a string or enum field: \" + field);\n    }\n  }, {\n    key: \"getNumber\",\n    value: function getNumber(field) {\n      var dynamicValue = this._getScalar(field);\n\n      if (typeof dynamicValue === \"number\") {\n        return dynamicValue;\n      }\n\n      throw new Error(\"Not a number field: \" + field);\n    }\n  }, {\n    key: \"getChildren\",\n    value: function getChildren(field) {\n      var fieldType = this._fieldToType.get(field);\n\n      if (fieldType !== CHILDREN_FIELD_TYPE) {\n        throw new Error(\"Not a children field: \" + field);\n      }\n\n      var childrenBuffer = this._getRaw(field);\n\n      invariant(Array.isArray(childrenBuffer), \"Expected array in children-typed field\");\n      return new ChromeHeapSnapshotRecordIterator(childrenBuffer, [], null, this._globalStringTable, -this._fieldToOffset.size, this);\n    }\n  }, {\n    key: \"setString\",\n    value: function setString(field, value) {\n      this._setRaw(field, this._encodeString(field, value));\n    }\n  }, {\n    key: \"setNumber\",\n    value: function setNumber(field, value) {\n      var fieldType = this._fieldToType.get(field);\n\n      if (Array.isArray(fieldType) || fieldType === \"string\" || fieldType === CHILDREN_FIELD_TYPE) {\n        throw new Error(\"Not a number field: \" + field);\n      }\n\n      this._setRaw(field, value);\n    }\n  }, {\n    key: \"moveToRecord\",\n    value: function moveToRecord(recordIndex) {\n      this._moveToPosition(recordIndex * this._recordSize);\n    }\n  }, {\n    key: \"append\",\n    value: function append(record) {\n      var savedPosition = this._position;\n\n      try {\n        return this.moveAndInsert(this._buffer.length / this._recordSize, record);\n      } finally {\n        this._position = savedPosition;\n      }\n    }\n  }, {\n    key: \"moveAndInsert\",\n    value: function moveAndInsert(recordIndex, record) {\n      this._moveToPosition(recordIndex * this._recordSize, true);\n\n      var didResizeBuffer = false;\n\n      try {\n        var _this$_buffer;\n\n        for (var _iterator = _createForOfIteratorHelperLoose(this._fieldToOffset.keys()), _step; !(_step = _iterator()).done;) {\n          var field = _step.value;\n\n          if (!Object.prototype.hasOwnProperty.call(record, field)) {\n            throw new Error(\"Missing value for field: \" + field);\n          }\n        }\n\n        (_this$_buffer = this._buffer).splice.apply(_this$_buffer, [this._position, 0].concat(_toConsumableArray(new Array(this._recordSize))));\n\n        didResizeBuffer = true;\n\n        for (var _i = 0, _Object$keys = Object.keys(record); _i < _Object$keys.length; _i++) {\n          var _field = _Object$keys[_i];\n\n          this._set(_field, record[_field]);\n        }\n\n        return this._position / this._recordSize;\n      } catch (e) {\n        if (didResizeBuffer) {\n          this._buffer.splice(this._position, this._recordSize);\n        }\n\n        throw e;\n      }\n    }\n  }, {\n    key: \"protectedHasNext\",\n    value: function protectedHasNext() {\n      if (this._position < 0) {\n        return this._buffer.length > 0;\n      }\n\n      return this._position < this._buffer.length;\n    }\n  }, {\n    key: \"protectedTryMoveNext\",\n    value: function protectedTryMoveNext() {\n      if (this.protectedHasNext()) {\n        this._moveToPosition(this._position + this._recordSize, true);\n      }\n    }\n  }, {\n    key: \"_getRaw\",\n    value: function _getRaw(field) {\n      this._validatePosition();\n\n      var offset = this._fieldToOffset.get(field);\n\n      if (offset == null) {\n        throw new Error(\"Unknown field: \" + field);\n      }\n\n      return this._buffer[this._position + offset];\n    }\n  }, {\n    key: \"_getScalar\",\n    value: function _getScalar(field) {\n      var rawValue = this._getRaw(field);\n\n      if (Array.isArray(rawValue)) {\n        throw new Error(\"Not a scalar field: \" + field);\n      }\n\n      var fieldType = this._fieldToType.get(field);\n\n      if (Array.isArray(fieldType)) {\n        invariant(rawValue >= 0 && rawValue < fieldType.length, \"raw value does not match field enum type\");\n        return fieldType[rawValue];\n      }\n\n      if (fieldType === \"string\") {\n        return this._globalStringTable.get(rawValue);\n      }\n\n      return rawValue;\n    }\n  }, {\n    key: \"_setRaw\",\n    value: function _setRaw(field, rawValue) {\n      this._validatePosition();\n\n      var offset = this._fieldToOffset.get(field);\n\n      if (offset == null) {\n        throw new Error(\"Unknown field: \" + field);\n      }\n\n      this._buffer[this._position + offset] = rawValue;\n    }\n  }, {\n    key: \"_set\",\n    value: function _set(field, value) {\n      if (typeof value === \"string\") {\n        this.setString(field, value);\n      } else if (typeof value === \"number\") {\n        this.setNumber(field, value);\n      } else if (Array.isArray(value)) {\n        this._setChildren(field, value);\n      } else {\n        throw new Error(\"Unsupported value for field: \" + field);\n      }\n    }\n  }, {\n    key: \"_setChildren\",\n    value: function _setChildren(field, value) {\n      var fieldType = this._fieldToType.get(field);\n\n      if (fieldType !== CHILDREN_FIELD_TYPE) {\n        throw new Error(\"Not a children field: \" + field);\n      }\n\n      this._setRaw(field, []);\n\n      var childIt = this.getChildren(field);\n\n      for (var _iterator2 = _createForOfIteratorHelperLoose(value), _step2; !(_step2 = _iterator2()).done;) {\n        var child = _step2.value;\n        childIt.append(child);\n      }\n    }\n  }, {\n    key: \"_encodeString\",\n    value: function _encodeString(field, value) {\n      var fieldType = this._fieldToType.get(field);\n\n      if (Array.isArray(fieldType)) {\n        var index = fieldType.indexOf(value);\n        invariant(index >= 0, \"Cannot define new values in enum field\");\n        return index;\n      }\n\n      if (fieldType === \"string\") {\n        return this._globalStringTable.add(value);\n      }\n\n      throw new Error(\"Not a string or enum field: \" + field);\n    }\n  }, {\n    key: \"_validatePosition\",\n    value: function _validatePosition() {\n      var allowEnd = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      var position = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this._position;\n\n      if (!Number.isInteger(position)) {\n        throw new Error(\"Position \" + position + \" is not an integer\");\n      }\n\n      if (position % this._recordSize !== 0) {\n        throw new Error(\"Position \" + position + \" is not a multiple of record size \" + this._recordSize);\n      }\n\n      if (position < 0) {\n        throw new Error(\"Position \" + position + \" is out of range\");\n      }\n\n      var maxPosition = allowEnd ? this._buffer.length : this._buffer.length - 1;\n\n      if (position > maxPosition) {\n        throw new Error(\"Position \" + position + \" is out of range\");\n      }\n\n      if (this._buffer.length - position < this._recordSize) {\n        if (!(allowEnd && this._buffer.length === position)) {\n          throw new Error(\"Record at position \" + position + \" is truncated: expected \" + this._recordSize + \" fields but found \" + (this._buffer.length - position));\n        }\n      }\n    }\n  }, {\n    key: \"_moveToPosition\",\n    value: function _moveToPosition(nextPosition) {\n      var allowEnd = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n      this._validatePosition(allowEnd, nextPosition);\n\n      this._position = nextPosition;\n    }\n  }]);\n\n  return ChromeHeapSnapshotRecordAccessor;\n}();\n\nvar ChromeHeapSnapshotRecordIterator = function (_ChromeHeapSnapshotRe, _Symbol$iterator) {\n  _inherits(ChromeHeapSnapshotRecordIterator, _ChromeHeapSnapshotRe);\n\n  var _super = _createSuper(ChromeHeapSnapshotRecordIterator);\n\n  function ChromeHeapSnapshotRecordIterator(buffer, recordFields, recordTypes, globalStringTable) {\n    var position = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : -recordFields.length;\n    var parent = arguments.length > 5 ? arguments[5] : undefined;\n\n    _classCallCheck(this, ChromeHeapSnapshotRecordIterator);\n\n    return _super.call(this, buffer, recordFields, recordTypes, globalStringTable, position, parent);\n  }\n\n  _createClass(ChromeHeapSnapshotRecordIterator, [{\n    key: \"next\",\n    value: function next() {\n      this.protectedTryMoveNext();\n      return {\n        done: !this.protectedHasNext(),\n        value: this\n      };\n    }\n  }, {\n    key: _Symbol$iterator,\n    value: function value() {\n      return this;\n    }\n  }]);\n\n  return ChromeHeapSnapshotRecordIterator;\n}(ChromeHeapSnapshotRecordAccessor, Symbol.iterator);\n\nmodule.exports = {\n  ChromeHeapSnapshotProcessor: ChromeHeapSnapshotProcessor\n};","map":{"version":3,"names":["invariant","require","CHILDREN_FIELD_TYPE","ChromeHeapSnapshotProcessor","snapshotData","_snapshotData","_globalStringTable","ChromeHeapSnapshotStringTable","strings","ChromeHeapSnapshotRecordIterator","trace_function_infos","snapshot","meta","trace_function_info_fields","name","script_name","undefined","locations","location_fields","nodes","node_fields","node_types","edges","edge_fields","edge_types","trace_tree","trace_node_fields","children","_strings","_indexCache","Map","value","_syncIndexCache","index","get","length","push","set","size","i","ChromeHeapSnapshotRecordAccessor","buffer","recordFields","recordTypes","globalStringTable","position","parent","_recordSize","_fieldToOffset","_fieldToType","Object","entries","map","offsetStr","String","Number","Array","isArray","type","_buffer","_position","field","dynamicValue","_getScalar","Error","fieldType","childrenBuffer","_getRaw","_setRaw","_encodeString","recordIndex","_moveToPosition","record","savedPosition","moveAndInsert","didResizeBuffer","keys","prototype","hasOwnProperty","call","splice","_set","e","protectedHasNext","_validatePosition","offset","rawValue","setString","setNumber","_setChildren","childIt","getChildren","child","append","indexOf","add","allowEnd","isInteger","maxPosition","nextPosition","protectedTryMoveNext","done","Symbol","iterator","module","exports"],"sources":["/Users/hozaifa/Documents/Uni App Github/node_modules/@react-native-community/cli-plugin-metro/node_modules/metro-symbolicate/src/ChromeHeapSnapshot.js"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *\n * @format\n */\n\"use strict\";\n\nconst invariant = require(\"invariant\");\n\n// The snapshot metadata doesn't have a type describing the `children` field\n// of `trace_tree`, but modeling it as a type works really well. So we make up\n// our own name for it and use that internally.\nconst CHILDREN_FIELD_TYPE = \"__CHILDREN__\"; // An adapter for reading and mutating a Chrome heap snapshot in-place,\n// including safely decoding and encoding fields that point into the global\n// string table and into enum types.\n// Care is taken to adhere to the self-describing heap snapshot schema, but\n// we make some additional assumptions based on what Chrome hardcodes (where\n// the format leaves us no other choice).\n\nclass ChromeHeapSnapshotProcessor {\n  // The raw snapshot data provided to this processor. Mutable.\n  // An adapter for the global string table in the raw snapshot data.\n  // This is shared across all the iterators we will create.\n  constructor(snapshotData) {\n    this._snapshotData = snapshotData;\n    this._globalStringTable = new ChromeHeapSnapshotStringTable(\n      this._snapshotData.strings\n    );\n  }\n\n  traceFunctionInfos() {\n    return new ChromeHeapSnapshotRecordIterator( // Flow is being conservative here, but we'll never change a number into RawBuffer or vice versa.\n      // $FlowIgnore[incompatible-call]\n      this._snapshotData.trace_function_infos,\n      this._snapshotData.snapshot.meta.trace_function_info_fields,\n      {\n        name: \"string\",\n        script_name: \"string\",\n      },\n      this._globalStringTable,\n      undefined\n      /* start position */\n    );\n  }\n\n  locations() {\n    return new ChromeHeapSnapshotRecordIterator( // Flow is being conservative here, but we'll never change a number into RawBuffer or vice versa.\n      // $FlowIgnore[incompatible-call]\n      this._snapshotData.locations,\n      this._snapshotData.snapshot.meta.location_fields,\n      null,\n      this._globalStringTable,\n      undefined\n      /* start position */\n    );\n  }\n\n  nodes() {\n    return new ChromeHeapSnapshotRecordIterator( // Flow is being conservative here, but we'll never change a number into RawBuffer or vice versa.\n      // $FlowIgnore[incompatible-call]\n      this._snapshotData.nodes,\n      this._snapshotData.snapshot.meta.node_fields,\n      this._snapshotData.snapshot.meta.node_types,\n      this._globalStringTable,\n      undefined\n      /* start position */\n    );\n  }\n\n  edges() {\n    return new ChromeHeapSnapshotRecordIterator( // Flow is being conservative here, but we'll never change a number into RawBuffer or vice versa.\n      // $FlowIgnore[incompatible-call]\n      this._snapshotData.edges,\n      this._snapshotData.snapshot.meta.edge_fields,\n      this._snapshotData.snapshot.meta.edge_types,\n      this._globalStringTable,\n      undefined\n      /* start position */\n    );\n  }\n\n  traceTree() {\n    return new ChromeHeapSnapshotRecordIterator(\n      this._snapshotData.trace_tree,\n      this._snapshotData.snapshot.meta.trace_node_fields,\n      {\n        children: CHILDREN_FIELD_TYPE,\n      },\n      this._globalStringTable,\n      undefined\n      /* start position */\n    );\n  }\n} // An uniquing adapter for the heap snapshot's string table that allows\n// retrieving and adding strings.\n//\n// Assumptions:\n// 1. The string table is only manipulated via this class, and only via a\n//    single instance of it.\n// 2. The string table array is always mutated in-place rather than being\n//    copied / replaced with a new array in its containing object.\n\nclass ChromeHeapSnapshotStringTable {\n  constructor(strings) {\n    this._strings = strings;\n    this._indexCache = new Map(); // NOTE: _indexCache is lazily initialised in _syncIndexCache.\n  } // Looks up a string in the string table, adds it if necessary, and returns\n  // its index.\n\n  add(value) {\n    this._syncIndexCache();\n\n    let index = this._indexCache.get(value);\n\n    if (index != null) {\n      return index;\n    }\n\n    index = this._strings.length;\n\n    this._strings.push(value);\n\n    this._indexCache.set(value, index);\n\n    return index;\n  } // Retrieve the string at the given index.\n\n  get(index) {\n    invariant(\n      index >= 0 && index < this._strings.length,\n      \"index out of string table range\"\n    );\n    return this._strings[index];\n  } // Indexes the string table for fast lookup.\n\n  _syncIndexCache() {\n    // Because we only grow the string table and we assume it's unique to begin\n    // with, we only need to scan any strings that we may have appended since\n    // the last time we synced the index.\n    // NOTE: This is not even strictly necessary other than for the very first\n    // add() call, but it might allow us to do more complicated string table\n    // manipulation down the line.\n    if (this._strings.length > this._indexCache.size) {\n      for (let i = this._indexCache.size; i < this._strings.length; ++i) {\n        this._indexCache.set(this._strings[i], i);\n      }\n    }\n  }\n}\n\n// A cursor pointing to a record-aligned position in a 1D array of N records\n// each with K fields in a fixed order. Supports encoding/decoding field values\n// in the raw array according to a schema passed to the constructor.\n//\n// Field values are stored as either numbers (representing scalars) or arrays\n// (representing lists of nested records). Scalar fields may represent strings\n// in the string table, strings in an enum, or numbers. Nested record lists are\n// processed according to the same schema as their parent record.\n//\n// Setters directly mutate raw data in the buffer and in the string table.\nclass ChromeHeapSnapshotRecordAccessor {\n  // Fast lookup tables from field names to their offsets (required) and types\n  // (optional). These are shared with any child iterators.\n  // The number of fields in every record (i.e. K).\n  // The raw buffer. Mutable.\n  // The global string table. Mutable in the ways allowed by the string table\n  // class.\n  // The current position in the raw buffer.\n  constructor(\n    buffer,\n    recordFields, // recordTypes can be:\n    // 1. An array: Field types as described in the snapshot itself, e.g.\n    //    node_types, edge_types.\n    // 2. An object: Field types that are implicit (hardcoded in V8 / DevTools)\n    //    so we pass them in by field name.\n    // 3. null: No field types are known.\n    // Fields with unknown types are assumed to be numeric.\n    recordTypes,\n    globalStringTable,\n    position,\n    parent\n  ) {\n    if (parent) {\n      this._recordSize = parent._recordSize;\n      this._fieldToOffset = parent._fieldToOffset;\n      this._fieldToType = parent._fieldToType;\n    } else {\n      this._recordSize = recordFields.length;\n      this._fieldToOffset = new Map(\n        Object.entries(recordFields).map(([offsetStr, name]) => [\n          String(name),\n          Number(offsetStr),\n        ])\n      );\n\n      if (Array.isArray(recordTypes)) {\n        this._fieldToType = new Map(\n          Object.entries(recordTypes).map(([offsetStr, type]) => [\n            recordFields[Number(offsetStr)], // $FlowIssue[incompatible-call] Object.entries is incompletely typed\n            type,\n          ])\n        );\n      } else {\n        // $FlowIssue[incompatible-type-arg] Object.entries is incompletely typed\n        this._fieldToType = new Map(Object.entries(recordTypes || {}));\n      }\n    }\n\n    this._buffer = buffer;\n    this._position = position;\n    invariant(\n      this._position % this._recordSize === 0,\n      \"Record accessor constructed at invalid offset\"\n    );\n    invariant(\n      this._buffer.length % this._recordSize === 0,\n      \"Record accessor constructed with wrong size buffer\"\n    );\n    this._globalStringTable = globalStringTable;\n  }\n  /** Public API */\n  // Reads a scalar string or enum value from the given field.\n  // It's an error to read a number (or other non-string) field as a string.\n  // NOTE: The type \"string_or_number\" is always treated as a number and cannot\n  // be read using this method.\n\n  getString(field) {\n    const dynamicValue = this._getScalar(field);\n\n    if (typeof dynamicValue === \"string\") {\n      return dynamicValue;\n    }\n\n    throw new Error(\"Not a string or enum field: \" + field);\n  } // Reads a scalar numeric value from the given field.\n  // It's an error to read a string (or other non-number) field as a number.\n  // NOTE: The type \"string_or_number\" is always treated as a number.\n\n  getNumber(field) {\n    const dynamicValue = this._getScalar(field);\n\n    if (typeof dynamicValue === \"number\") {\n      return dynamicValue;\n    }\n\n    throw new Error(\"Not a number field: \" + field);\n  } // Returns an iterator over the children of this record that are stored in\n  // the given field (typically 'children'). Children conform to the same\n  // schema as the current record.\n\n  getChildren(field) {\n    const fieldType = this._fieldToType.get(field);\n\n    if (fieldType !== CHILDREN_FIELD_TYPE) {\n      throw new Error(\"Not a children field: \" + field);\n    }\n\n    const childrenBuffer = this._getRaw(field);\n\n    invariant(\n      Array.isArray(childrenBuffer),\n      \"Expected array in children-typed field\"\n    );\n    return new ChromeHeapSnapshotRecordIterator(\n      childrenBuffer,\n      [], // recordFields ignored when there's a parent\n      null, // recordTypes ignored when there's a parent\n      this._globalStringTable,\n      -this._fieldToOffset.size,\n      /* start position */\n      this\n    );\n  } // Writes a scalar string or enum value into the given field, updating the\n  // global string table as needed.\n  // It's an error to write anything other than a string into a string or enum\n  // field.\n  // It's an error to write an unknown enum value into an enum field.\n  // NOTE: The type \"string_or_number\" is always treated as a number and cannot\n  // be written using this method.\n\n  setString(field, value) {\n    this._setRaw(field, this._encodeString(field, value));\n  } // Writes a scalar numeric value into the given field.\n  // It's an error to write anything other than a number into a numeric field.\n  // NOTE: The type \"string_or_number\" is always treated as a number.\n\n  setNumber(field, value) {\n    const fieldType = this._fieldToType.get(field);\n\n    if (\n      Array.isArray(fieldType) ||\n      fieldType === \"string\" ||\n      fieldType === CHILDREN_FIELD_TYPE\n    ) {\n      throw new Error(\"Not a number field: \" + field);\n    }\n\n    this._setRaw(field, value);\n  } // Moves the cursor to a given index in the buffer (expressed in # of\n  // records, NOT fields).\n\n  moveToRecord(recordIndex) {\n    this._moveToPosition(recordIndex * this._recordSize);\n  } // Appends a new record at the end of the buffer.\n  //\n  // Returns the index of the appended record. All fields must be specified and\n  // have values of the correct types. The cursor may move while writing, but\n  // is guaranteed to return to its initial position when this function returns\n  // (or throws).\n\n  append(record) {\n    const savedPosition = this._position;\n\n    try {\n      return this.moveAndInsert(this._buffer.length / this._recordSize, record);\n    } finally {\n      this._position = savedPosition;\n    }\n  } // Moves the cursor to a given index in the buffer (expressed in # of\n  // records, NOT fields) and inserts a record.\n  //\n  // Returns the index of the inserted record. All fields must be specified and\n  // have values of the correct types. The given index may be the end of the\n  // buffer; otherwise existing records starting at the given index will be\n  // shifted to the right to accommodate the new record.\n  //\n  // NOTE: Inserting is a risky, low-level operation. Care must be taken not to\n  // desync buffers that implicitly or explicitly depend on one another (e.g.\n  // edge.to_node -> node position, cumulative node.edge_count -> edge indices).\n\n  moveAndInsert(recordIndex, record) {\n    this._moveToPosition(\n      recordIndex * this._recordSize,\n      /* allowEnd */\n      true\n    );\n\n    let didResizeBuffer = false;\n\n    try {\n      for (const field of this._fieldToOffset.keys()) {\n        // $FlowFixMe[method-unbinding] added when improving typing for this parameters\n        if (!Object.prototype.hasOwnProperty.call(record, field)) {\n          throw new Error(\"Missing value for field: \" + field);\n        }\n      }\n\n      this._buffer.splice(this._position, 0, ...new Array(this._recordSize));\n\n      didResizeBuffer = true;\n\n      for (const field of Object.keys(record)) {\n        this._set(field, record[field]);\n      }\n\n      return this._position / this._recordSize;\n    } catch (e) {\n      if (didResizeBuffer) {\n        // Roll back the write\n        this._buffer.splice(this._position, this._recordSize);\n      }\n\n      throw e;\n    }\n  }\n  /** \"Protected\" methods (please don't use) */\n  // Return true if we can advance the position by one record (including from\n  // the last record to the \"end\" position).\n\n  protectedHasNext() {\n    if (this._position < 0) {\n      // We haven't started iterating yet, so this might _be_ the end position.\n      return this._buffer.length > 0;\n    }\n\n    return this._position < this._buffer.length;\n  } // Move to the next record (or the end) if we're not already at the end.\n\n  protectedTryMoveNext() {\n    if (this.protectedHasNext()) {\n      this._moveToPosition(\n        this._position + this._recordSize,\n        /* allowEnd */\n        true\n      );\n    }\n  }\n  /** Private methods */\n  // Reads the raw numeric value of a field.\n\n  _getRaw(field) {\n    this._validatePosition();\n\n    const offset = this._fieldToOffset.get(field);\n\n    if (offset == null) {\n      throw new Error(\"Unknown field: \" + field);\n    }\n\n    return this._buffer[this._position + offset];\n  } // Decodes a scalar (string or number) field.\n\n  _getScalar(field) {\n    const rawValue = this._getRaw(field);\n\n    if (Array.isArray(rawValue)) {\n      throw new Error(\"Not a scalar field: \" + field);\n    }\n\n    const fieldType = this._fieldToType.get(field);\n\n    if (Array.isArray(fieldType)) {\n      invariant(\n        rawValue >= 0 && rawValue < fieldType.length,\n        \"raw value does not match field enum type\"\n      );\n      return fieldType[rawValue];\n    }\n\n    if (fieldType === \"string\") {\n      return this._globalStringTable.get(rawValue);\n    }\n\n    return rawValue;\n  } // Writes the raw value of a field.\n\n  _setRaw(field, rawValue) {\n    this._validatePosition();\n\n    const offset = this._fieldToOffset.get(field);\n\n    if (offset == null) {\n      throw new Error(\"Unknown field: \" + field);\n    }\n\n    this._buffer[this._position + offset] = rawValue;\n  } // Writes a scalar or children value to `field`, inferring the intended type\n  // based on the runtime type of `value`.\n\n  _set(field, value) {\n    if (typeof value === \"string\") {\n      this.setString(field, value);\n    } else if (typeof value === \"number\") {\n      this.setNumber(field, value);\n    } else if (Array.isArray(value)) {\n      this._setChildren(field, value);\n    } else {\n      throw new Error(\"Unsupported value for field: \" + field);\n    }\n  } // Writes a children array to `field` by appending each element of `value` to\n  // a new buffer using `append()`s semantics.\n\n  _setChildren(field, value) {\n    const fieldType = this._fieldToType.get(field);\n\n    if (fieldType !== CHILDREN_FIELD_TYPE) {\n      throw new Error(\"Not a children field: \" + field);\n    }\n\n    this._setRaw(field, []);\n\n    const childIt = this.getChildren(field);\n\n    for (const child of value) {\n      childIt.append(child);\n    }\n  } // Encodes a string value according to its field schema.\n  // The global string table may be updated as a side effect.\n\n  _encodeString(field, value) {\n    const fieldType = this._fieldToType.get(field);\n\n    if (Array.isArray(fieldType)) {\n      const index = fieldType.indexOf(value);\n      invariant(index >= 0, \"Cannot define new values in enum field\");\n      return index;\n    }\n\n    if (fieldType === \"string\") {\n      return this._globalStringTable.add(value);\n    }\n\n    throw new Error(\"Not a string or enum field: \" + field);\n  } // Asserts that the given position (default: the current position) is either\n  // a valid position for reading a record, or (if allowEnd is true) the end of\n  // the buffer.\n\n  _validatePosition(allowEnd = false, position = this._position) {\n    if (!Number.isInteger(position)) {\n      throw new Error(`Position ${position} is not an integer`);\n    }\n\n    if (position % this._recordSize !== 0) {\n      throw new Error(\n        `Position ${position} is not a multiple of record size ${this._recordSize}`\n      );\n    }\n\n    if (position < 0) {\n      throw new Error(`Position ${position} is out of range`);\n    }\n\n    const maxPosition = allowEnd\n      ? this._buffer.length\n      : this._buffer.length - 1;\n\n    if (position > maxPosition) {\n      throw new Error(`Position ${position} is out of range`);\n    }\n\n    if (this._buffer.length - position < this._recordSize) {\n      if (!(allowEnd && this._buffer.length === position)) {\n        throw new Error(\n          `Record at position ${position} is truncated: expected ${\n            this._recordSize\n          } fields but found ${this._buffer.length - position}`\n        );\n      }\n    }\n  } // Move to the given position or throw an error if it is invalid.\n\n  _moveToPosition(nextPosition, allowEnd = false) {\n    this._validatePosition(allowEnd, nextPosition);\n\n    this._position = nextPosition;\n  }\n} // $FlowIssue[prop-missing] Flow doesn't see that we implement the iteration protocol\n\nclass ChromeHeapSnapshotRecordIterator extends ChromeHeapSnapshotRecordAccessor {\n  constructor(\n    buffer,\n    recordFields,\n    recordTypes,\n    globalStringTable, // Initialise to \"before the first iteration\".\n    // The Accessor constructor intentionally checks only alignment, not range,\n    // so this works as long as we don't try to read/write (at which point\n    // validation will kick in).\n    position = -recordFields.length,\n    parent\n  ) {\n    super(\n      buffer,\n      recordFields,\n      recordTypes,\n      globalStringTable,\n      position,\n      parent\n    );\n  } // JS Iterator protocol\n\n  next() {\n    this.protectedTryMoveNext();\n    return {\n      done: !this.protectedHasNext(),\n      value: this,\n    };\n  } // JS Iterable protocol\n  // $FlowIssue[unsupported-syntax]\n\n  [Symbol.iterator]() {\n    return this;\n  }\n}\n\nmodule.exports = {\n  ChromeHeapSnapshotProcessor,\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}