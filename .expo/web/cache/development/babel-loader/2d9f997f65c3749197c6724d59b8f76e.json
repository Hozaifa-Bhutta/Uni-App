{"ast":null,"code":"\"use strict\";\n\nvar _defineProperty = require(\"@babel/runtime/helpers/defineProperty\");\n\nvar _regeneratorRuntime = require(\"@babel/runtime/regenerator\");\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nfunction _chalk() {\n  var data = _interopRequireDefault(require(\"chalk\"));\n\n  _chalk = function _chalk() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _cliTools() {\n  var data = require(\"@react-native-community/cli-tools\");\n\n  _cliTools = function _cliTools() {\n    return data;\n  };\n\n  return data;\n}\n\nvar _healthchecks = require(\"../tools/healthchecks\");\n\nvar _printFixOptions = _interopRequireWildcard(require(\"../tools/printFixOptions\"));\n\nvar _runAutomaticFix = _interopRequireWildcard(require(\"../tools/runAutomaticFix\"));\n\nvar _envinfo = _interopRequireDefault(require(\"../tools/envinfo\"));\n\nvar _common = require(\"../tools/healthchecks/common\");\n\nfunction _getRequireWildcardCache(nodeInterop) {\n  if (typeof WeakMap !== \"function\") return null;\n  var cacheBabelInterop = new WeakMap();\n  var cacheNodeInterop = new WeakMap();\n  return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) {\n    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\n  })(nodeInterop);\n}\n\nfunction _interopRequireWildcard(obj, nodeInterop) {\n  if (!nodeInterop && obj && obj.__esModule) {\n    return obj;\n  }\n\n  if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n    return {\n      default: obj\n    };\n  }\n\n  var cache = _getRequireWildcardCache(nodeInterop);\n\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n\n  for (var key in obj) {\n    if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n\n  newObj.default = obj;\n\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n\n  return newObj;\n}\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nvar printCategory = function printCategory(_ref) {\n  var label = _ref.label,\n      key = _ref.key;\n\n  if (key > 0) {\n    _cliTools().logger.log();\n  }\n\n  _cliTools().logger.log(_chalk().default.dim(label));\n};\n\nvar printVersions = function printVersions(_ref2) {\n  var version = _ref2.version,\n      versions = _ref2.versions,\n      versionRange = _ref2.versionRange;\n\n  if (versions) {\n    var _versionsToShow = Array.isArray(versions) ? versions.join(', ') : 'N/A';\n\n    (0, _common.logMessage)(\"- Versions found: \" + _chalk().default.red(_versionsToShow));\n    (0, _common.logMessage)(\"- Version supported: \" + _chalk().default.green(versionRange));\n    return;\n  }\n\n  var versionsToShow = version && version !== 'Not Found' ? version : 'N/A';\n  (0, _common.logMessage)(\"- Version found: \" + _chalk().default.red(versionsToShow));\n  (0, _common.logMessage)(\"- Version supported: \" + _chalk().default.green(versionRange));\n  return;\n};\n\nvar printIssue = function printIssue(_ref3) {\n  var label = _ref3.label,\n      needsToBeFixed = _ref3.needsToBeFixed,\n      version = _ref3.version,\n      versions = _ref3.versions,\n      versionRange = _ref3.versionRange,\n      isRequired = _ref3.isRequired,\n      description = _ref3.description;\n  var symbol = needsToBeFixed ? isRequired ? _chalk().default.red('✖') : _chalk().default.yellow('●') : _chalk().default.green('✓');\n  var descriptionToShow = description ? \" - \" + description : '';\n\n  _cliTools().logger.log(\" \" + symbol + \" \" + label + descriptionToShow);\n\n  if (needsToBeFixed && versionRange) {\n    return printVersions({\n      version: version,\n      versions: versions,\n      versionRange: versionRange\n    });\n  }\n};\n\nvar printOverallStats = function printOverallStats(_ref4) {\n  var errors = _ref4.errors,\n      warnings = _ref4.warnings;\n\n  _cliTools().logger.log(\"\\n\" + _chalk().default.bold('Errors:') + \"   \" + errors);\n\n  _cliTools().logger.log(_chalk().default.bold('Warnings:') + \" \" + warnings);\n};\n\nvar getAutomaticFixForPlatform = function getAutomaticFixForPlatform(healthcheck, platform) {\n  switch (platform) {\n    case 'win32':\n      return healthcheck.win32AutomaticFix || healthcheck.runAutomaticFix;\n\n    case 'darwin':\n      return healthcheck.darwinAutomaticFix || healthcheck.runAutomaticFix;\n\n    case 'linux':\n      return healthcheck.linuxAutomaticFix || healthcheck.runAutomaticFix;\n\n    default:\n      return healthcheck.runAutomaticFix;\n  }\n};\n\nvar doctorCommand = function _callee4(_, options) {\n  var loader, environmentInfo, iterateOverHealthChecks, removeFixedCategories, iterateOverCategories, healthchecksPerCategory, stats, removeKeyPressListener, onKeyPress;\n  return _regeneratorRuntime.async(function _callee4$(_context4) {\n    while (1) {\n      switch (_context4.prev = _context4.next) {\n        case 0:\n          loader = (0, _cliTools().getLoader)();\n          loader.start('Running diagnostics...');\n          _context4.next = 4;\n          return _regeneratorRuntime.awrap((0, _envinfo.default)());\n\n        case 4:\n          environmentInfo = _context4.sent;\n\n          iterateOverHealthChecks = function _callee2(_ref5) {\n            var label, healthchecks;\n            return _regeneratorRuntime.async(function _callee2$(_context2) {\n              while (1) {\n                switch (_context2.prev = _context2.next) {\n                  case 0:\n                    label = _ref5.label, healthchecks = _ref5.healthchecks;\n                    _context2.t0 = label;\n                    _context2.next = 4;\n                    return _regeneratorRuntime.awrap(Promise.all(healthchecks.map(function _callee(healthcheck) {\n                      var _await$healthcheck$ge, needsToBeFixed, version, versions, versionRange, isRequired, isWarning;\n\n                      return _regeneratorRuntime.async(function _callee$(_context) {\n                        while (1) {\n                          switch (_context.prev = _context.next) {\n                            case 0:\n                              if (!(healthcheck.visible === false)) {\n                                _context.next = 2;\n                                break;\n                              }\n\n                              return _context.abrupt(\"return\");\n\n                            case 2:\n                              _context.next = 4;\n                              return _regeneratorRuntime.awrap(healthcheck.getDiagnostics(environmentInfo));\n\n                            case 4:\n                              _await$healthcheck$ge = _context.sent;\n                              needsToBeFixed = _await$healthcheck$ge.needsToBeFixed;\n                              version = _await$healthcheck$ge.version;\n                              versions = _await$healthcheck$ge.versions;\n                              versionRange = _await$healthcheck$ge.versionRange;\n                              isRequired = healthcheck.isRequired !== false;\n                              isWarning = needsToBeFixed && !isRequired;\n                              return _context.abrupt(\"return\", {\n                                label: healthcheck.label,\n                                needsToBeFixed: Boolean(needsToBeFixed),\n                                version: version,\n                                versions: versions,\n                                versionRange: versionRange,\n                                description: healthcheck.description,\n                                runAutomaticFix: getAutomaticFixForPlatform(healthcheck, process.platform),\n                                isRequired: isRequired,\n                                type: needsToBeFixed ? isWarning ? _healthchecks.HEALTHCHECK_TYPES.WARNING : _healthchecks.HEALTHCHECK_TYPES.ERROR : undefined\n                              });\n\n                            case 12:\n                            case \"end\":\n                              return _context.stop();\n                          }\n                        }\n                      }, null, null, null, Promise);\n                    })));\n\n                  case 4:\n                    _context2.t1 = _context2.sent.filter(function (healthcheck) {\n                      return healthcheck !== undefined;\n                    });\n                    return _context2.abrupt(\"return\", {\n                      label: _context2.t0,\n                      healthchecks: _context2.t1\n                    });\n\n                  case 6:\n                  case \"end\":\n                    return _context2.stop();\n                }\n              }\n            }, null, null, null, Promise);\n          };\n\n          removeFixedCategories = function removeFixedCategories(categories) {\n            return categories.filter(function (category) {\n              return category.healthchecks.some(function (healthcheck) {\n                return healthcheck.needsToBeFixed;\n              });\n            });\n          };\n\n          iterateOverCategories = function iterateOverCategories(categories) {\n            return Promise.all(categories.map(iterateOverHealthChecks));\n          };\n\n          _context4.next = 10;\n          return _regeneratorRuntime.awrap(iterateOverCategories(Object.values((0, _healthchecks.getHealthchecks)(options)).filter(function (category) {\n            return category !== undefined;\n          })));\n\n        case 10:\n          healthchecksPerCategory = _context4.sent;\n          loader.stop();\n          stats = {\n            errors: 0,\n            warnings: 0\n          };\n          healthchecksPerCategory.forEach(function (issueCategory, key) {\n            printCategory(_objectSpread(_objectSpread({}, issueCategory), {}, {\n              key: key\n            }));\n            issueCategory.healthchecks.forEach(function (healthcheck) {\n              printIssue(healthcheck);\n\n              if (healthcheck.type === _healthchecks.HEALTHCHECK_TYPES.WARNING) {\n                stats.warnings++;\n                return;\n              }\n\n              if (healthcheck.type === _healthchecks.HEALTHCHECK_TYPES.ERROR) {\n                stats.errors++;\n                return;\n              }\n            });\n          });\n          printOverallStats(stats);\n\n          if (!options.fix) {\n            _context4.next = 19;\n            break;\n          }\n\n          _context4.next = 18;\n          return _regeneratorRuntime.awrap((0, _runAutomaticFix.default)({\n            healthchecks: removeFixedCategories(healthchecksPerCategory),\n            automaticFixLevel: _runAutomaticFix.AUTOMATIC_FIX_LEVELS.ALL_ISSUES,\n            stats: stats,\n            loader: loader,\n            environmentInfo: environmentInfo\n          }));\n\n        case 18:\n          return _context4.abrupt(\"return\", _context4.sent);\n\n        case 19:\n          removeKeyPressListener = function removeKeyPressListener() {\n            if (typeof process.stdin.setRawMode === 'function') {\n              process.stdin.setRawMode(false);\n            }\n\n            process.stdin.removeAllListeners('data');\n          };\n\n          onKeyPress = function _callee3(key) {\n            var _automaticFixLevel, automaticFixLevel;\n\n            return _regeneratorRuntime.async(function _callee3$(_context3) {\n              while (1) {\n                switch (_context3.prev = _context3.next) {\n                  case 0:\n                    if (key === _printFixOptions.KEYS.EXIT || key === \"\\x03\") {\n                      removeKeyPressListener();\n                      process.exit(0);\n                    }\n\n                    if (![_printFixOptions.KEYS.FIX_ALL_ISSUES, _printFixOptions.KEYS.FIX_ERRORS, _printFixOptions.KEYS.FIX_WARNINGS].includes(key)) {\n                      _context3.next = 13;\n                      break;\n                    }\n\n                    removeKeyPressListener();\n                    _context3.prev = 3;\n                    automaticFixLevel = (_automaticFixLevel = {}, _defineProperty(_automaticFixLevel, _printFixOptions.KEYS.FIX_ALL_ISSUES, _runAutomaticFix.AUTOMATIC_FIX_LEVELS.ALL_ISSUES), _defineProperty(_automaticFixLevel, _printFixOptions.KEYS.FIX_ERRORS, _runAutomaticFix.AUTOMATIC_FIX_LEVELS.ERRORS), _defineProperty(_automaticFixLevel, _printFixOptions.KEYS.FIX_WARNINGS, _runAutomaticFix.AUTOMATIC_FIX_LEVELS.WARNINGS), _automaticFixLevel);\n                    _context3.next = 7;\n                    return _regeneratorRuntime.awrap((0, _runAutomaticFix.default)({\n                      healthchecks: removeFixedCategories(healthchecksPerCategory),\n                      automaticFixLevel: automaticFixLevel[key],\n                      stats: stats,\n                      loader: loader,\n                      environmentInfo: environmentInfo\n                    }));\n\n                  case 7:\n                    process.exit(0);\n                    _context3.next = 13;\n                    break;\n\n                  case 10:\n                    _context3.prev = 10;\n                    _context3.t0 = _context3[\"catch\"](3);\n                    process.exit(1);\n\n                  case 13:\n                  case \"end\":\n                    return _context3.stop();\n                }\n              }\n            }, null, null, [[3, 10]], Promise);\n          };\n\n          if (stats.errors || stats.warnings) {\n            (0, _printFixOptions.default)({\n              onKeyPress: onKeyPress\n            });\n          }\n\n        case 22:\n        case \"end\":\n          return _context4.stop();\n      }\n    }\n  }, null, null, null, Promise);\n};\n\nvar _default = {\n  func: doctorCommand,\n  detached: true,\n  name: 'doctor',\n  description: 'Diagnose and fix common Node.js, iOS, Android & React Native issues.',\n  options: [{\n    name: '--fix',\n    description: 'Attempt to fix all diagnosed issues.'\n  }, {\n    name: '--contributor',\n    description: 'Add healthchecks required to installations required for contributing to React Native.'\n  }]\n};\nexports.default = _default;","map":{"version":3,"sources":["../../src/commands/doctor.ts"],"names":["printCategory","key","logger","chalk","printVersions","versionRange","versionsToShow","Array","versions","version","printIssue","description","symbol","needsToBeFixed","isRequired","descriptionToShow","label","printOverallStats","warnings","getAutomaticFixForPlatform","healthcheck","doctorCommand","loader","environmentInfo","iterateOverHealthChecks","healthchecks","isWarning","Boolean","runAutomaticFix","process","type","HEALTHCHECK_TYPES","undefined","removeFixedCategories","categories","category","iterateOverCategories","Promise","healthchecksPerCategory","Object","stats","errors","issueCategory","options","automaticFixLevel","AUTOMATIC_FIX_LEVELS","removeKeyPressListener","onKeyPress","KEYS","WARNINGS","func","detached","name"],"mappings":"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","sourcesContent":["import chalk from 'chalk';\nimport {logger, getLoader} from '@react-native-community/cli-tools';\nimport {getHealthchecks, HEALTHCHECK_TYPES} from '../tools/healthchecks';\nimport printFixOptions, {KEYS} from '../tools/printFixOptions';\nimport runAutomaticFix, {AUTOMATIC_FIX_LEVELS} from '../tools/runAutomaticFix';\nimport {DetachedCommandFunction} from '@react-native-community/cli-types';\nimport {\n  HealthCheckCategoryResult,\n  HealthCheckInterface,\n  HealthCheckCategory,\n  HealthCheckResult,\n} from '../types';\nimport getEnvironmentInfo from '../tools/envinfo';\nimport {logMessage} from '../tools/healthchecks/common';\n\nconst printCategory = ({label, key}: {label: string; key: number}) => {\n  if (key > 0) {\n    logger.log();\n  }\n\n  logger.log(chalk.dim(label));\n};\n\nconst printVersions = ({\n  version,\n  versions,\n  versionRange,\n}: {\n  version?: 'Not Found' | string;\n  versions?: [string] | string;\n  versionRange: string;\n}) => {\n  if (versions) {\n    const versionsToShow = Array.isArray(versions)\n      ? versions.join(', ')\n      : 'N/A';\n\n    logMessage(`- Versions found: ${chalk.red(versionsToShow)}`);\n    logMessage(`- Version supported: ${chalk.green(versionRange)}`);\n\n    return;\n  }\n\n  const versionsToShow = version && version !== 'Not Found' ? version : 'N/A';\n\n  logMessage(`- Version found: ${chalk.red(versionsToShow)}`);\n  logMessage(`- Version supported: ${chalk.green(versionRange)}`);\n\n  return;\n};\n\nconst printIssue = ({\n  label,\n  needsToBeFixed,\n  version,\n  versions,\n  versionRange,\n  isRequired,\n  description,\n}: HealthCheckResult) => {\n  const symbol = needsToBeFixed\n    ? isRequired\n      ? chalk.red('✖')\n      : chalk.yellow('●')\n    : chalk.green('✓');\n\n  const descriptionToShow = description ? ` - ${description}` : '';\n\n  logger.log(` ${symbol} ${label}${descriptionToShow}`);\n\n  if (needsToBeFixed && versionRange) {\n    return printVersions({version, versions, versionRange});\n  }\n};\n\nconst printOverallStats = ({\n  errors,\n  warnings,\n}: {\n  errors: number;\n  warnings: number;\n}) => {\n  logger.log(`\\n${chalk.bold('Errors:')}   ${errors}`);\n  logger.log(`${chalk.bold('Warnings:')} ${warnings}`);\n};\n\ntype FlagsT = {\n  fix: boolean | void;\n  contributor: boolean | void;\n};\n\n/**\n * Given a `healthcheck` and a `platform`, returns the specific fix for\n * it or the fallback one if there is not one (`runAutomaticFix`).\n */\nconst getAutomaticFixForPlatform = (\n  healthcheck: HealthCheckInterface,\n  platform: NodeJS.Platform,\n) => {\n  switch (platform) {\n    case 'win32':\n      return healthcheck.win32AutomaticFix || healthcheck.runAutomaticFix;\n    case 'darwin':\n      return healthcheck.darwinAutomaticFix || healthcheck.runAutomaticFix;\n    case 'linux':\n      return healthcheck.linuxAutomaticFix || healthcheck.runAutomaticFix;\n    default:\n      return healthcheck.runAutomaticFix;\n  }\n};\n\nconst doctorCommand = (async (_, options) => {\n  const loader = getLoader();\n\n  loader.start('Running diagnostics...');\n\n  const environmentInfo = await getEnvironmentInfo();\n\n  const iterateOverHealthChecks = async ({\n    label,\n    healthchecks,\n  }: HealthCheckCategory): Promise<HealthCheckCategoryResult> => ({\n    label,\n    healthchecks: (\n      await Promise.all(\n        healthchecks.map(async (healthcheck) => {\n          if (healthcheck.visible === false) {\n            return;\n          }\n\n          const {\n            needsToBeFixed,\n            version,\n            versions,\n            versionRange,\n          } = await healthcheck.getDiagnostics(environmentInfo);\n\n          // Assume that it's required unless specified otherwise\n          const isRequired = healthcheck.isRequired !== false;\n          const isWarning = needsToBeFixed && !isRequired;\n\n          return {\n            label: healthcheck.label,\n            needsToBeFixed: Boolean(needsToBeFixed),\n            version,\n            versions,\n            versionRange,\n            description: healthcheck.description,\n            runAutomaticFix: getAutomaticFixForPlatform(\n              healthcheck,\n              process.platform,\n            ),\n            isRequired,\n            type: needsToBeFixed\n              ? isWarning\n                ? HEALTHCHECK_TYPES.WARNING\n                : HEALTHCHECK_TYPES.ERROR\n              : undefined,\n          };\n        }),\n      )\n    ).filter((healthcheck) => healthcheck !== undefined) as HealthCheckResult[],\n  });\n\n  // Remove all the categories that don't have any healthcheck with\n  // `needsToBeFixed` so they don't show when the user taps to fix encountered\n  // issues\n  const removeFixedCategories = (categories: HealthCheckCategoryResult[]) =>\n    categories.filter((category) =>\n      category.healthchecks.some((healthcheck) => healthcheck.needsToBeFixed),\n    );\n\n  const iterateOverCategories = (categories: HealthCheckCategory[]) =>\n    Promise.all(categories.map(iterateOverHealthChecks));\n\n  const healthchecksPerCategory = await iterateOverCategories(\n    Object.values(getHealthchecks(options)).filter(\n      (category) => category !== undefined,\n    ) as HealthCheckCategory[],\n  );\n\n  loader.stop();\n\n  const stats = {\n    errors: 0,\n    warnings: 0,\n  };\n\n  healthchecksPerCategory.forEach((issueCategory, key) => {\n    printCategory({...issueCategory, key});\n\n    issueCategory.healthchecks.forEach((healthcheck) => {\n      printIssue(healthcheck);\n\n      if (healthcheck.type === HEALTHCHECK_TYPES.WARNING) {\n        stats.warnings++;\n        return;\n      }\n\n      if (healthcheck.type === HEALTHCHECK_TYPES.ERROR) {\n        stats.errors++;\n        return;\n      }\n    });\n  });\n\n  printOverallStats(stats);\n\n  if (options.fix) {\n    return await runAutomaticFix({\n      healthchecks: removeFixedCategories(healthchecksPerCategory),\n      automaticFixLevel: AUTOMATIC_FIX_LEVELS.ALL_ISSUES,\n      stats,\n      loader,\n      environmentInfo,\n    });\n  }\n\n  const removeKeyPressListener = () => {\n    if (typeof process.stdin.setRawMode === 'function') {\n      process.stdin.setRawMode(false);\n    }\n    process.stdin.removeAllListeners('data');\n  };\n\n  const onKeyPress = async (key: string) => {\n    if (key === KEYS.EXIT || key === '\\u0003') {\n      removeKeyPressListener();\n\n      process.exit(0);\n    }\n\n    if (\n      [KEYS.FIX_ALL_ISSUES, KEYS.FIX_ERRORS, KEYS.FIX_WARNINGS].includes(key)\n    ) {\n      removeKeyPressListener();\n\n      try {\n        const automaticFixLevel = {\n          [KEYS.FIX_ALL_ISSUES]: AUTOMATIC_FIX_LEVELS.ALL_ISSUES,\n          [KEYS.FIX_ERRORS]: AUTOMATIC_FIX_LEVELS.ERRORS,\n          [KEYS.FIX_WARNINGS]: AUTOMATIC_FIX_LEVELS.WARNINGS,\n        };\n\n        await runAutomaticFix({\n          healthchecks: removeFixedCategories(healthchecksPerCategory),\n          automaticFixLevel: automaticFixLevel[key],\n          stats,\n          loader,\n          environmentInfo,\n        });\n\n        process.exit(0);\n      } catch (err) {\n        // TODO: log error\n        process.exit(1);\n      }\n    }\n  };\n\n  if (stats.errors || stats.warnings) {\n    printFixOptions({onKeyPress});\n  }\n}) as DetachedCommandFunction<FlagsT>;\n\nexport default {\n  func: doctorCommand,\n  detached: true,\n  name: 'doctor',\n  description:\n    'Diagnose and fix common Node.js, iOS, Android & React Native issues.',\n  options: [\n    {\n      name: '--fix',\n      description: 'Attempt to fix all diagnosed issues.',\n    },\n    {\n      name: '--contributor',\n      description:\n        'Add healthchecks required to installations required for contributing to React Native.',\n    },\n  ],\n};\n"]},"metadata":{},"sourceType":"script"}