{"ast":null,"code":"\"use strict\";\n\nvar _defineProperty = require(\"@babel/runtime/helpers/defineProperty\");\n\nvar _inherits = require(\"@babel/runtime/helpers/inherits\");\n\nvar _possibleConstructorReturn = require(\"@babel/runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"@babel/runtime/helpers/getPrototypeOf\");\n\nvar _classCallCheck = require(\"@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"@babel/runtime/helpers/createClass\");\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _createForOfIteratorHelperLoose(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (it) return (it = it.call(o)).next.bind(it); if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nvar _require = require(\"./ChromeHeapSnapshot\"),\n    ChromeHeapSnapshotProcessor = _require.ChromeHeapSnapshotProcessor;\n\nvar SourceMetadataMapConsumer = require(\"./SourceMetadataMapConsumer\");\n\nvar fs = require(\"fs\");\n\nvar invariant = require(\"invariant\");\n\nvar nullthrows = require(\"nullthrows\");\n\nvar path = require(\"path\");\n\nvar UNKNOWN_MODULE_IDS = {\n  segmentId: 0,\n  localId: undefined\n};\n\nvar SymbolicationContext = function () {\n  function SymbolicationContext(options) {\n    _classCallCheck(this, SymbolicationContext);\n\n    this.options = {\n      inputLineStart: 1,\n      inputColumnStart: 0,\n      outputLineStart: 1,\n      outputColumnStart: 0,\n      nameSource: \"function_names\"\n    };\n\n    if (options) {\n      for (var _i = 0, _arr = [\"inputLineStart\", \"inputColumnStart\", \"outputLineStart\", \"outputColumnStart\"]; _i < _arr.length; _i++) {\n        var option = _arr[_i];\n\n        if (options[option] != null) {\n          this.options[option] = options[option];\n        }\n      }\n\n      if (options.nameSource != null) {\n        this.options.nameSource = options.nameSource;\n      }\n    }\n  }\n\n  _createClass(SymbolicationContext, [{\n    key: \"symbolicate\",\n    value: function symbolicate(stackTrace) {\n      var _this = this;\n\n      return stackTrace.replace(/(?:([^@: \\n(]+)(@|:))?(?:(?:([^@: \\n(]+):)?(\\d+):(\\d+)|\\[native code\\])/g, function (match, func, delimiter, fileName, line, column) {\n        var _original$source, _original$line, _original$name;\n\n        if (delimiter === \":\" && func && !fileName) {\n          fileName = func;\n          func = null;\n        }\n\n        var original = _this.getOriginalPositionFor(line, column, _this.parseFileName(fileName || \"\"));\n\n        return ((_original$source = original.source) !== null && _original$source !== void 0 ? _original$source : \"null\") + \":\" + ((_original$line = original.line) !== null && _original$line !== void 0 ? _original$line : \"null\") + \":\" + ((_original$name = original.name) !== null && _original$name !== void 0 ? _original$name : \"null\");\n      });\n    }\n  }, {\n    key: \"symbolicateProfilerMap\",\n    value: function symbolicateProfilerMap(mapFile) {\n      var _this2 = this;\n\n      return fs.readFileSync(mapFile, \"utf8\").split(\"\\n\").slice(0, -1).map(function (line) {\n        var line_list = line.split(\" \");\n        var trampoline = line_list[0];\n        var js_name = line_list[1];\n        var offset = parseInt(line_list[2], 10);\n\n        if (!offset) {\n          return trampoline + \" \" + trampoline;\n        }\n\n        var original = _this2.getOriginalPositionFor(_this2.options.inputLineStart, offset);\n\n        return trampoline + \" \" + (original.name || js_name) + \"::\" + [original.source, original.line, original.column].join(\":\");\n      }).join(\"\\n\");\n    }\n  }, {\n    key: \"symbolicateAttribution\",\n    value: function symbolicateAttribution(obj) {\n      var loc = obj.location;\n      var line = loc.line != null ? loc.line : this.options.inputLineStart;\n      var column = Number(loc.column != null ? loc.column : loc.virtualOffset);\n      var file = loc.filename ? this.parseFileName(loc.filename) : null;\n      var original = this.getOriginalPositionFor(line, column, file);\n      var isBytecodeRange = loc.bytecodeSize != null && loc.virtualOffset != null && loc.column == null;\n      var virtualOffset = Number(loc.virtualOffset);\n      var bytecodeSize = Number(loc.bytecodeSize);\n\n      while (isBytecodeRange && original.source == null && ++column < virtualOffset + bytecodeSize) {\n        original = this.getOriginalPositionFor(line, column, file);\n      }\n\n      obj.location = {\n        file: original.source,\n        line: original.line,\n        column: original.column\n      };\n    }\n  }, {\n    key: \"symbolicateChromeTrace\",\n    value: function symbolicateChromeTrace(traceFile, _ref) {\n      var _this3 = this;\n\n      var stdout = _ref.stdout,\n          stderr = _ref.stderr;\n      var content = JSON.parse(fs.readFileSync(traceFile, \"utf8\"));\n\n      if (content.stackFrames == null) {\n        throw new Error(\"Unable to locate `stackFrames` section in trace.\");\n      }\n\n      var keys = Object.keys(content.stackFrames);\n      stdout.write(\"Processing \" + keys.length + \" frames\\n\");\n      keys.forEach(function (key) {\n        var _addressOriginal$sour, _addressOriginal$line, _addressOriginal$colu;\n\n        var entry = content.stackFrames[key];\n        var line;\n        var column;\n        var funcLine;\n        var funcColumn;\n\n        if (entry.funcVirtAddr != null && entry.offset != null) {\n          var funcVirtAddr = parseInt(entry.funcVirtAddr, 10);\n          var offsetInFunction = parseInt(entry.offset, 10);\n          line = _this3.options.inputLineStart;\n          column = funcVirtAddr + offsetInFunction;\n          funcLine = _this3.options.inputLineStart;\n          funcColumn = funcVirtAddr;\n        } else if (entry.line != null && entry.column != null) {\n          line = entry.line;\n          column = entry.column;\n          funcLine = entry.funcLine;\n          funcColumn = entry.funcColumn;\n        } else {\n          return;\n        }\n\n        var addressOriginal = _this3.getOriginalPositionDetailsFor(line, column);\n\n        var frameName;\n\n        if (addressOriginal.functionName) {\n          frameName = addressOriginal.functionName;\n        } else {\n          frameName = entry.name;\n\n          if (funcLine != null && funcColumn != null) {\n            var funcOriginal = _this3.getOriginalPositionFor(funcLine, funcColumn);\n\n            if (funcOriginal.name != null) {\n              frameName = funcOriginal.name;\n            }\n          } else {\n            (stderr || stdout).write(\"Warning: no function prolog line/column info; name may be wrong\\n\");\n          }\n        }\n\n        entry.name = [frameName, \"(\", [(_addressOriginal$sour = addressOriginal.source) !== null && _addressOriginal$sour !== void 0 ? _addressOriginal$sour : \"null\", (_addressOriginal$line = addressOriginal.line) !== null && _addressOriginal$line !== void 0 ? _addressOriginal$line : \"null\", (_addressOriginal$colu = addressOriginal.column) !== null && _addressOriginal$colu !== void 0 ? _addressOriginal$colu : \"null\"].join(\":\"), \")\"].join(\"\");\n      });\n      stdout.write(\"Writing to \" + traceFile + \"\\n\");\n      fs.writeFileSync(traceFile, JSON.stringify(content));\n    }\n  }, {\n    key: \"getOriginalPositionFor\",\n    value: function getOriginalPositionFor(lineNumber, columnNumber, moduleIds) {\n      var position = this.getOriginalPositionDetailsFor(lineNumber, columnNumber, moduleIds);\n      return {\n        line: position.line,\n        column: position.column,\n        source: position.source,\n        name: position.functionName ? position.functionName : position.name\n      };\n    }\n  }, {\n    key: \"symbolicateHermesMinidumpTrace\",\n    value: function symbolicateHermesMinidumpTrace(crashInfo) {\n      throw new Error(\"Not implemented\");\n    }\n  }, {\n    key: \"symbolicateHeapSnapshot\",\n    value: function symbolicateHeapSnapshot(snapshotContents) {\n      var snapshotData = typeof snapshotContents === \"string\" ? JSON.parse(snapshotContents) : snapshotContents;\n      var processor = new ChromeHeapSnapshotProcessor(snapshotData);\n\n      for (var _iterator = _createForOfIteratorHelperLoose(processor.traceFunctionInfos()), _step; !(_step = _iterator()).done;) {\n        var frame = _step.value;\n        var moduleIds = this.parseFileName(frame.getString(\"script_name\"));\n        var generatedLine = frame.getNumber(\"line\");\n        var generatedColumn = frame.getNumber(\"column\");\n\n        if (generatedLine === 0 && generatedColumn === 0) {\n          continue;\n        }\n\n        var _this$getOriginalPosi = this.getOriginalPositionDetailsFor(frame.getNumber(\"line\") - 1 + this.options.inputLineStart, frame.getNumber(\"column\") - 1 + this.options.inputColumnStart, moduleIds),\n            originalLine = _this$getOriginalPosi.line,\n            originalColumn = _this$getOriginalPosi.column,\n            originalSource = _this$getOriginalPosi.source,\n            originalFunctionName = _this$getOriginalPosi.functionName;\n\n        if (originalSource != null) {\n          frame.setString(\"script_name\", originalSource);\n\n          if (originalLine != null) {\n            frame.setNumber(\"line\", originalLine - this.options.outputLineStart + 1);\n          } else {\n            frame.setNumber(\"line\", 0);\n          }\n\n          if (originalColumn != null) {\n            frame.setNumber(\"column\", originalColumn - this.options.outputColumnStart + 1);\n          } else {\n            frame.setNumber(\"column\", 0);\n          }\n        }\n\n        frame.setString(\"name\", originalFunctionName !== null && originalFunctionName !== void 0 ? originalFunctionName : frame.getString(\"name\"));\n      }\n\n      return snapshotData;\n    }\n  }, {\n    key: \"symbolicateHermesCoverageTrace\",\n    value: function symbolicateHermesCoverageTrace(coverageInfo) {\n      var symbolicatedTrace = [];\n      var executedFunctions = coverageInfo.executedFunctions;\n\n      if (executedFunctions != null) {\n        for (var _iterator2 = _createForOfIteratorHelperLoose(executedFunctions), _step2; !(_step2 = _iterator2()).done;) {\n          var stackItem = _step2.value;\n          var line = stackItem.line,\n              column = stackItem.column,\n              SourceURL = stackItem.SourceURL;\n          var generatedLine = line + this.options.inputLineStart;\n          var generatedColumn = column + this.options.inputColumnStart;\n          var originalPosition = this.getOriginalPositionDetailsFor(generatedLine, generatedColumn, this.parseFileName(SourceURL || \"\"));\n          symbolicatedTrace.push(originalPosition);\n        }\n      }\n\n      return symbolicatedTrace;\n    }\n  }, {\n    key: \"getOriginalPositionDetailsFor\",\n    value: function getOriginalPositionDetailsFor(lineNumber, columnNumber, moduleIds) {\n      throw new Error(\"Not implemented\");\n    }\n  }, {\n    key: \"parseFileName\",\n    value: function parseFileName(str) {\n      throw new Error(\"Not implemented\");\n    }\n  }]);\n\n  return SymbolicationContext;\n}();\n\nvar SingleMapSymbolicationContext = function (_SymbolicationContext) {\n  _inherits(SingleMapSymbolicationContext, _SymbolicationContext);\n\n  var _super = _createSuper(SingleMapSymbolicationContext);\n\n  function SingleMapSymbolicationContext(SourceMapConsumer, sourceMapContent) {\n    var _this4;\n\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    _classCallCheck(this, SingleMapSymbolicationContext);\n\n    _this4 = _super.call(this, options);\n    _this4._SourceMapConsumer = SourceMapConsumer;\n    var sourceMapJson = typeof sourceMapContent === \"string\" ? JSON.parse(sourceMapContent.replace(/^\\)\\]\\}'/, \"\")) : sourceMapContent;\n    var segments = {\n      0: _this4._initSegment(sourceMapJson)\n    };\n\n    if (sourceMapJson.x_facebook_segments) {\n      for (var _i2 = 0, _Object$keys = Object.keys(sourceMapJson.x_facebook_segments); _i2 < _Object$keys.length; _i2++) {\n        var key = _Object$keys[_i2];\n        var map = sourceMapJson.x_facebook_segments[key];\n        segments[key] = _this4._initSegment(map);\n      }\n    }\n\n    _this4._legacyFormat = sourceMapJson.x_facebook_segments != null || sourceMapJson.x_facebook_offsets != null;\n    _this4._segments = segments;\n    return _this4;\n  }\n\n  _createClass(SingleMapSymbolicationContext, [{\n    key: \"_initSegment\",\n    value: function _initSegment(map) {\n      var useFunctionNames = this.options.nameSource === \"function_names\";\n      var SourceMapConsumer = this._SourceMapConsumer;\n      return {\n        get consumer() {\n          Object.defineProperty(this, \"consumer\", {\n            value: new SourceMapConsumer(map)\n          });\n          return this.consumer;\n        },\n\n        moduleOffsets: map.x_facebook_offsets || [],\n\n        get sourceFunctionsConsumer() {\n          Object.defineProperty(this, \"sourceFunctionsConsumer\", {\n            value: useFunctionNames ? new SourceMetadataMapConsumer(map) : null\n          });\n          return this.sourceFunctionsConsumer;\n        },\n\n        hermesOffsets: map.x_hermes_function_offsets\n      };\n    }\n  }, {\n    key: \"symbolicateHermesMinidumpTrace\",\n    value: function symbolicateHermesMinidumpTrace(crashInfo) {\n      var symbolicatedTrace = [];\n      var callstack = crashInfo.callstack;\n\n      if (callstack != null) {\n        for (var _iterator3 = _createForOfIteratorHelperLoose(callstack), _step3; !(_step3 = _iterator3()).done;) {\n          var stackItem = _step3.value;\n\n          if (stackItem.NativeCode) {\n            symbolicatedTrace.push(stackItem);\n          } else {\n            var CJSModuleOffset = stackItem.CJSModuleOffset,\n                SegmentID = stackItem.SegmentID,\n                SourceURL = stackItem.SourceURL,\n                FunctionID = stackItem.FunctionID,\n                localOffset = stackItem.ByteCodeOffset;\n            var cjsModuleOffsetOrSegmentID = nullthrows(CJSModuleOffset !== null && CJSModuleOffset !== void 0 ? CJSModuleOffset : SegmentID, \"Either CJSModuleOffset or SegmentID must be specified in the Hermes stack frame\");\n            var moduleInformation = this.parseFileName(SourceURL);\n            var generatedLine = cjsModuleOffsetOrSegmentID + this.options.inputLineStart;\n\n            var segment = this._segments[moduleInformation.segmentId.toString()];\n\n            var hermesOffsets = segment === null || segment === void 0 ? void 0 : segment.hermesOffsets;\n\n            if (!hermesOffsets) {\n              symbolicatedTrace.push({\n                line: null,\n                column: null,\n                source: null,\n                functionName: null,\n                name: null\n              });\n            } else {\n              var segmentOffsets = hermesOffsets[Number(cjsModuleOffsetOrSegmentID)];\n              var generatedColumn = segmentOffsets[FunctionID] + localOffset + this.options.inputColumnStart;\n              var originalPosition = this.getOriginalPositionDetailsFor(generatedLine, generatedColumn, moduleInformation);\n              symbolicatedTrace.push(originalPosition);\n            }\n          }\n        }\n      }\n\n      return symbolicatedTrace;\n    }\n  }, {\n    key: \"symbolicateHermesCoverageTrace\",\n    value: function symbolicateHermesCoverageTrace(coverageInfo) {\n      var symbolicatedTrace = [];\n      var executedFunctions = coverageInfo.executedFunctions;\n\n      if (executedFunctions != null) {\n        for (var _iterator4 = _createForOfIteratorHelperLoose(executedFunctions), _step4; !(_step4 = _iterator4()).done;) {\n          var stackItem = _step4.value;\n          var line = stackItem.line,\n              column = stackItem.column,\n              SourceURL = stackItem.SourceURL;\n          var generatedLine = line + this.options.inputLineStart;\n          var generatedColumn = column + this.options.inputColumnStart;\n          var originalPosition = this.getOriginalPositionDetailsFor(generatedLine, generatedColumn, this.parseFileName(SourceURL || \"\"));\n          symbolicatedTrace.push(originalPosition);\n        }\n      }\n\n      return symbolicatedTrace;\n    }\n  }, {\n    key: \"getOriginalPositionDetailsFor\",\n    value: function getOriginalPositionDetailsFor(lineNumber, columnNumber, moduleIds) {\n      lineNumber = lineNumber != null ? lineNumber - this.options.inputLineStart + 1 : lineNumber;\n      columnNumber = columnNumber != null ? columnNumber - this.options.inputColumnStart + 0 : columnNumber;\n\n      if (!moduleIds) {\n        moduleIds = UNKNOWN_MODULE_IDS;\n      }\n\n      var moduleLineOffset = 0;\n      var metadata = this._segments[moduleIds.segmentId + \"\"];\n      var _moduleIds = moduleIds,\n          localId = _moduleIds.localId;\n\n      if (localId != null) {\n        var moduleOffsets = metadata.moduleOffsets;\n\n        if (!moduleOffsets) {\n          throw new Error(\"Module ID given for a source map that does not have \" + \"an x_facebook_offsets field\");\n        }\n\n        if (moduleOffsets[localId] == null) {\n          throw new Error(\"Unknown module ID: \" + localId);\n        }\n\n        moduleLineOffset = moduleOffsets[localId];\n      }\n\n      var original = metadata.consumer.originalPositionFor({\n        line: Number(lineNumber) + moduleLineOffset,\n        column: Number(columnNumber)\n      });\n\n      if (metadata.sourceFunctionsConsumer) {\n        original.functionName = metadata.sourceFunctionsConsumer.functionNameFor(original) || null;\n      } else {\n        original.functionName = null;\n      }\n\n      return _objectSpread(_objectSpread({}, original), {}, {\n        line: original.line != null ? original.line - 1 + this.options.outputLineStart : original.line,\n        column: original.column != null ? original.column - 0 + this.options.outputColumnStart : original.column\n      });\n    }\n  }, {\n    key: \"parseFileName\",\n    value: function parseFileName(str) {\n      if (this._legacyFormat) {\n        return parseSingleMapFileName(str);\n      }\n\n      return UNKNOWN_MODULE_IDS;\n    }\n  }]);\n\n  return SingleMapSymbolicationContext;\n}(SymbolicationContext);\n\nvar DirectorySymbolicationContext = function (_SymbolicationContext2) {\n  _inherits(DirectorySymbolicationContext, _SymbolicationContext2);\n\n  var _super2 = _createSuper(DirectorySymbolicationContext);\n\n  function DirectorySymbolicationContext(SourceMapConsumer, rootDir) {\n    var _this5;\n\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    _classCallCheck(this, DirectorySymbolicationContext);\n\n    _this5 = _super2.call(this, options);\n    _this5._fileMaps = new Map();\n    _this5._rootDir = rootDir;\n    _this5._SourceMapConsumer = SourceMapConsumer;\n    return _this5;\n  }\n\n  _createClass(DirectorySymbolicationContext, [{\n    key: \"_loadMap\",\n    value: function _loadMap(mapFilename) {\n      invariant(fs.existsSync(mapFilename), \"Could not read source map from '\" + mapFilename + \"'\");\n\n      var fileMap = this._fileMaps.get(mapFilename);\n\n      if (fileMap == null) {\n        fileMap = new SingleMapSymbolicationContext(this._SourceMapConsumer, fs.readFileSync(mapFilename, \"utf8\"), this.options);\n\n        this._fileMaps.set(mapFilename, fileMap);\n      }\n\n      return fileMap;\n    }\n  }, {\n    key: \"getOriginalPositionDetailsFor\",\n    value: function getOriginalPositionDetailsFor(lineNumber, columnNumber, filename) {\n      invariant(filename != null, \"filename is required for DirectorySymbolicationContext\");\n      var mapFilename;\n      var relativeFilename = path.relative(this._rootDir, path.resolve(this._rootDir, filename));\n\n      if (!relativeFilename.startsWith(\"..\")) {\n        mapFilename = path.join(this._rootDir, relativeFilename + \".map\");\n      }\n\n      if (mapFilename == null || !fs.existsSync(mapFilename)) {\n        lineNumber = lineNumber != null ? lineNumber - this.options.inputLineStart + this.options.outputLineStart : lineNumber;\n        columnNumber = columnNumber != null ? columnNumber - this.options.inputColumnStart + this.options.outputColumnStart : columnNumber;\n        return {\n          line: lineNumber,\n          column: columnNumber,\n          source: filename,\n          name: null,\n          functionName: null\n        };\n      }\n\n      return this._loadMap(mapFilename).getOriginalPositionDetailsFor(lineNumber, columnNumber);\n    }\n  }, {\n    key: \"parseFileName\",\n    value: function parseFileName(str) {\n      return str;\n    }\n  }]);\n\n  return DirectorySymbolicationContext;\n}(SymbolicationContext);\n\nfunction parseSingleMapFileName(str) {\n  var modMatch = str.match(/^(\\d+).js$/);\n\n  if (modMatch != null) {\n    return {\n      segmentId: 0,\n      localId: Number(modMatch[1])\n    };\n  }\n\n  var segMatch = str.match(/^seg-(\\d+)(?:_(\\d+))?.js$/);\n\n  if (segMatch != null) {\n    return {\n      segmentId: Number(segMatch[1]),\n      localId: segMatch[2] ? Number(segMatch[2]) : null\n    };\n  }\n\n  return UNKNOWN_MODULE_IDS;\n}\n\nfunction createContext(SourceMapConsumer, sourceMapContent) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  return new SingleMapSymbolicationContext(SourceMapConsumer, sourceMapContent, options);\n}\n\nfunction unstable_createDirectoryContext(SourceMapConsumer, rootDir) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  return new DirectorySymbolicationContext(SourceMapConsumer, rootDir, options);\n}\n\nfunction getOriginalPositionFor(lineNumber, columnNumber, moduleIds, context) {\n  return context.getOriginalPositionFor(lineNumber, columnNumber, moduleIds);\n}\n\nfunction symbolicate(stackTrace, context) {\n  return context.symbolicate(stackTrace);\n}\n\nfunction symbolicateProfilerMap(mapFile, context) {\n  return context.symbolicateProfilerMap(mapFile);\n}\n\nfunction symbolicateAttribution(obj, context) {\n  context.symbolicateAttribution(obj);\n}\n\nfunction symbolicateChromeTrace(traceFile, _ref2, context) {\n  var stdout = _ref2.stdout,\n      stderr = _ref2.stderr;\n  return context.symbolicateChromeTrace(traceFile, {\n    stdout: stdout,\n    stderr: stderr\n  });\n}\n\nmodule.exports = {\n  createContext: createContext,\n  unstable_createDirectoryContext: unstable_createDirectoryContext,\n  getOriginalPositionFor: getOriginalPositionFor,\n  parseFileName: parseSingleMapFileName,\n  symbolicate: symbolicate,\n  symbolicateProfilerMap: symbolicateProfilerMap,\n  symbolicateAttribution: symbolicateAttribution,\n  symbolicateChromeTrace: symbolicateChromeTrace,\n  SourceMetadataMapConsumer: SourceMetadataMapConsumer\n};","map":{"version":3,"names":["require","ChromeHeapSnapshotProcessor","SourceMetadataMapConsumer","fs","invariant","nullthrows","path","UNKNOWN_MODULE_IDS","segmentId","localId","undefined","SymbolicationContext","options","inputLineStart","inputColumnStart","outputLineStart","outputColumnStart","nameSource","option","stackTrace","replace","match","func","delimiter","fileName","line","column","_original$source","_original$line","_original$name","original","getOriginalPositionFor","parseFileName","source","name","mapFile","readFileSync","split","slice","map","line_list","trampoline","js_name","offset","parseInt","join","obj","loc","location","Number","virtualOffset","file","filename","isBytecodeRange","bytecodeSize","traceFile","stdout","stderr","content","JSON","parse","stackFrames","Error","keys","Object","write","length","forEach","key","_addressOriginal$sour","_addressOriginal$line","_addressOriginal$colu","entry","funcLine","funcColumn","funcVirtAddr","offsetInFunction","addressOriginal","getOriginalPositionDetailsFor","frameName","functionName","funcOriginal","writeFileSync","stringify","lineNumber","columnNumber","moduleIds","position","crashInfo","snapshotContents","snapshotData","processor","traceFunctionInfos","frame","getString","generatedLine","getNumber","generatedColumn","originalLine","originalColumn","originalSource","originalFunctionName","setString","setNumber","coverageInfo","symbolicatedTrace","executedFunctions","stackItem","SourceURL","originalPosition","push","str","SingleMapSymbolicationContext","SourceMapConsumer","sourceMapContent","_SourceMapConsumer","sourceMapJson","segments","_initSegment","x_facebook_segments","_legacyFormat","x_facebook_offsets","_segments","useFunctionNames","consumer","defineProperty","value","moduleOffsets","sourceFunctionsConsumer","hermesOffsets","x_hermes_function_offsets","callstack","NativeCode","CJSModuleOffset","SegmentID","FunctionID","localOffset","ByteCodeOffset","cjsModuleOffsetOrSegmentID","moduleInformation","segment","toString","segmentOffsets","moduleLineOffset","metadata","originalPositionFor","functionNameFor","parseSingleMapFileName","DirectorySymbolicationContext","rootDir","_fileMaps","Map","_rootDir","mapFilename","existsSync","fileMap","get","set","relativeFilename","relative","resolve","startsWith","_loadMap","modMatch","segMatch","createContext","unstable_createDirectoryContext","context","symbolicate","symbolicateProfilerMap","symbolicateAttribution","symbolicateChromeTrace","module","exports"],"sources":["/Users/hozaifa/Documents/Uni App Github/node_modules/@react-native-community/cli-plugin-metro/node_modules/metro-symbolicate/src/Symbolication.js"],"sourcesContent":["\"use strict\";\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *\n * @format\n */\n// flowlint-next-line untyped-type-import:off\nconst { ChromeHeapSnapshotProcessor } = require(\"./ChromeHeapSnapshot\");\n\nconst SourceMetadataMapConsumer = require(\"./SourceMetadataMapConsumer\");\n\nconst fs = require(\"fs\");\n\nconst invariant = require(\"invariant\");\n\nconst nullthrows = require(\"nullthrows\");\n\nconst path = require(\"path\");\n\nconst UNKNOWN_MODULE_IDS = {\n  segmentId: 0,\n  localId: undefined,\n};\n\nclass SymbolicationContext {\n  constructor(options) {\n    this.options = {\n      inputLineStart: 1,\n      inputColumnStart: 0,\n      outputLineStart: 1,\n      outputColumnStart: 0,\n      nameSource: \"function_names\",\n    };\n\n    if (options) {\n      for (const option of [\n        \"inputLineStart\",\n        \"inputColumnStart\",\n        \"outputLineStart\",\n        \"outputColumnStart\",\n      ]) {\n        if (options[option] != null) {\n          this.options[option] = options[option];\n        }\n      }\n\n      if (options.nameSource != null) {\n        this.options.nameSource = options.nameSource;\n      }\n    }\n  } // parse stack trace with String.replace\n  // replace the matched part of stack trace to symbolicated result\n  // sample stack trace:\n  //  IOS: foo@4:18131, Android: bar:4:18063\n  // sample stack trace with module id:\n  //  IOS: foo@123.js:4:18131, Android: bar:123.js:4:18063\n  // sample stack trace without function name:\n  //  123.js:4:18131\n  // sample result:\n  //  IOS: foo.js:57:foo, Android: bar.js:75:bar\n\n  symbolicate(stackTrace) {\n    return stackTrace.replace(\n      /(?:([^@: \\n(]+)(@|:))?(?:(?:([^@: \\n(]+):)?(\\d+):(\\d+)|\\[native code\\])/g,\n      (match, func, delimiter, fileName, line, column) => {\n        var _original$source, _original$line, _original$name;\n\n        if (delimiter === \":\" && func && !fileName) {\n          fileName = func;\n          func = null;\n        }\n\n        const original = this.getOriginalPositionFor(\n          line,\n          column,\n          this.parseFileName(fileName || \"\")\n        );\n        return (\n          ((_original$source = original.source) !== null &&\n          _original$source !== void 0\n            ? _original$source\n            : \"null\") +\n          \":\" +\n          ((_original$line = original.line) !== null &&\n          _original$line !== void 0\n            ? _original$line\n            : \"null\") +\n          \":\" +\n          ((_original$name = original.name) !== null &&\n          _original$name !== void 0\n            ? _original$name\n            : \"null\")\n        );\n      }\n    );\n  } // Taking in a map like\n  // trampoline offset (optional js function name)\n  // JS_0158_xxxxxxxxxxxxxxxxxxxxxx fe 91081\n  // JS_0159_xxxxxxxxxxxxxxxxxxxxxx Ft 68651\n  // JS_0160_xxxxxxxxxxxxxxxxxxxxxx value 50700\n  // JS_0161_xxxxxxxxxxxxxxxxxxxxxx setGapAtCursor 0\n  // JS_0162_xxxxxxxxxxxxxxxxxxxxxx (unknown) 50818\n  // JS_0163_xxxxxxxxxxxxxxxxxxxxxx value 108267\n\n  symbolicateProfilerMap(mapFile) {\n    return fs\n      .readFileSync(mapFile, \"utf8\")\n      .split(\"\\n\")\n      .slice(0, -1)\n      .map((line) => {\n        const line_list = line.split(\" \");\n        const trampoline = line_list[0];\n        const js_name = line_list[1];\n        const offset = parseInt(line_list[2], 10);\n\n        if (!offset) {\n          return trampoline + \" \" + trampoline;\n        }\n\n        const original = this.getOriginalPositionFor(\n          this.options.inputLineStart,\n          offset\n        );\n        return (\n          trampoline +\n          \" \" +\n          (original.name || js_name) +\n          \"::\" +\n          [original.source, original.line, original.column].join(\":\")\n        );\n      })\n      .join(\"\\n\");\n  }\n\n  symbolicateAttribution(obj) {\n    const loc = obj.location;\n    const line = loc.line != null ? loc.line : this.options.inputLineStart;\n    let column = Number(loc.column != null ? loc.column : loc.virtualOffset);\n    const file = loc.filename ? this.parseFileName(loc.filename) : null;\n    let original = this.getOriginalPositionFor(line, column, file);\n    const isBytecodeRange =\n      loc.bytecodeSize != null &&\n      loc.virtualOffset != null &&\n      loc.column == null;\n    const virtualOffset = Number(loc.virtualOffset);\n    const bytecodeSize = Number(loc.bytecodeSize); // Functions compiled from Metro-bundled modules will often have a little bit\n    // of unmapped wrapper code right at the beginning - which is where we query.\n    // Let's attribute them to where the inner module code originates instead.\n    // This loop is O(n*log(n)) in the size of the function, but we will generally\n    // either:\n    // 1. Find a non-null mapping within one or two iterations; or\n    // 2. Reach the end of the function without encountering mappings - this might\n    //    happen for function bodies that never throw (generally very short).\n\n    while (\n      isBytecodeRange &&\n      original.source == null &&\n      ++column < virtualOffset + bytecodeSize\n    ) {\n      original = this.getOriginalPositionFor(line, column, file);\n    }\n\n    obj.location = {\n      file: original.source,\n      line: original.line,\n      column: original.column,\n    };\n  } // Symbolicate chrome trace \"stackFrames\" section.\n  // Each frame in it has three fields: name, funcVirtAddr(optional), offset(optional).\n  // funcVirtAddr and offset are only available if trace is generated from\n  // hbc bundle without debug info.\n\n  symbolicateChromeTrace(traceFile, { stdout, stderr }) {\n    const content = JSON.parse(fs.readFileSync(traceFile, \"utf8\"));\n\n    if (content.stackFrames == null) {\n      throw new Error(\"Unable to locate `stackFrames` section in trace.\");\n    }\n\n    const keys = Object.keys(content.stackFrames);\n    stdout.write(\"Processing \" + keys.length + \" frames\\n\");\n    keys.forEach((key) => {\n      var _addressOriginal$sour, _addressOriginal$line, _addressOriginal$colu;\n\n      const entry = content.stackFrames[key];\n      let line;\n      let column; // Function entrypoint line/column; used for symbolicating function name\n      // with legacy source maps (or when --no-function-names is set).\n\n      let funcLine;\n      let funcColumn;\n\n      if (entry.funcVirtAddr != null && entry.offset != null) {\n        // Without debug information.\n        const funcVirtAddr = parseInt(entry.funcVirtAddr, 10);\n        const offsetInFunction = parseInt(entry.offset, 10); // Main bundle always use hard-coded line value 1.\n        // TODO: support multiple bundle/module.\n\n        line = this.options.inputLineStart;\n        column = funcVirtAddr + offsetInFunction;\n        funcLine = this.options.inputLineStart;\n        funcColumn = funcVirtAddr;\n      } else if (entry.line != null && entry.column != null) {\n        // For hbc bundle with debug info, name field may already have source\n        // information for the bundle; we still can use the Metro\n        // source map to symbolicate the bundle frame addresses further to its\n        // original source code.\n        line = entry.line;\n        column = entry.column;\n        funcLine = entry.funcLine;\n        funcColumn = entry.funcColumn;\n      } else {\n        // Native frames.\n        return;\n      } // Symbolicate original file/line/column.\n\n      const addressOriginal = this.getOriginalPositionDetailsFor(line, column);\n      let frameName;\n\n      if (addressOriginal.functionName) {\n        frameName = addressOriginal.functionName;\n      } else {\n        frameName = entry.name; // Symbolicate function name.\n\n        if (funcLine != null && funcColumn != null) {\n          const funcOriginal = this.getOriginalPositionFor(\n            funcLine,\n            funcColumn\n          );\n\n          if (funcOriginal.name != null) {\n            frameName = funcOriginal.name;\n          }\n        } else {\n          // No function line/column info.\n          (stderr || stdout).write(\n            \"Warning: no function prolog line/column info; name may be wrong\\n\"\n          );\n        }\n      } // Output format is: funcName(file:line:column)\n\n      entry.name = [\n        frameName,\n        \"(\",\n        [\n          (_addressOriginal$sour = addressOriginal.source) !== null &&\n          _addressOriginal$sour !== void 0\n            ? _addressOriginal$sour\n            : \"null\",\n          (_addressOriginal$line = addressOriginal.line) !== null &&\n          _addressOriginal$line !== void 0\n            ? _addressOriginal$line\n            : \"null\",\n          (_addressOriginal$colu = addressOriginal.column) !== null &&\n          _addressOriginal$colu !== void 0\n            ? _addressOriginal$colu\n            : \"null\",\n        ].join(\":\"),\n        \")\",\n      ].join(\"\");\n    });\n    stdout.write(\"Writing to \" + traceFile + \"\\n\");\n    fs.writeFileSync(traceFile, JSON.stringify(content));\n  }\n  /*\n   * A helper function to return a mapping {line, column} object for a given input\n   * line and column, and optionally a module ID.\n   */\n\n  getOriginalPositionFor(lineNumber, columnNumber, moduleIds) {\n    const position = this.getOriginalPositionDetailsFor(\n      lineNumber,\n      columnNumber,\n      moduleIds\n    );\n    return {\n      line: position.line,\n      column: position.column,\n      source: position.source,\n      name: position.functionName ? position.functionName : position.name,\n    };\n  }\n  /*\n   * Symbolicates the JavaScript stack trace extracted from the minidump\n   * produced by hermes\n   */\n\n  symbolicateHermesMinidumpTrace(crashInfo) {\n    throw new Error(\"Not implemented\");\n  }\n  /**\n   * Symbolicates heap alloction stacks in a Chrome-formatted heap\n   * snapshot/timeline.\n   * Line and column offsets in options (both input and output) are _ignored_,\n   * because this format has a well-defined convention (1-based lines and\n   * columns).\n   */\n\n  symbolicateHeapSnapshot(snapshotContents) {\n    const snapshotData =\n      typeof snapshotContents === \"string\"\n        ? JSON.parse(snapshotContents)\n        : snapshotContents;\n    const processor = new ChromeHeapSnapshotProcessor(snapshotData);\n\n    for (const frame of processor.traceFunctionInfos()) {\n      const moduleIds = this.parseFileName(frame.getString(\"script_name\"));\n      const generatedLine = frame.getNumber(\"line\");\n      const generatedColumn = frame.getNumber(\"column\");\n\n      if (generatedLine === 0 && generatedColumn === 0) {\n        continue;\n      }\n\n      const {\n        line: originalLine,\n        column: originalColumn,\n        source: originalSource,\n        functionName: originalFunctionName,\n      } = this.getOriginalPositionDetailsFor(\n        frame.getNumber(\"line\") - 1 + this.options.inputLineStart,\n        frame.getNumber(\"column\") - 1 + this.options.inputColumnStart,\n        moduleIds\n      );\n\n      if (originalSource != null) {\n        frame.setString(\"script_name\", originalSource);\n\n        if (originalLine != null) {\n          frame.setNumber(\n            \"line\",\n            originalLine - this.options.outputLineStart + 1\n          );\n        } else {\n          frame.setNumber(\"line\", 0);\n        }\n\n        if (originalColumn != null) {\n          frame.setNumber(\n            \"column\",\n            originalColumn - this.options.outputColumnStart + 1\n          );\n        } else {\n          frame.setNumber(\"column\", 0);\n        }\n      }\n\n      frame.setString(\n        \"name\",\n        originalFunctionName !== null && originalFunctionName !== void 0\n          ? originalFunctionName\n          : frame.getString(\"name\")\n      );\n    }\n\n    return snapshotData;\n  }\n  /*\n   * Symbolicates the JavaScript stack trace extracted from the coverage information\n   * produced by HermesRuntime::getExecutedFunctions.\n   */\n\n  symbolicateHermesCoverageTrace(coverageInfo) {\n    const symbolicatedTrace = [];\n    const { executedFunctions } = coverageInfo;\n\n    if (executedFunctions != null) {\n      for (const stackItem of executedFunctions) {\n        const { line, column, SourceURL } = stackItem;\n        const generatedLine = line + this.options.inputLineStart;\n        const generatedColumn = column + this.options.inputColumnStart;\n        const originalPosition = this.getOriginalPositionDetailsFor(\n          generatedLine,\n          generatedColumn,\n          this.parseFileName(SourceURL || \"\")\n        );\n        symbolicatedTrace.push(originalPosition);\n      }\n    }\n\n    return symbolicatedTrace;\n  }\n  /*\n   * An internal helper function similar to getOriginalPositionFor. This one\n   * returns both `name` and `functionName` fields so callers can distinguish the\n   * source of the name.\n   */\n\n  getOriginalPositionDetailsFor(lineNumber, columnNumber, moduleIds) {\n    throw new Error(\"Not implemented\");\n  }\n\n  parseFileName(str) {\n    throw new Error(\"Not implemented\");\n  }\n}\n\nclass SingleMapSymbolicationContext extends SymbolicationContext {\n  // $FlowFixMe[value-as-type]\n  constructor(SourceMapConsumer, sourceMapContent, options = {}) { // $FlowFixMe[value-as-type]\n    super(options);\n    this._SourceMapConsumer = SourceMapConsumer;\n    const sourceMapJson =\n      typeof sourceMapContent === \"string\"\n        ? JSON.parse(sourceMapContent.replace(/^\\)\\]\\}'/, \"\"))\n        : sourceMapContent;\n    const segments = {\n      0: this._initSegment(sourceMapJson),\n    };\n\n    if (sourceMapJson.x_facebook_segments) {\n      for (const key of Object.keys(sourceMapJson.x_facebook_segments)) {\n        const map = sourceMapJson.x_facebook_segments[key];\n        segments[key] = this._initSegment(map);\n      }\n    }\n\n    this._legacyFormat =\n      sourceMapJson.x_facebook_segments != null ||\n      sourceMapJson.x_facebook_offsets != null;\n    this._segments = segments;\n  }\n\n  _initSegment(map) {\n    const useFunctionNames = this.options.nameSource === \"function_names\";\n    const { _SourceMapConsumer: SourceMapConsumer } = this;\n    return {\n      get consumer() {\n        Object.defineProperty(this, \"consumer\", {\n          value: new SourceMapConsumer(map),\n        });\n        return this.consumer;\n      },\n\n      moduleOffsets: map.x_facebook_offsets || [],\n\n      get sourceFunctionsConsumer() {\n        Object.defineProperty(this, \"sourceFunctionsConsumer\", {\n          value: useFunctionNames ? new SourceMetadataMapConsumer(map) : null,\n        });\n        return this.sourceFunctionsConsumer;\n      },\n\n      hermesOffsets: map.x_hermes_function_offsets,\n    };\n  }\n\n  symbolicateHermesMinidumpTrace(crashInfo) {\n    const symbolicatedTrace = [];\n    const { callstack } = crashInfo;\n\n    if (callstack != null) {\n      for (const stackItem of callstack) {\n        if (stackItem.NativeCode) {\n          symbolicatedTrace.push(stackItem);\n        } else {\n          const {\n            CJSModuleOffset,\n            SegmentID,\n            SourceURL,\n            FunctionID,\n            ByteCodeOffset: localOffset,\n          } = stackItem;\n          const cjsModuleOffsetOrSegmentID = nullthrows(\n            CJSModuleOffset !== null && CJSModuleOffset !== void 0\n              ? CJSModuleOffset\n              : SegmentID,\n            \"Either CJSModuleOffset or SegmentID must be specified in the Hermes stack frame\"\n          );\n          const moduleInformation = this.parseFileName(SourceURL);\n          const generatedLine =\n            cjsModuleOffsetOrSegmentID + this.options.inputLineStart;\n\n          const segment =\n            this._segments[moduleInformation.segmentId.toString()];\n\n          const hermesOffsets =\n            segment === null || segment === void 0\n              ? void 0\n              : segment.hermesOffsets;\n\n          if (!hermesOffsets) {\n            symbolicatedTrace.push({\n              line: null,\n              column: null,\n              source: null,\n              functionName: null,\n              name: null,\n            });\n          } else {\n            const segmentOffsets =\n              hermesOffsets[Number(cjsModuleOffsetOrSegmentID)];\n            const generatedColumn =\n              segmentOffsets[FunctionID] +\n              localOffset +\n              this.options.inputColumnStart;\n            const originalPosition = this.getOriginalPositionDetailsFor(\n              generatedLine,\n              generatedColumn,\n              moduleInformation\n            );\n            symbolicatedTrace.push(originalPosition);\n          }\n        }\n      }\n    }\n\n    return symbolicatedTrace;\n  }\n\n  symbolicateHermesCoverageTrace(coverageInfo) {\n    const symbolicatedTrace = [];\n    const { executedFunctions } = coverageInfo;\n\n    if (executedFunctions != null) {\n      for (const stackItem of executedFunctions) {\n        const { line, column, SourceURL } = stackItem;\n        const generatedLine = line + this.options.inputLineStart;\n        const generatedColumn = column + this.options.inputColumnStart;\n        const originalPosition = this.getOriginalPositionDetailsFor(\n          generatedLine,\n          generatedColumn,\n          this.parseFileName(SourceURL || \"\")\n        );\n        symbolicatedTrace.push(originalPosition);\n      }\n    }\n\n    return symbolicatedTrace;\n  }\n  /*\n   * An internal helper function similar to getOriginalPositionFor. This one\n   * returns both `name` and `functionName` fields so callers can distinguish the\n   * source of the name.\n   */\n\n  getOriginalPositionDetailsFor(lineNumber, columnNumber, moduleIds) {\n    // Adjust arguments to source-map's input coordinates\n    lineNumber =\n      lineNumber != null\n        ? lineNumber - this.options.inputLineStart + 1\n        : lineNumber;\n    columnNumber =\n      columnNumber != null\n        ? columnNumber - this.options.inputColumnStart + 0\n        : columnNumber;\n\n    if (!moduleIds) {\n      moduleIds = UNKNOWN_MODULE_IDS;\n    }\n\n    let moduleLineOffset = 0;\n    const metadata = this._segments[moduleIds.segmentId + \"\"];\n    const { localId } = moduleIds;\n\n    if (localId != null) {\n      const { moduleOffsets } = metadata;\n\n      if (!moduleOffsets) {\n        throw new Error(\n          \"Module ID given for a source map that does not have \" +\n            \"an x_facebook_offsets field\"\n        );\n      }\n\n      if (moduleOffsets[localId] == null) {\n        throw new Error(\"Unknown module ID: \" + localId);\n      }\n\n      moduleLineOffset = moduleOffsets[localId];\n    }\n\n    const original = metadata.consumer.originalPositionFor({\n      line: Number(lineNumber) + moduleLineOffset,\n      column: Number(columnNumber),\n    });\n\n    if (metadata.sourceFunctionsConsumer) {\n      original.functionName =\n        metadata.sourceFunctionsConsumer.functionNameFor(original) || null;\n    } else {\n      original.functionName = null;\n    }\n\n    return {\n      ...original,\n      line:\n        original.line != null\n          ? original.line - 1 + this.options.outputLineStart\n          : original.line,\n      column:\n        original.column != null\n          ? original.column - 0 + this.options.outputColumnStart\n          : original.column,\n    };\n  }\n\n  parseFileName(str) {\n    if (this._legacyFormat) {\n      return parseSingleMapFileName(str);\n    }\n\n    return UNKNOWN_MODULE_IDS;\n  }\n}\n\nclass DirectorySymbolicationContext extends SymbolicationContext {\n  // $FlowFixMe[value-as-type]\n  constructor(SourceMapConsumer, rootDir, options = {}) { // $FlowFixMe[value-as-type]\n    super(options);\n    this._fileMaps = new Map();\n    this._rootDir = rootDir;\n    this._SourceMapConsumer = SourceMapConsumer;\n  }\n\n  _loadMap(mapFilename) {\n    invariant(\n      fs.existsSync(mapFilename),\n      `Could not read source map from '${mapFilename}'`\n    );\n\n    let fileMap = this._fileMaps.get(mapFilename);\n\n    if (fileMap == null) {\n      fileMap = new SingleMapSymbolicationContext(\n        this._SourceMapConsumer,\n        fs.readFileSync(mapFilename, \"utf8\"),\n        this.options\n      );\n\n      this._fileMaps.set(mapFilename, fileMap);\n    }\n\n    return fileMap;\n  }\n  /*\n   * An internal helper function similar to getOriginalPositionFor. This one\n   * returns both `name` and `functionName` fields so callers can distinguish the\n   * source of the name.\n   */\n\n  getOriginalPositionDetailsFor(lineNumber, columnNumber, filename) {\n    invariant(\n      filename != null,\n      \"filename is required for DirectorySymbolicationContext\"\n    );\n    let mapFilename;\n    const relativeFilename = path.relative(\n      this._rootDir,\n      path.resolve(this._rootDir, filename)\n    ); // Lock down access to files outside the root dir.\n\n    if (!relativeFilename.startsWith(\"..\")) {\n      mapFilename = path.join(this._rootDir, relativeFilename + \".map\");\n    }\n\n    if (mapFilename == null || !fs.existsSync(mapFilename)) {\n      // Adjust arguments to the output coordinates\n      lineNumber =\n        lineNumber != null\n          ? lineNumber -\n            this.options.inputLineStart +\n            this.options.outputLineStart\n          : lineNumber;\n      columnNumber =\n        columnNumber != null\n          ? columnNumber -\n            this.options.inputColumnStart +\n            this.options.outputColumnStart\n          : columnNumber;\n      return {\n        line: lineNumber,\n        column: columnNumber,\n        source: filename,\n        name: null,\n        functionName: null,\n      };\n    }\n\n    return this._loadMap(mapFilename).getOriginalPositionDetailsFor(\n      lineNumber,\n      columnNumber\n    );\n  }\n\n  parseFileName(str) {\n    return str;\n  }\n}\n/*\n * If the file name of a stack frame is numeric (+ \".js\"), we assume it's a\n * lazily injected module coming from a \"random access bundle\". We are using\n * special source maps for these bundles, so that we can symbolicate stack\n * traces for multiple injected files with a single source map.\n *\n * There is also a convention for callsites that are in split segments of a\n * bundle, named either `seg-3.js` for segment #3 for example, or `seg-3_5.js`\n * for module #5 of segment #3 of a segmented RAM bundle.\n */\n\nfunction parseSingleMapFileName(str) {\n  const modMatch = str.match(/^(\\d+).js$/);\n\n  if (modMatch != null) {\n    return {\n      segmentId: 0,\n      localId: Number(modMatch[1]),\n    };\n  }\n\n  const segMatch = str.match(/^seg-(\\d+)(?:_(\\d+))?.js$/);\n\n  if (segMatch != null) {\n    return {\n      segmentId: Number(segMatch[1]),\n      localId: segMatch[2] ? Number(segMatch[2]) : null,\n    };\n  }\n\n  return UNKNOWN_MODULE_IDS;\n}\n\nfunction createContext(SourceMapConsumer, sourceMapContent, options = {}) { // $FlowFixMe[value-as-type]\n  return new SingleMapSymbolicationContext(\n    SourceMapConsumer,\n    sourceMapContent,\n    options\n  );\n}\n\nfunction unstable_createDirectoryContext( // $FlowFixMe[value-as-type]\n  SourceMapConsumer,\n  rootDir,\n  options = {}\n) {\n  return new DirectorySymbolicationContext(SourceMapConsumer, rootDir, options);\n}\n\nfunction getOriginalPositionFor(lineNumber, columnNumber, moduleIds, context) {\n  return context.getOriginalPositionFor(lineNumber, columnNumber, moduleIds);\n}\n\nfunction symbolicate(stackTrace, context) {\n  return context.symbolicate(stackTrace);\n}\n\nfunction symbolicateProfilerMap(mapFile, context) {\n  return context.symbolicateProfilerMap(mapFile);\n}\n\nfunction symbolicateAttribution(obj, context) {\n  context.symbolicateAttribution(obj);\n}\n\nfunction symbolicateChromeTrace(traceFile, { stdout, stderr }, context) {\n  return context.symbolicateChromeTrace(traceFile, {\n    stdout,\n    stderr,\n  });\n}\n\nmodule.exports = {\n  createContext,\n  unstable_createDirectoryContext,\n  getOriginalPositionFor,\n  parseFileName: parseSingleMapFileName,\n  symbolicate,\n  symbolicateProfilerMap,\n  symbolicateAttribution,\n  symbolicateChromeTrace,\n  SourceMetadataMapConsumer,\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}