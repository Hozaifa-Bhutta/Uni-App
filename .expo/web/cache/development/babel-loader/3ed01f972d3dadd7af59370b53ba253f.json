{"ast":null,"code":"\"use strict\";\n\nvar _slicedToArray = require(\"@babel/runtime/helpers/slicedToArray\");\n\nfunction _createForOfIteratorHelperLoose(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (it) return (it = it.call(o)).next.bind(it); if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nvar traverse = require(\"@babel/traverse\").default;\n\nvar nullthrows = require(\"nullthrows\");\n\nfunction normalizePseudoglobals(ast, options) {\n  var _options$reservedName;\n\n  var reservedNames = new Set((_options$reservedName = options === null || options === void 0 ? void 0 : options.reservedNames) !== null && _options$reservedName !== void 0 ? _options$reservedName : []);\n  var renamedParamNames = [];\n  traverse(ast, {\n    Program: function Program(path) {\n      var params = path.get(\"body.0.expression.arguments.0.params\");\n      var body = path.get(\"body.0.expression.arguments.0.body\");\n\n      if (!body || Array.isArray(body) || !Array.isArray(params)) {\n        path.stop();\n        return;\n      }\n\n      var pseudoglobals = params.map(function (path) {\n        return path.node.name;\n      }).filter(function (name) {\n        return !reservedNames.has(name);\n      });\n      var usedShortNames = new Set();\n      var namePairs = pseudoglobals.map(function (fullName) {\n        return [fullName, getShortName(fullName, usedShortNames)];\n      });\n\n      for (var _iterator = _createForOfIteratorHelperLoose(namePairs), _step; !(_step = _iterator()).done;) {\n        var _ref = _step.value;\n\n        var _ref2 = _slicedToArray(_ref, 2);\n\n        var fullName = _ref2[0];\n        var shortName = _ref2[1];\n\n        if (reservedNames.has(shortName)) {\n          throw new ReferenceError(\"Could not reserve the identifier \" + shortName + \" because it is the short name for \" + fullName);\n        }\n\n        renamedParamNames.push(rename(fullName, shortName, body.scope));\n      }\n\n      path.stop();\n    }\n  });\n  return renamedParamNames;\n}\n\nfunction getShortName(fullName, usedNames) {\n  var regexp = /^[^A-Za-z]*([A-Za-z])|([A-Z])[a-z]|([A-Z])[A-Z]+$/g;\n  var match;\n\n  while (match = regexp.exec(fullName)) {\n    var name = (match[1] || match[2] || match[3] || \"\").toLowerCase();\n\n    if (!name) {\n      throw new ReferenceError(\"Could not identify any valid name for \" + fullName);\n    }\n\n    if (!usedNames.has(name)) {\n      usedNames.add(name);\n      return name;\n    }\n  }\n\n  throw new ReferenceError(\"Unable to determine short name for \" + fullName + \". The variables are not unique: \" + Array.from(usedNames).join(\", \"));\n}\n\nfunction rename(fullName, shortName, scope) {\n  var unusedName = shortName;\n\n  if (scope.hasLabel(shortName) || scope.hasBinding(shortName) || scope.hasGlobal(shortName) || scope.hasReference(shortName)) {\n    unusedName = scope.generateUid(shortName);\n    var programScope = scope.getProgramParent();\n    nullthrows(programScope.references)[shortName] = true;\n    nullthrows(programScope.uids)[shortName] = true;\n  }\n\n  scope.rename(fullName, unusedName);\n  return unusedName;\n}\n\nmodule.exports = normalizePseudoglobals;","map":{"version":3,"names":["traverse","require","default","nullthrows","normalizePseudoglobals","ast","options","_options$reservedName","reservedNames","Set","renamedParamNames","Program","path","params","get","body","Array","isArray","stop","pseudoglobals","map","node","name","filter","has","usedShortNames","namePairs","fullName","getShortName","shortName","ReferenceError","push","rename","scope","usedNames","regexp","match","exec","toLowerCase","add","from","join","unusedName","hasLabel","hasBinding","hasGlobal","hasReference","generateUid","programScope","getProgramParent","references","uids","module","exports"],"sources":["/Users/hozaifa/Documents/Uni App Github/node_modules/@react-native-community/cli-plugin-metro/node_modules/metro-transform-plugins/src/normalizePseudoGlobals.js"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *\n * @format\n */\n\"use strict\";\n\nconst traverse = require(\"@babel/traverse\").default;\n\nconst nullthrows = require(\"nullthrows\");\n\nfunction normalizePseudoglobals(ast, options) {\n  var _options$reservedName;\n\n  const reservedNames = new Set(\n    (_options$reservedName =\n      options === null || options === void 0\n        ? void 0\n        : options.reservedNames) !== null && _options$reservedName !== void 0\n      ? _options$reservedName\n      : []\n  );\n  const renamedParamNames = [];\n  traverse(ast, {\n    Program(path) {\n      const params = path.get(\"body.0.expression.arguments.0.params\");\n      const body = path.get(\"body.0.expression.arguments.0.body\");\n\n      if (!body || Array.isArray(body) || !Array.isArray(params)) {\n        path.stop();\n        return;\n      }\n\n      const pseudoglobals = params // $FlowFixMe Flow error uncovered by typing Babel more strictly\n        .map((path) => path.node.name)\n        .filter((name) => !reservedNames.has(name));\n      const usedShortNames = new Set();\n      const namePairs = pseudoglobals.map((fullName) => [\n        fullName,\n        getShortName(fullName, usedShortNames),\n      ]);\n\n      for (const [fullName, shortName] of namePairs) {\n        if (reservedNames.has(shortName)) {\n          throw new ReferenceError(\n            \"Could not reserve the identifier \" +\n              shortName +\n              \" because it is the short name for \" +\n              fullName\n          );\n        }\n\n        renamedParamNames.push(rename(fullName, shortName, body.scope));\n      }\n\n      path.stop();\n    },\n  });\n  return renamedParamNames;\n}\n\nfunction getShortName(fullName, usedNames) {\n  // Try finding letters that are semantically relatable to the name\n  // of the variable given. For instance, in XMLHttpRequest, it will\n  // first match \"X\", then \"H\", then \"R\".\n  const regexp = /^[^A-Za-z]*([A-Za-z])|([A-Z])[a-z]|([A-Z])[A-Z]+$/g;\n  let match;\n\n  while ((match = regexp.exec(fullName))) {\n    const name = (match[1] || match[2] || match[3] || \"\").toLowerCase();\n\n    if (!name) {\n      throw new ReferenceError(\n        \"Could not identify any valid name for \" + fullName\n      );\n    }\n\n    if (!usedNames.has(name)) {\n      usedNames.add(name);\n      return name;\n    }\n  }\n\n  throw new ReferenceError(\n    `Unable to determine short name for ${fullName}. The variables are not unique: ${Array.from(\n      usedNames\n    ).join(\", \")}`\n  );\n}\n\nfunction rename(fullName, shortName, scope) {\n  let unusedName = shortName; // `generateUid` generates a name of the form name_ even if there was no conflict which we don't want.\n  // Check if the desired name was never used and in that case proceed and only use `generateUid` if there's a\n  // name clash.\n\n  if (\n    scope.hasLabel(shortName) ||\n    scope.hasBinding(shortName) ||\n    scope.hasGlobal(shortName) ||\n    scope.hasReference(shortName)\n  ) {\n    unusedName = scope.generateUid(shortName);\n    const programScope = scope.getProgramParent();\n    nullthrows(programScope.references)[shortName] = true;\n    nullthrows(programScope.uids)[shortName] = true;\n  }\n\n  scope.rename(fullName, unusedName);\n  return unusedName;\n}\n\nmodule.exports = normalizePseudoglobals;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}