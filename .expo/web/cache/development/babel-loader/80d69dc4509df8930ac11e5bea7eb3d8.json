{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"@babel/runtime/regenerator\");\n\nvar _defineProperty = require(\"@babel/runtime/helpers/defineProperty\");\n\nvar _objectWithoutProperties = require(\"@babel/runtime/helpers/objectWithoutProperties\");\n\nvar _classCallCheck = require(\"@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"@babel/runtime/helpers/createClass\");\n\nvar _excluded = [\"getTransformOptions\", \"transformVariants\", \"workerPath\"],\n    _excluded2 = [\"customTransformOptions\", \"dev\", \"experimentalImportSupport\", \"hot\", \"inlinePlatform\", \"inlineRequires\", \"minify\", \"nonInlinedRequires\", \"platform\", \"runtimeBytecodeVersion\", \"type\", \"unstable_disableES6Transforms\", \"unstable_transformProfile\"];\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nvar getTransformCacheKey = require(\"./getTransformCacheKey\");\n\nvar WorkerFarm = require(\"./WorkerFarm\");\n\nvar assert = require(\"assert\");\n\nvar fs = require(\"fs\");\n\nvar _require = require(\"metro-cache\"),\n    Cache = _require.Cache,\n    stableHash = _require.stableHash;\n\nvar path = require(\"path\");\n\nvar Transformer = function () {\n  function Transformer(config, getSha1Fn) {\n    _classCallCheck(this, Transformer);\n\n    this._config = config;\n\n    this._config.watchFolders.forEach(verifyRootExists);\n\n    this._cache = new Cache(config.cacheStores);\n    this._getSha1 = getSha1Fn;\n\n    var _this$_config$transfo = this._config.transformer,\n        _getTransformOptions = _this$_config$transfo.getTransformOptions,\n        _transformVariants = _this$_config$transfo.transformVariants,\n        _workerPath = _this$_config$transfo.workerPath,\n        transformerConfig = _objectWithoutProperties(_this$_config$transfo, _excluded);\n\n    var transformerOptions = {\n      transformerPath: this._config.transformerPath,\n      transformerConfig: transformerConfig\n    };\n    this._workerFarm = new WorkerFarm(config, transformerOptions);\n    var globalCacheKey = this._cache.isDisabled ? \"\" : getTransformCacheKey({\n      cacheVersion: this._config.cacheVersion,\n      projectRoot: this._config.projectRoot,\n      transformerConfig: transformerOptions\n    });\n    this._baseHash = stableHash([globalCacheKey]).toString(\"binary\");\n  }\n\n  _createClass(Transformer, [{\n    key: \"transformFile\",\n    value: function transformFile(filePath, transformerOptions) {\n      var cache, customTransformOptions, dev, experimentalImportSupport, hot, inlinePlatform, inlineRequires, minify, nonInlinedRequires, platform, runtimeBytecodeVersion, type, unstable_disableES6Transforms, unstable_transformProfile, extra, key, localPath, partialKey, sha1, fullKey, result, data;\n      return _regeneratorRuntime.async(function transformFile$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              cache = this._cache;\n              customTransformOptions = transformerOptions.customTransformOptions, dev = transformerOptions.dev, experimentalImportSupport = transformerOptions.experimentalImportSupport, hot = transformerOptions.hot, inlinePlatform = transformerOptions.inlinePlatform, inlineRequires = transformerOptions.inlineRequires, minify = transformerOptions.minify, nonInlinedRequires = transformerOptions.nonInlinedRequires, platform = transformerOptions.platform, runtimeBytecodeVersion = transformerOptions.runtimeBytecodeVersion, type = transformerOptions.type, unstable_disableES6Transforms = transformerOptions.unstable_disableES6Transforms, unstable_transformProfile = transformerOptions.unstable_transformProfile, extra = _objectWithoutProperties(transformerOptions, _excluded2);\n              _context.t0 = _regeneratorRuntime.keys(extra);\n\n            case 3:\n              if ((_context.t1 = _context.t0()).done) {\n                _context.next = 9;\n                break;\n              }\n\n              key = _context.t1.value;\n\n              if (!hasOwnProperty.call(extra, key)) {\n                _context.next = 7;\n                break;\n              }\n\n              throw new Error(\"Extra keys detected: \" + Object.keys(extra).join(\", \"));\n\n            case 7:\n              _context.next = 3;\n              break;\n\n            case 9:\n              localPath = path.relative(this._config.projectRoot, filePath);\n              partialKey = stableHash([this._baseHash, localPath, customTransformOptions, dev, experimentalImportSupport, hot, inlinePlatform, inlineRequires, minify, nonInlinedRequires, platform, runtimeBytecodeVersion, type, unstable_disableES6Transforms, unstable_transformProfile]);\n              sha1 = this._getSha1(filePath);\n              fullKey = Buffer.concat([partialKey, Buffer.from(sha1, \"hex\")]);\n              _context.next = 15;\n              return _regeneratorRuntime.awrap(cache.get(fullKey));\n\n            case 15:\n              result = _context.sent;\n\n              if (!result) {\n                _context.next = 20;\n                break;\n              }\n\n              _context.t2 = {\n                result: result,\n                sha1: sha1\n              };\n              _context.next = 23;\n              break;\n\n            case 20:\n              _context.next = 22;\n              return _regeneratorRuntime.awrap(this._workerFarm.transform(localPath, transformerOptions));\n\n            case 22:\n              _context.t2 = _context.sent;\n\n            case 23:\n              data = _context.t2;\n\n              if (sha1 !== data.sha1) {\n                fullKey = Buffer.concat([partialKey, Buffer.from(data.sha1, \"hex\")]);\n              }\n\n              cache.set(fullKey, data.result);\n              return _context.abrupt(\"return\", _objectSpread(_objectSpread({}, data.result), {}, {\n                getSource: function getSource() {\n                  return fs.readFileSync(filePath);\n                }\n              }));\n\n            case 27:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, null, this, null, Promise);\n    }\n  }, {\n    key: \"end\",\n    value: function end() {\n      this._workerFarm.kill();\n    }\n  }]);\n\n  return Transformer;\n}();\n\nfunction verifyRootExists(root) {\n  assert(fs.statSync(root).isDirectory(), \"Root has to be a valid directory\");\n}\n\nmodule.exports = Transformer;","map":{"version":3,"names":["getTransformCacheKey","require","WorkerFarm","assert","fs","Cache","stableHash","path","Transformer","config","getSha1Fn","_config","watchFolders","forEach","verifyRootExists","_cache","cacheStores","_getSha1","transformer","_getTransformOptions","getTransformOptions","_transformVariants","transformVariants","_workerPath","workerPath","transformerConfig","transformerOptions","transformerPath","_workerFarm","globalCacheKey","isDisabled","cacheVersion","projectRoot","_baseHash","toString","filePath","cache","customTransformOptions","dev","experimentalImportSupport","hot","inlinePlatform","inlineRequires","minify","nonInlinedRequires","platform","runtimeBytecodeVersion","type","unstable_disableES6Transforms","unstable_transformProfile","extra","key","hasOwnProperty","call","Error","Object","keys","join","localPath","relative","partialKey","sha1","fullKey","Buffer","concat","from","get","result","transform","data","set","getSource","readFileSync","kill","root","statSync","isDirectory","module","exports"],"sources":["/Users/hozaifa/Documents/Uni App Github/node_modules/@react-native-community/cli-plugin-metro/node_modules/metro/src/DeltaBundler/Transformer.js"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *\n * @format\n */\n\"use strict\";\n\nconst getTransformCacheKey = require(\"./getTransformCacheKey\");\n\nconst WorkerFarm = require(\"./WorkerFarm\");\n\nconst assert = require(\"assert\");\n\nconst fs = require(\"fs\");\n\nconst { Cache, stableHash } = require(\"metro-cache\");\n\nconst path = require(\"path\");\n\nclass Transformer {\n  constructor(config, getSha1Fn) {\n    this._config = config;\n\n    this._config.watchFolders.forEach(verifyRootExists);\n\n    this._cache = new Cache(config.cacheStores);\n    this._getSha1 = getSha1Fn; // Remove the transformer config params that we don't want to pass to the\n    // transformer. We should change the config object and move them away so we\n    // can treat the transformer config params as opaque.\n\n    const {\n      getTransformOptions: _getTransformOptions,\n      transformVariants: _transformVariants,\n      workerPath: _workerPath,\n      ...transformerConfig\n    } = this._config.transformer;\n    const transformerOptions = {\n      transformerPath: this._config.transformerPath,\n      transformerConfig,\n    };\n    this._workerFarm = new WorkerFarm(config, transformerOptions);\n    const globalCacheKey = this._cache.isDisabled\n      ? \"\"\n      : getTransformCacheKey({\n          cacheVersion: this._config.cacheVersion,\n          projectRoot: this._config.projectRoot,\n          transformerConfig: transformerOptions,\n        });\n    this._baseHash = stableHash([globalCacheKey]).toString(\"binary\");\n  }\n\n  async transformFile(filePath, transformerOptions) {\n    const cache = this._cache;\n    const {\n      customTransformOptions,\n      dev,\n      experimentalImportSupport,\n      hot,\n      inlinePlatform,\n      inlineRequires,\n      minify,\n      nonInlinedRequires,\n      platform,\n      runtimeBytecodeVersion,\n      type,\n      unstable_disableES6Transforms,\n      unstable_transformProfile,\n      ...extra\n    } = transformerOptions;\n\n    for (const key in extra) {\n      // $FlowFixMe[cannot-resolve-name]\n      if (hasOwnProperty.call(extra, key)) {\n        throw new Error(\n          \"Extra keys detected: \" + Object.keys(extra).join(\", \")\n        );\n      }\n    }\n\n    const localPath = path.relative(this._config.projectRoot, filePath);\n    const partialKey = stableHash([\n      // This is the hash related to the global Bundler config.\n      this._baseHash, // Path.\n      localPath,\n      customTransformOptions,\n      dev,\n      experimentalImportSupport,\n      hot,\n      inlinePlatform,\n      inlineRequires,\n      minify,\n      nonInlinedRequires,\n      platform,\n      runtimeBytecodeVersion,\n      type,\n      unstable_disableES6Transforms,\n      unstable_transformProfile,\n    ]);\n\n    const sha1 = this._getSha1(filePath);\n\n    let fullKey = Buffer.concat([partialKey, Buffer.from(sha1, \"hex\")]);\n    const result = await cache.get(fullKey); // A valid result from the cache is used directly; otherwise we call into\n    // the transformer to computed the corresponding result.\n\n    const data = result\n      ? {\n          result,\n          sha1,\n        }\n      : await this._workerFarm.transform(localPath, transformerOptions); // Only re-compute the full key if the SHA-1 changed. This is because\n    // references are used by the cache implementation in a weak map to keep\n    // track of the cache that returned the result.\n\n    if (sha1 !== data.sha1) {\n      fullKey = Buffer.concat([partialKey, Buffer.from(data.sha1, \"hex\")]);\n    }\n\n    cache.set(fullKey, data.result);\n    return {\n      ...data.result,\n\n      getSource() {\n        return fs.readFileSync(filePath);\n      },\n    };\n  }\n\n  end() {\n    this._workerFarm.kill();\n  }\n}\n\nfunction verifyRootExists(root) {\n  // Verify that the root exists.\n  assert(fs.statSync(root).isDirectory(), \"Root has to be a valid directory\");\n}\n\nmodule.exports = Transformer;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}