{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"@babel/runtime/regenerator\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.fetchToTemp = exports.fetch = void 0;\n\nfunction os() {\n  var data = _interopRequireWildcard(require(\"os\"));\n\n  os = function os() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction path() {\n  var data = _interopRequireWildcard(require(\"path\"));\n\n  path = function path() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction fs() {\n  var data = _interopRequireWildcard(require(\"fs\"));\n\n  fs = function fs() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _nodeFetch() {\n  var data = _interopRequireDefault(require(\"node-fetch\"));\n\n  _nodeFetch = function _nodeFetch() {\n    return data;\n  };\n\n  return data;\n}\n\nvar _errors = require(\"./errors\");\n\nvar _logger = _interopRequireDefault(require(\"./logger\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _getRequireWildcardCache(nodeInterop) {\n  if (typeof WeakMap !== \"function\") return null;\n  var cacheBabelInterop = new WeakMap();\n  var cacheNodeInterop = new WeakMap();\n  return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) {\n    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\n  })(nodeInterop);\n}\n\nfunction _interopRequireWildcard(obj, nodeInterop) {\n  if (!nodeInterop && obj && obj.__esModule) {\n    return obj;\n  }\n\n  if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n    return {\n      default: obj\n    };\n  }\n\n  var cache = _getRequireWildcardCache(nodeInterop);\n\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n\n  for (var key in obj) {\n    if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n\n  newObj.default = obj;\n\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n\n  return newObj;\n}\n\nfunction unwrapFetchResult(response) {\n  var data;\n  return _regeneratorRuntime.async(function unwrapFetchResult$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          _context.next = 2;\n          return _regeneratorRuntime.awrap(response.text());\n\n        case 2:\n          data = _context.sent;\n          _context.prev = 3;\n          return _context.abrupt(\"return\", JSON.parse(data));\n\n        case 7:\n          _context.prev = 7;\n          _context.t0 = _context[\"catch\"](3);\n          return _context.abrupt(\"return\", data);\n\n        case 10:\n        case \"end\":\n          return _context.stop();\n      }\n    }\n  }, null, null, [[3, 7]], Promise);\n}\n\nvar fetchToTemp = function fetchToTemp(url) {\n  try {\n    return new Promise(function (resolve, reject) {\n      var fileName = path().basename(url);\n      var tmpDir = path().join(os().tmpdir(), fileName);\n      (0, _nodeFetch().default)(url).then(function (result) {\n        if (result.status >= 400) {\n          return reject(\"Fetch request failed with status \" + result.status);\n        }\n\n        var dest = fs().createWriteStream(tmpDir);\n        result.body.pipe(dest);\n        result.body.on('end', function () {\n          resolve(tmpDir);\n        });\n        result.body.on('error', reject);\n      });\n    });\n  } catch (e) {\n    _logger.default.error(e);\n\n    throw e;\n  }\n};\n\nexports.fetchToTemp = fetchToTemp;\n\nvar fetch = function _callee(url, options) {\n  var result, data;\n  return _regeneratorRuntime.async(function _callee$(_context2) {\n    while (1) {\n      switch (_context2.prev = _context2.next) {\n        case 0:\n          _context2.next = 2;\n          return _regeneratorRuntime.awrap((0, _nodeFetch().default)(url, options));\n\n        case 2:\n          result = _context2.sent;\n          _context2.next = 5;\n          return _regeneratorRuntime.awrap(unwrapFetchResult(result));\n\n        case 5:\n          data = _context2.sent;\n\n          if (!(result.status >= 400)) {\n            _context2.next = 8;\n            break;\n          }\n\n          throw new _errors.CLIError(\"Fetch request failed with status \" + result.status + \": \" + data + \".\");\n\n        case 8:\n          return _context2.abrupt(\"return\", {\n            status: result.status,\n            headers: result.headers,\n            data: data\n          });\n\n        case 9:\n        case \"end\":\n          return _context2.stop();\n      }\n    }\n  }, null, null, null, Promise);\n};\n\nexports.fetch = fetch;","map":{"version":3,"sources":["../src/fetch.ts"],"names":["data","response","JSON","fetchToTemp","url","fileName","path","tmpDir","os","result","reject","dest","fs","resolve","logger","fetch","unwrapFetchResult","CLIError","status","headers"],"mappings":";;;;;;;;;AAAA,SAAA,EAAA,GAAA;EAAA,IAAA,IAAA,GAAA,uBAAA,CAAA,OAAA,CAAA,IAAA,CAAA,CAAA;;EAAA,EAAA,GAAA,cAAA;IAAA,OAAA,IAAA;EAAA,CAAA;;EAAA,OAAA,IAAA;AAAA;;AACA,SAAA,IAAA,GAAA;EAAA,IAAA,IAAA,GAAA,uBAAA,CAAA,OAAA,CAAA,MAAA,CAAA,CAAA;;EAAA,IAAA,GAAA,gBAAA;IAAA,OAAA,IAAA;EAAA,CAAA;;EAAA,OAAA,IAAA;AAAA;;AACA,SAAA,EAAA,GAAA;EAAA,IAAA,IAAA,GAAA,uBAAA,CAAA,OAAA,CAAA,IAAA,CAAA,CAAA;;EAAA,EAAA,GAAA,cAAA;IAAA,OAAA,IAAA;EAAA,CAAA;;EAAA,OAAA,IAAA;AAAA;;AAEA,SAAA,UAAA,GAAA;EAAA,IAAA,IAAA,GAAA,sBAAA,CAAA,OAAA,CAAA,YAAA,CAAA,CAAA;;EAAA,UAAA,GAAA,sBAAA;IAAA,OAAA,IAAA;EAAA,CAAA;;EAAA,OAAA,IAAA;AAAA;;AAMA,IAAA,OAAA,GAAA,OAAA,YAAA;;AACA,IAAA,OAAA,GAAA,sBAAA,CAAA,OAAA,YAAA,CAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAEA,SAAA,iBAAA,CAAA,QAAA;EAAA;EAAA;IAAA;MAAA;QAAA;UAAA;UAAA,iCACqBC,QAAQ,CAA3B,IAAmBA,EADrB;;QAAA;UACQD,IADR;UAAA;UAAA,iCAIWE,IAAI,CAAJA,KAAAA,CAAP,IAAOA,CAJX;;QAAA;UAAA;UAAA;UAAA,iCAMI,IANJ;;QAAA;QAAA;UAAA;MAAA;IAAA;EAAA;AAAA;;AAcA,IAAMC,WAAW,GAAIC,SAAfD,WAAeC,CAAAA,GAAD,EAAkC;EACpD,IAAI;IACF,OAAO,IAAA,OAAA,CAAY,UAAA,OAAA,EAAA,MAAA,EAAqB;MACtC,IAAMC,QAAQ,GAAGC,IAAI,GAAJA,QAAAA,CAAjB,GAAiBA,CAAjB;MACA,IAAMC,MAAM,GAAGD,IAAI,GAAJA,IAAAA,CAAUE,EAAE,GAAZF,MAAUE,EAAVF,EAAf,QAAeA,CAAf;MAEA,CAAA,GAAA,UAAA,GAAA,OAAA,EAAA,GAAA,EAAA,IAAA,CAAqBG,UAAAA,MAAD,EAAY;QAC9B,IAAIA,MAAM,CAANA,MAAAA,IAAJ,GAAA,EAA0B;UACxB,OAAOC,MAAM,uCAAqCD,MAAM,CAAxD,MAAa,CAAb;QACD;;QAED,IAAME,IAAI,GAAGC,EAAE,GAAFA,iBAAAA,CAAb,MAAaA,CAAb;QACAH,MAAM,CAANA,IAAAA,CAAAA,IAAAA,CAAAA,IAAAA;QAEAA,MAAM,CAANA,IAAAA,CAAAA,EAAAA,CAAAA,KAAAA,EAAsB,YAAM;UAC1BI,OAAO,CAAPA,MAAO,CAAPA;QADFJ,CAAAA;QAIAA,MAAM,CAANA,IAAAA,CAAAA,EAAAA,CAAAA,OAAAA,EAAAA,MAAAA;MAZF,CAAA;IAJF,CAAO,CAAP;EADF,CAAA,CAoBE,OAAA,CAAA,EAAU;IACVK,OAAAA,CAAAA,OAAAA,CAAAA,KAAAA,CAAAA,CAAAA;;IACA,MAAA,CAAA;EACD;AAxBH,CAAA;;;;AA2BA,IAAMC,KAAK,GAAG,iBAAA,GAAA,EAAA,OAAA;EAAA;EAAA;IAAA;MAAA;QAAA;UAAA;UAAA,iCAIS,CAAA,GAAA,UAAA,GAAA,OAAA,EAAA,GAAA,EAArB,OAAqB,CAJT;;QAAA;UAINN,MAJM;UAAA;UAAA,iCAKOO,iBAAiB,CAApC,MAAoC,CALxB;;QAAA;UAKNhB,IALM;;UAAA,MAORS,MAAM,CAANA,MAAAA,IAAJ,GAPY;YAAA;YAAA;UAAA;;UAAA,MAQJ,IAAIQ,OAAAA,CAAJ,QAAA,uCACgCR,MAAM,CAACS,MADvC,UAAN,IAAM,OARI;;QAAA;UAAA,kCAaL;YACLA,MAAM,EAAET,MAAM,CADT,MAAA;YAELU,OAAO,EAAEV,MAAM,CAFV,OAAA;YAGLT,IAAAA,EAAAA;UAHK,CAbK;;QAAA;QAAA;UAAA;MAAA;IAAA;EAAA;AAAA,CAAd","sourcesContent":["import * as os from 'os';\nimport * as path from 'path';\nimport * as fs from 'fs';\n\nimport nodeFetch, {\n  RequestInit as FetchOptions,\n  Response,\n  Request,\n  Headers,\n} from 'node-fetch';\nimport {CLIError} from './errors';\nimport logger from './logger';\n\nasync function unwrapFetchResult(response: Response) {\n  const data = await response.text();\n\n  try {\n    return JSON.parse(data);\n  } catch (e) {\n    return data;\n  }\n}\n\n/**\n * Downloads the given `url` to the OS's temp folder and\n * returns the path to it.\n */\nconst fetchToTemp = (url: string): Promise<string> => {\n  try {\n    return new Promise((resolve, reject) => {\n      const fileName = path.basename(url);\n      const tmpDir = path.join(os.tmpdir(), fileName);\n\n      nodeFetch(url).then((result) => {\n        if (result.status >= 400) {\n          return reject(`Fetch request failed with status ${result.status}`);\n        }\n\n        const dest = fs.createWriteStream(tmpDir);\n        result.body.pipe(dest);\n\n        result.body.on('end', () => {\n          resolve(tmpDir);\n        });\n\n        result.body.on('error', reject);\n      });\n    });\n  } catch (e) {\n    logger.error(e);\n    throw e;\n  }\n};\n\nconst fetch = async (\n  url: string | Request,\n  options?: FetchOptions,\n): Promise<{status: number; data: any; headers: Headers}> => {\n  const result = await nodeFetch(url, options);\n  const data = await unwrapFetchResult(result);\n\n  if (result.status >= 400) {\n    throw new CLIError(\n      `Fetch request failed with status ${result.status}: ${data}.`,\n    );\n  }\n\n  return {\n    status: result.status,\n    headers: result.headers,\n    data,\n  };\n};\n\nexport {fetch, fetchToTemp};\n"]},"metadata":{},"sourceType":"script"}